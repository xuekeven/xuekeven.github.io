

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Keven">
  <meta name="keywords" content="">
  
  <title>React Hook - Keven&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"siteId=16939915","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 50vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Keven's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/dome/">
                <i class="iconfont icon-th-large"></i>
                Dome
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tools/">
                <i class="iconfont icon-briefcase"></i>
                工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/example.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.2)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="React Hook">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Keven
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-12-03 22:00" pubdate>
        2022年12月3日
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      66
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">React Hook</h1>
            
            <div class="markdown-body">
              <p>参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html">https://zh-hans.reactjs.org/docs/hooks-reference.html</a> 。</p>
<h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate">https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate</a> 。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [state, setState] = useState(initialState);<br></code></pre></td></tr></table></figure>

<p>传入一个 <code>initialState</code> （也可以不传）；返回一个 <code>state</code>，以及更新 <code>state</code> 的函数 <code>setState</code>。在初始渲染期间，返回的状态 <code>state</code> 与传入的第一个参数 <code>initialState</code> 值相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">setState(newState);<br></code></pre></td></tr></table></figure>

<p><code>setState</code> 函数用于更新 <code>state</code>，它接收一个新的 <code>newState</code> 值并将组件的一次重新渲染加入队列。在后续的重新渲染中，<code>useState</code> 返回的第一个值将始终是更新后最新的 <code>state</code>。不过，如果 <code>setState</code> 函数接受的值与当前 <code>state</code> 值完全相同，则随后的重渲染会被完全跳过。</p>
<p>注意，React 会确保 <code>setState</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>setState</code>。</p>
<h2 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h2><p>如果新的 <code>state</code> 需要通过使用先前的 <code>state</code> 计算得出，那么可以将<strong>函数</strong>传递给 <code>setState</code>。该函数将接收先前的 <code>state</code>，并返回一个更新后的值。实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(initialCount);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      Count: &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count - 1)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。可以用函数式的 <code>setState</code> 结合展开运算符来达到合并更新对象的效果。（<code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 <code>state</code> 对象。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [state, setState] = useState(&#123;&#125;);<br><span class="hljs-comment">// ...</span><br>setState(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;...prevState, ...updatedValues&#125;; <span class="hljs-comment">// 也可以使用 Object.assign</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="惰性初始-state"><a href="#惰性初始-state" class="headerlink" title="惰性初始 state"></a>惰性初始 <code>state</code></h2><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 <code>state</code> 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 <code>state</code>，此函数只在初始渲染时被调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [state, setState] = useState(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> initialState = someExpensiveComputation(props);<br>  <span class="hljs-keyword">return</span> initialState;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="跳过-state-更新"><a href="#跳过-state-更新" class="headerlink" title="跳过 state 更新"></a>跳过 <code>state</code> 更新</h2><p>如前所述，如果更新 State Hook 后的 <code>state</code> 与当前的 <code>state</code> 相同时，React 将跳过子组件的渲染并且不会触发 effect 的执行。（React 使用 <code>Object.is</code> 比较算法 来比较 <code>state</code>）</p>
<p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p>
<h2 id="Batching-of-state-updates"><a href="#Batching-of-state-updates" class="headerlink" title="Batching of state updates"></a>Batching of state updates</h2><p>React may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.</p>
<p>Before React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.</p>
<p>In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in flushSync. However, this can hurt performance so do this only where needed.</p>
<p>React 可以将多个状态更新分组到单个重新渲染中以提高性能。通常，这会提高性能，并且不会影响应用程序的行为。</p>
<p>在 React 18 之前，只有 React 事件处理程序中的更新被批处理。从 React 18 开始，默认情况下为所有更新启用批处理。请注意，React 确保来自几个不同用户启动的事件的更新——例如，单击一个按钮两次——总是单独处理的，不会被批处理。这可以防止逻辑错误。</p>
<p>在极少数情况下，您需要强制同步应用 DOM 更新，您可以将其包装在 flushSync 中。但是，这可能会损害性能，因此请仅在需要时执行此操作。</p>
<h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><p>参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect">https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect</a> 。</p>
<h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">useEffect(didUpdate);<br></code></pre></td></tr></table></figure>

<p>该 Hook 接收一个包含命令式、且可能有副作用代码的函数。</p>
<p>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。</p>
<p>使用 <code>useEffect</code> 完成副作用操作。赋值给 <code>useEffect</code> 的函数会在<strong>组件渲染到屏幕之后</strong>执行。你可以把 <code>effect</code> 看作从 React 的纯函数式世界通往命令式世界的逃生通道。</p>
<p>默认情况下，<code>effect</code> 将在每轮渲染结束后执行，但你可以选择让它 [在只有某些值改变的时候()] 才执行。</p>
<h2 id="清除-effect"><a href="#清除-effect" class="headerlink" title="清除 effect"></a>清除 <code>effect</code></h2><p>通常，组件卸载时需要清除 <code>effect</code> 创建的诸如订阅或计时器 ID 等资源。要实现这一点，<code>useEffect</code> 函数需<strong>返回一个清除函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> subscription = props.source.subscribe();<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 清除订阅</span><br>    subscription.unsubscribe();<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 <code>effect</code> 之前，上一个 <code>effect</code> 就已被清除。在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都触发 <code>effect</code> 的执行，请参阅下一小节。</p>
<h2 id="effect-的执行时机"><a href="#effect-的执行时机" class="headerlink" title="effect 的执行时机"></a><code>effect</code> 的执行时机</h2><p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，传给 <code>useEffect</code> 的函数会<strong>在浏览器完成布局与绘制之后、在一个延迟事件中被调用</strong>。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作<strong>不应阻塞</strong>浏览器对屏幕的更新。</p>
<p>然而，并非所有 <code>effect</code> 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别）React 为此提供了一个额外的 <code>useLayoutEffect</code> Hook 来处理这类 <code>effect</code>。它和 <code>useEffect</code> 的结构相同，区别只是调用时机不同。</p>
<p>此外，从 React 18 开始，当它是离散的用户输入（如点击）的结果时，或者当它是由 flushSync 包装的更新结果时，传递给 <code>useEffect</code> 的函数将在屏幕布局和绘制之前同步执行。这种行为便于事件系统或 flushSync 的调用者观察该效果的结果。</p>
<p>即使在 <code>useEffect</code> 被推迟到浏览器绘制之后的情况下，它也能保证在任何新的渲染前启动执行。React 在开始新的更新前，总会先刷新之前的渲染的 <code>effect</code>。</p>
<h2 id="effect-的条件执行"><a href="#effect-的条件执行" class="headerlink" title="effect 的条件执行"></a><code>effect</code> 的条件执行</h2><p>默认情况下，<code>effect</code> 会在每轮组件渲染完成后执行。这样的话，一旦 <code>effect</code> 的依赖发生变化，它就会被重新创建。然而，在某些场景下这么做可能会矫枉过正。比如，我们可能不需要在每次组件更新时都创建新的订阅，而是仅需要在一些值改变时重新创建。</p>
<p>要实现这一点，可以给 <code>useEffect</code> 传递第二个参数，它是 <code>effect</code> 所依赖的值数组。如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">useEffect(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> subscription = props.source.subscribe();<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      subscription.unsubscribe();<br>    &#125;;<br>  &#125;,<br>  [props.source],<br>);<br></code></pre></td></tr></table></figure>

<p>依赖项数组不会作为参数传给 <code>effect</code> 函数。虽然从概念上来说它表现为：所有 <code>effect</code> 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p>
<p>注意，如果要使用此优化方式，请确保数组中包含了所有外部作用域中会发生变化且在 <code>effect</code> 中使用的变量，否则代码会引用到先前渲染中的旧变量。</p>
<p>如果想执行只运行一次的 <code>effect</code>（仅在组件挂载和卸载时执行），可以传递一个空数组作为第二个参数。这就告诉 React 你的 <code>effect</code> 不依赖于 <code>props</code> 和 <code>state</code> 中的任何值，所以它永远都不需要重复执行。</p>
<p>如果传入了一个空数组，<code>effect</code> 内部的 <code>props</code> 和 <code>state</code> 就会一直持有其初始值。尽管传入空数组作为第二个参数有点类似于 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 的思维模式，但我们有更好的方式 来避免过于频繁的重复调用 <code>effect</code>。除此之外，记得 React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code>，因此会使得处理额外操作很方便。</p>
<p>不传依赖项数组：<code>effct</code>会在每轮组件渲染完成后执行；传依赖项数组为空数组：<code>effct</code>会在组件挂载时仅执行一次。两者不同！</p>
<h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><p>参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext</a> 。</p>
<h2 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> value = useContext(MyContext);<br></code></pre></td></tr></table></figure>

<p>接收一个 <code>context</code> 对象（<code>React.createContext</code> 的返回值 <code>MyContext</code>）并返回该 <code>context</code> 的当前值。当前的 <code>context</code> 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p>
<p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 <code>context</code> <code>value</code> 值。即使祖先使用 <code>React.memo</code> 或 <code>shouldComponentUpdate</code>，也会在组件本身使用 <code>useContext</code> 时重新渲染。<code>useContext(MyContext)</code> 相当于 class 组件中的 <code>static contextType = MyContext</code> 或者 <code>&lt;MyContext.Consumer&gt;</code>。</p>
<p>注意，<code>useContext</code> 的参数必须是 <code>context</code> 对象本身，正确使用方法是 <code>useContext(MyContext)</code>，<code>useContext(MyContext.Consumer)</code>和<code>useContext(MyContext.Provider)</code> 都是错误的。</p>
<p>调用了 <code>useContext</code> 的组件总会在 <code>context</code> 值变化时重新渲染。如果重渲染组件的开销较大，可以通过使用 <code>memoization</code> 来优化。</p>
<p>实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> themes = &#123;<br>  <span class="hljs-attr">light</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;white&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">dark</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;black&quot;</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> ThemeContext = React.createContext(themes.light);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GroundFather</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;themes.dark&#125;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">GroundSon</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GroundSon</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> theme = useContext(ThemeContext);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">background:</span> <span class="hljs-attr">theme.background</span>, <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.foreground</span> &#125;&#125;&gt;</span></span><br><span class="xml">      I am styled by theme context!</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><p>参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer</a> 。</p>
<h2 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);<br></code></pre></td></tr></table></figure>

<p>这是 useState 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 <code>reducer</code>，并返回当前的 <code>state</code> 以及与其配套的 <code>dispatch</code> 方法。</p>
<p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 <code>state</code> 逻辑较复杂且包含多个子值，或者下一个 <code>state</code> 依赖于之前的 <code>state</code> 等。并且使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数。</p>
<p>实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> initialState = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      Count: &#123;state.count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>意，React 会确保 <code>dispatch</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code>。</p>
<h2 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h2><p>可以选择惰性地创建初始 <code>state</code>。为此，需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 <code>state</code> 将被设置为 <code>init(initialArg)</code>。</p>
<p>这么做可以将用于计算 <code>state</code> 的逻辑提取到 <code>reducer</code> 外部，这也为将来对重置 <code>state</code> 的 <code>action</code> 做处理提供了便利：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">initialCount</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: initialCount &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> init(action.payload);<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">&#123; initialCount &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      Count: &#123;state.count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27;, payload: initialCount &#125;)&#125;&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="跳过-dispatch"><a href="#跳过-dispatch" class="headerlink" title="跳过 dispatch"></a>跳过 dispatch</h2><p>如前所述，如果更新 Reducer Hook 后的 <code>state</code> 与当前的 <code>state</code> 相同时，React 将跳过子组件的渲染及副作用的执行。（React 使用 <code>Object.is</code> 比较算法来比较 <code>state</code>）</p>
<p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p>
<h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback">https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904101445124110">https://juejin.cn/post/6844904101445124110</a></li>
</ul>
<p>Demo：<a target="_blank" rel="noopener" href="https://github.com/xuekeven/learn-react/blob/main/src/hook/useCallBack/index.tsx">https://github.com/xuekeven/learn-react/blob/main/src/hook/useCallBack/index.tsx</a> 。</p>
<h2 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> memoizedCallback = useCallback(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    doSomething(a, b);<br>  &#125;,<br>  [a, b],<br>);<br></code></pre></td></tr></table></figure>

<p>简单来说就是传递一个返回的函数和依赖项，只有在依赖项发生变化的时候才会更新（返回一个新的函数），否则返回的原函数不变。</p>
<p>依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有的回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p>
<p>不要把所有的方法都包上 <code>useCallback</code>。<code>useCallback</code> 是要配合子组件的 <code>shouldComponentUpdate</code> 或 <code>React.memo</code> 一起来使用的，否则就是反向优化。</p>
<p>组件重新渲染时，<code>useCallback</code> 里面的函数也会声明一个新的函数，并被传入到 <code>useCallback</code> 中，尽管这个新的函数有可能因为依赖项没有发生改变不会被返回到定义的变量上。那么在这种情况下，它返回新的函数和老的函数也都一样，如果子组件没有使用 <code>shouldComponentUpdate</code> 或 <code>React.memo</code>，子组件都会被重新渲染，这时使用 <code>useCallback</code> 后每次执行到这里内部要要比对依赖项是否变化，还要存一下之前的函数，消耗更大了。</p>
<p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p>
<h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo">https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904101445124110">https://juejin.cn/post/6844904101445124110</a></li>
</ul>
<p>Demo：<a target="_blank" rel="noopener" href="https://github.com/xuekeven/learn-react/blob/main/src/hook/useMemo/index.tsx">https://github.com/xuekeven/learn-react/blob/main/src/hook/useMemo/index.tsx</a> 。</p>
<h2 id="基础-5"><a href="#基础-5" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> memoizedValue = useMemo(<span class="hljs-function">() =&gt;</span> computeExpensiveValue(a, b), [a, b]);<br></code></pre></td></tr></table></figure>

<p>简单来说就是传递一个创建函数和依赖项，创建函数需要返回一个值，只有在依赖项发生改变的时候，才会重新调用此函数返回一个新的值，否则返回的原值不变。</p>
<p><code>useMemo</code> 与 <code>useCallback</code> 很像，根据 <code>useCallback</code> 可以想到 <code>useMemo</code> 也能针对传入子组件的值进行缓存优化，有助于避免在每次渲染时都进行高开销的计算。</p>
<p>记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行不应该在渲染期间内执行的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p>
<p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p>
<p>依赖项数组不会作为参数传给“创建”函数。虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>可以把一些昂贵的计算逻辑放到 <code>useMemo</code> 中，只有当依赖值发生改变的时候才去更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> num = useMemo(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 这里使用 count 针对 num 做一些很复杂的计算，</span><br>  <span class="hljs-comment">// 当 count 没改变的时候，组件重新渲染就会直接返回之前缓存的值。</span><br>  <span class="hljs-keyword">return</span> num;<br>&#125;, [count]);<br><br><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>事实上在使用中 <code>useMemo</code> 的场景远比 <code>useCallback</code> 要广泛的很多，我们可以将 <code>useMemo</code> 的返回值定义为返回一个函数这样就可以变通的实现了 <code>useCallback</code>。在开发中当我们有部分变量改变时会影响到多个地方的更新那我们就可以返回一个对象或者数组，通过解构赋值的方式来实现同时对多个数据的缓存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [age, followUser] = useMemo(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> [<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear() - userInfo.birth, <span class="hljs-comment">// 根据生日计算年龄</span><br>    <span class="hljs-keyword">async</span> () =&gt; &#123; <span class="hljs-comment">// 关注用户</span><br>      <span class="hljs-keyword">await</span> request(<span class="hljs-string">&#x27;/follow&#x27;</span>, &#123; <span class="hljs-attr">uid</span>: userInfo.id &#125;);<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  ];<br>&#125;, [userInfo]);<br><br><span class="hljs-keyword">return</span> (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>name: &#123;userInfo.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>age: &#123;age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">followUser</span>=<span class="hljs-string">&#123;followUser&#125;/</span>&gt;</span></span><br><span class="xml">    &#123;</span><br><span class="xml">      useMemo(() =&gt; (</span><br><span class="xml">        // 如果 Card1 组件内部没有使用 React.memo 函数，那还可以通过这种方式在父组件减少子组件的渲染</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Card1</span> <span class="hljs-attr">followUser</span>=<span class="hljs-string">&#123;followUser&#125;/</span>&gt;</span></span><br><span class="xml">      ), [followUser])</span><br><span class="xml">    &#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br></code></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><code>useCallback</code> 与 <code>useMemo</code> 一个缓存的是函数，一个缓存的是函数的返回值。<br><code>useCallback</code> 是来优化子组件的，防止子组件的重复渲染。<code>useMemo</code> 可以优化当前组件也可以优化子组件，优化当前组件主要是通过 memoize 来将一些复杂的计算逻辑进行缓存。当然如果只是进行一些简单的计算也没必要使用 <code>useMemo</code>，这里可以考虑一些计算的性能消耗和比较依赖项的性能消耗来做一个权衡。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7104436526494253087">https://juejin.cn/post/7104436526494253087</a> 。</p>
<p>但是，关于是否使用这些，或许可以用一句话来总结：<br>如果没有性能瓶颈，那就建议不用，大部分项目你可能并不需要考虑以阻止 React 的渲染来提高性能 ———— 甚至可以说如果你不能保证收获比成本大的“多”，那就尽量不用。<br>其实这上面这句话也藏着性能优化的原则之一：不要过早优化。</p>
<h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p>参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useref">https://zh-hans.reactjs.org/docs/hooks-reference.html#useref</a> 。</p>
<h2 id="基础-6"><a href="#基础-6" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> refContainer = useRef(initialValue);<br></code></pre></td></tr></table></figure>

<p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 <code>ref</code> 对象在组件的整个生命周期内持续存在。</p>
<p>一个常见的用例便是命令式地访问子组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> inputEl = useRef(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span><br>    inputEl.current.focus();<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputEl&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。</p>
<p>应当熟悉 <code>ref</code> 这一种访问 DOM 的主要方式。如果将 <code>ref</code> 对象以<code> &lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 <code>ref</code> 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p>
<p>然而，<code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。这是因为它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 <code>ref</code> 对象。</p>
<p>当 <code>ref</code> 对象内容发生变化时，<code>useRef</code> 并不会通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 <code>ref</code> 时运行某些代码，则需要使用回调 <code>ref</code> 来实现。</p>
<h1 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h1><p>参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle">https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle</a> 。</p>
<h2 id="基础-7"><a href="#基础-7" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">useImperativeHandle(ref, createHandle, [deps])<br></code></pre></td></tr></table></figure>

<p><code>useImperativeHandle</code> 可以在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 <code>ref</code> 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code> 一起使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> inputRef = useRef(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">const</span> onClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    (inputRef <span class="hljs-keyword">as</span> any).current.focus()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;inputRef---&#x27;</span>, inputRef)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>Father<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">SonWrapper</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/&gt;</span></span> <br>&#125;<br><br><span class="hljs-keyword">const</span> SonWrapper = forwardRef(Son);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span> (<span class="hljs-params">props: any, ref: any</span>) </span>&#123;<br><br>  <span class="hljs-keyword">const</span> mouseIn = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;useImperativeHandle---mouseIn&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> mouseOut = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;useImperativeHandle---mouseOut&#x27;</span>)<br>  &#125;<br><br>  useImperativeHandle(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;useImperativeHandle---focus&#x27;</span>)<br>    &#125;, <br>    mouseOut<br>  &#125;), [mouseOut]);<br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Son<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><p>参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect">https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect</a> 。</p>
<h2 id="基础-8"><a href="#基础-8" class="headerlink" title="基础"></a>基础</h2><p>其函数签名与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 <code>effect</code>。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</p>
<p>尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p>
<p>注意，虽然 <code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的。但还是推荐先用 <code>useEffect</code>，当出现问题的时候再尝试使用 <code>useLayoutEffect</code>。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9D%97/">框架模块</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9D%97/React/">React</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/React/">React</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/04/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">React生命周期</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/24/JavaScript%E7%9F%A5%E8%AF%86/">
                        <span class="hidden-mobile">JavaScript知识</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Powered by Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Theme is Fluid</span></a>
  </div>
  

  

  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bbe44c28232a60458d913426edaff12f";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?siteId=16939915";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
