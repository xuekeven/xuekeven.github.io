<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript语言基础之语句</title>
    <link href="/2023/02/02/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%AD%E5%8F%A5/"/>
    <url>/2023/02/02/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>ECMA-262 描述了一些语句（也称为流控制语句），而 ECMAScript 大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><code>if</code>语句</h1><p><code>if</code> 语句是使用最频繁的语句之一，语法如下：<br><code>if (condition) statement1 else statement2</code></p><p>其中的条件（<code>condition</code>）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自动调用 <code>Boolean()</code> 函数将这个表达式的值转换为布尔值。如果条件求值为 <code>true</code>，则执行语句 <code>statement1</code>；如果条件求值为 <code>false</code>，则执行语句 <code>statement2</code>。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。</p><p>连续使用多个<code>if</code>语句：<br><code>if (condition1) statement1 else if (condition2) statement2 else statement3</code></p><p>语句是代码块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (condition) &#123;<br>  statements<br>&#125;<br><br><span class="hljs-keyword">if</span> (condition) &#123;<br>  statments1<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  statments2<br>&#125;<br><br><span class="hljs-keyword">if</span> (condition1) &#123;<br>  statments1<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2) &#123;<br>  statments2<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  statments3<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a><code>while</code>语句</h1><p><code>while</code> 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，<code>while</code> 循环体内的代码有可能不会执行。</p><p><code>while</code> 循环的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span> (expression) statement<br><br><span class="hljs-keyword">while</span> (expression) &#123;<br>  statement;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a><code>do-while</code>语句</h1><p><code>do-while</code> 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。</p><p><code>do-while</code> 循环的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;<br>  statement<br>&#125; <span class="hljs-keyword">while</span> (expression); <br></code></pre></td></tr></table></figure><h1 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a><code>for</code>语句</h1><p><code>for</code> 语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式。</p><p><code>for</code> 循环的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (initialization; expression; post-loop-expression) statement <br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(i); <br>&#125;<br></code></pre></td></tr></table></figure><p>无法通过 <code>while</code> 循环实现的逻辑，同样也无法使用 <code>for</code> 循环实现。因此，<code>for</code> 循环只是将循环相关的代码封装在一起。</p><p>在 <code>for</code> 循环的初始化代码中，其实可以不使用变量声明关键字。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了，最清晰的写法是使用 <code>let</code> 声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。</p><p>初始化、条件表达式和循环后表达式都不是必需的。因此可以创建无穷循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (;;) &#123;<br>  doSomething(); <br>&#125;<br></code></pre></td></tr></table></figure><p>如果只包含条件表达式，那么 <code>for</code> 循环实际上就变成了 <code>while</code> 循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> count = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <br><br><span class="hljs-keyword">for</span> (; i &lt; count; ) &#123; <br>  <span class="hljs-built_in">console</span>.log(i); <br>  i++;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a><code>for-in</code>语句</h1><p><code>for-in</code> 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (property <span class="hljs-keyword">in</span> expression) statement<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">in</span> expression) &#123;<br>  statement;<br>&#125; <br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propName <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) &#123; <br>  <span class="hljs-built_in">console</span>.log(propName); <br>&#125;<br></code></pre></td></tr></table></figure><p>ECMAScript 中对象的属性是无序的，因此 <code>for-in</code> 语句不能保证返回对象属性的顺序。就是说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异</p><p>如果 <code>for-in</code> 循环要迭代的变量是 <code>null</code> 或 <code>undefined</code>，则不执行循环体。</p><h1 id="for-of语句"><a href="#for-of语句" class="headerlink" title="for-of语句"></a><code>for-of</code>语句</h1><p><code>for-of</code> 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (property <span class="hljs-keyword">of</span> expression) statement<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> expression) &#123;<br>  statement;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]) &#123; <br>  <span class="hljs-built_in">console</span>.log(el); <br>&#125;<br></code></pre></td></tr></table></figure><p><code>for-of</code> 循环会按照可迭代对象的 <code>next()</code> 方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则 <code>for-of</code> 语句会抛出错误。</p><p>ES2018 对 <code>for-of</code> 语句进行了扩展，增加了 <code>for-await-of</code> 循环以支持生成期约的异步可迭代对象。</p><h1 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h1><p>标签语句用于给语句加标签，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">label: statement <br><br><span class="hljs-attr">start</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>  <span class="hljs-built_in">console</span>.log(i); <br>&#125; <br></code></pre></td></tr></table></figure><p>上方例子中，<code>start</code> 是一个标签，可以在后面通过 <code>break</code> 或 <code>continue</code> 语句引用。</p><p>标签语句的典型应用场景是嵌套循环。</p><h1 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a><code>break</code>和<code>continue</code>语句</h1><p><code>break</code> 和 <code>continue</code> 语句为执行循环代码提供了更严格的控制手段。</p><p><code>break</code> 用于立即退出循环，强制执行循环后的下一条语句；<code>continue</code> 用于立即退出循环，但会再次从循环顶部开始执行。</p><p><code>break</code> 和 <code>continue</code> 都可以与标签语句一起使用返回代码中特定的位置， 这通常是在嵌套循环中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">0</span>; <br>outermost1: <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123; <br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span> &amp;&amp; j == <span class="hljs-number">5</span>) &#123;<br>      <span class="hljs-keyword">break</span> outermost1; <br>    &#125; <br>    num1++; <br>  &#125; <br>&#125; <br><span class="hljs-built_in">console</span>.log(num1); <span class="hljs-comment">// 55</span><br><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0</span>; <br>outermost2:<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span> &amp;&amp; j == <span class="hljs-number">5</span>) &#123;<br>      <span class="hljs-keyword">continue</span> outermost2; <br>    &#125; <br>    num2++; <br>  &#125; <br>&#125; <br><span class="hljs-built_in">console</span>.log(num2); <span class="hljs-comment">// 95</span><br></code></pre></td></tr></table></figure><p>组合使用标签语句和 <code>break</code>、<code>continue</code> 能实现复杂的逻辑，执行外部循环，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p><h1 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a><code>with</code>语句</h1><p>with 语句的用途是将代码作用域设置为特定的对象，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">with</span> (expression) statement;<br><br><span class="hljs-keyword">with</span> (expression) &#123;<br>  statement;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用语句主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> qs = location.search.substring(<span class="hljs-number">1</span>); <br><span class="hljs-keyword">let</span> hostName = location.hostname; <br><span class="hljs-keyword">let</span> url = location.href; <br><br><span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">location</span>)</span> &#123; <br>  <span class="hljs-keyword">let</span> qs = search.substring(<span class="hljs-number">1</span>); <br>  <span class="hljs-keyword">let</span> hostName = hostname; <br>  <span class="hljs-keyword">let</span> url = href; <br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>with</code> 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 <code>with</code> 语句。</p><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h1><p><code>switch</code> 语句是与 <code>if</code> 语句紧密相关的一种流控制语句，跟 C 语言中 <code>switch</code> 语句的语法非常相似，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (expression) &#123;<br>  <span class="hljs-keyword">case</span> value1: <br>    statement;<br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">case</span> value2: <br>    statement;<br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">default</span>: <br>    statement;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 <code>case</code> 相当于：“如果表达式等于（使用全等操作符<code>===</code>比较）后面的值，则执行下面的语句。” <code>break</code> 关键字会导致代码执行跳出 <code>switch</code> 语句。如果没有 <code>break</code>，则代码会继续匹配下一个条件。<code>default</code> 关键字用于在任何条件都没有满足时指定默认执行的语句（相当于 <code>else</code> 语句）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (i == <span class="hljs-number">25</span>) &#123; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;25&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">35</span>) &#123; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;35&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">45</span>) &#123; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;45&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Other&quot;</span>); <br>&#125; <br><br><span class="hljs-keyword">switch</span> (i) &#123; <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;25&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">35</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;35&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">45</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;45&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">default</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Other&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>为避免不必要的条件判断，最好给每个条件后面都加上 <code>break</code> 语句。如果确实需连续匹配几个条件，那么推荐写个注释表明是故意忽略了 <code>break</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (i) &#123; <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>: <br>    <span class="hljs-comment">/*跳过*/</span> <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">35</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;25 or 35&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">45</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;45&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">default</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Other&quot;</span>); <br>&#125; <br></code></pre></td></tr></table></figure><p>虽然 <code>switch</code> 语句是从其他语言借鉴过来的，但 ECMAScript 为它赋予一些独有的特性。首先，<code>switch</code> 语句可以用于所有数据类型（在很多语言，它只能用于数值），因此可以使用字符串甚至对象。其次，条件的值不需要是常量，也可以是变量或表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (<span class="hljs-string">&quot;hello world&quot;</span>) &#123; <br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot; world&quot;</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Greeting was found.&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;goodbye&quot;</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Closing was found.&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">default</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Unexpected message was found.&quot;</span>); <br>&#125; <br><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">25</span>; <br><span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) &#123; <br>  <span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">0</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Less than 0.&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">case</span> num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt;= <span class="hljs-number">10</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Between 0 and 10.&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">case</span> num &gt; <span class="hljs-number">10</span> &amp;&amp; num &lt;= <span class="hljs-number">20</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Between 10 and 20.&quot;</span>); <br>    <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">default</span>: <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;More than 20.&quot;</span>); <br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语言基础之操作符</title>
    <link href="/2023/01/24/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <url>/2023/01/24/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators</a> 。</p><p>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 <code>valueOf()</code> 或 <code>toString()</code> 方法来取得可以计算的值。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>注：</p><ol><li>期待操作符类型中的<code>lval</code>即<code>lvalue(左值)</code>，意思是“一个可以合法地出现在赋值表达式左侧的表达式”。在 JavaScript 中，变量、对象元素、数组元素都是“左值”。</li><li>下表的操作符是按照优先级从高到低的顺序排列的，其中的横线分组了相同优先级的操作符。</li><li>“左”表示结合性为从左到右，“右”表示结合性为从右到左。</li></ol><p><img src="/images/JavaScript%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8A.jpg"><br><img src="/images/JavaScript%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8B.jpg" alt="JavaScript操作符"></p><h2 id="操作数个数"><a href="#操作数个数" class="headerlink" title="操作数个数"></a>操作数个数</h2><p>操作符可以按照它们期待的操作数个数（参数数量）来分类。</p><p>多数的 JavaScript 操作符都是二元操作符，可以将两个表达式组合成一个更复杂的表达式。换句话说，这些操作符期待两个操作数。</p><p>同时，JavaScript 也支持一元操作符，这些操作符将一个表达式转换为另一个更复杂的表达式。</p><p>最后，JavaScript 也支持一个三元操作符，即条件操作符，用于将三个表达式组合为一个表达式。</p><h2 id="操作数与结果类型"><a href="#操作数与结果类型" class="headerlink" title="操作数与结果类型"></a>操作数与结果类型</h2><p>有些操作数用于任何类型的数值，但是多数操作符期待自己的操作数是某种特定类型，而且多数操作符也返回（或求值为）特定类型的值，具体如上表。</p><p>JavaScript 操作符通常按照需要转换操作数的类型。如乘法操作符期待数值参数，但表达式<code>&#39;3&#39; * &#39;5&#39;</code>之所以合法，是因为 JavaScript 可以把操作数转化为数值，且其结果是数值15而不是字符串15。</p><p>也要记住，每个 JavaScript 值要么是“真值”要么是“假值”，因此期待布尔值的操作符可以用于任何类型的操作符。</p><p>有些操作符的行为会因为操作数类型的不同而不同。最明显的就是加法操作符，其可以把数值加起来，也可以拼接字符串；还有比较操作符根据操作数类型会俺早数值顺序或字母表顺序比较。</p><h2 id="操作符副效应"><a href="#操作符副效应" class="headerlink" title="操作符副效应"></a>操作符副效应</h2><p>大部分如<code>2 * 3</code>这样的简单表达式求值不会影响程序状态，程序后续的计算也不会北这个求值所影响。</p><p>但是有些表达式是有副效应的，即对它们求值可能影响将来求值的结果。赋值操作符就是一例，把一个值赋给变量或属性，会改变后续使用该变量或属性的表达式的值。同理，递增和递减操作符也有副效应。此外，<code>delete</code>操作符的副效应在于删除属性类似于（但不同于）给属性赋值<code>undefined</code>。</p><p>其它的操作符都没有副效应，但函数调用和对象创建表达式是否有副效应，取决于函数和构造函数体内是否使用了有副效应的操作符。</p><h2 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h2><p>靠近表格顶部的操作符咸鱼靠近表格底部的操作符先执行。</p><p>如 <code>w = x + y * z</code>，其中，乘法计算先与加法执行，最后赋值给左侧的变量。不过，具体的执行顺序可以由圆括号改写：``w = (x + y) * z`，这样便会先执行加法后进行乘法计算。</p><p>但是要注意，属性访问和调用表达式的优先级高于表格中的任何操作符。因为操作符要基于属性访问、数组索引和函数调用的结果执行，所以这些操作的优先级全部高于操作符。</p><p>如果不确定优先级，最简单的方法是使用圆括号明确求值顺序。最重要的规则在于：乘和除先于加和减执行，而赋值优先级很低，几乎总是最后执行。</p><p>JavaScript 新增的操作符并不总是符合这个优先级模式。比如，<code>??</code> 操作符比 <code>||</code> 和 <code>&amp;&amp;</code> 优先级低，而实际上它相对于这两个操作符的优先级并没有定义，ES2020 要求在混用 <code>??</code> 和 <code>||</code> 或 <code>&amp;&amp;</code> 时必须使用圆括号。类似地，<code>**</code> 相对于一元负值操作符的优先级也没有定义，因此在同时求负值和求幂时也必须使用圆括号。</p><h2 id="操作符结合性"><a href="#操作符结合性" class="headerlink" title="操作符结合性"></a>操作符结合性</h2><p>操作符结合性规定了相同优先级操作的执行顺序。左结合性意味着操作操作从做到右执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">w = x - y - z<br>y = a ** b ** c<br>x = ~-y<br>w = x = y = z<br>q = a ? b : c ? d : e ? f : g<br><br><span class="hljs-comment">// 等价于</span><br><br>w = ((x - y) - z)<br>y = (a ** (b ** c))<br>x = ~(-y)<br>w = (x = (y = z))<br>q = (a ? b : (c ? d : (e ? f : g)))<br></code></pre></td></tr></table></figure><p>这是因为，减操作符具有左结合性；而幂、一元、赋值、三元操作符具有右结合性。</p><h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>操作符的优先级和结合性规定了复杂表达式中操作的执行顺序，但它们没有规定子表达式的求值顺序。JavaScript 始终严格按照<strong>从左到右</strong>的顺序对表达式求值。</p><p>例如，在表达式 <code>w = x + y * z</code> 中，子表达式 w 首先被求值，再对 x、y 和 z 求值。然后将 y 和 z 相乘，加到 x 上，再把结果赋值给表达式 w 表示的变量或属性。使用圆括号会改变执行顺序，但不会改变从左到右的求值顺序。</p><h1 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h1><p>只操作一个值的操作符叫一元操作符，是 ECMAScript 中最简单的操作符。</p><h2 id="递增和递减操作符"><a href="#递增和递减操作符" class="headerlink" title="递增和递减操作符"></a>递增和递减操作符</h2><p>递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p><ul><li>前缀版：在跟其他操作混合时，变量的值在语句被求值之前改变（先递增递减后运算语句）</li><li>后缀版：在跟其他操作混合时，变量的值在语句被求值之后发生（先运算语句后递增递减）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> age1 = age2 = <span class="hljs-number">29</span>;<br><span class="hljs-comment">// 前缀版</span><br>++age1;<br>--age1;<br><span class="hljs-comment">// 后缀版</span><br>age1++;<br>age1--;<br><br><span class="hljs-built_in">console</span>.log(--age1 + <span class="hljs-number">2</span>); <span class="hljs-comment">// 30</span><br><span class="hljs-built_in">console</span>.log(age2-- + <span class="hljs-number">2</span>); <span class="hljs-comment">// 31</span><br><span class="hljs-built_in">console</span>.log(age1); <span class="hljs-comment">// 28</span><br><span class="hljs-built_in">console</span>.log(age2); <span class="hljs-comment">// 28</span><br></code></pre></td></tr></table></figure><p>这 4 个操作符可作用于任何值，整数、字符串、布尔值、浮点值，甚至对象都可。递增和递减操作符遵循如下规则：</p><ul><li>数值，直接改变后返回</li><li>布尔值，<code>true</code> 转换为 1，<code>false</code> 转换为 0，再应用改变，变量类型从布尔值变成数值</li><li>字符串，如果是有效的数值形式，则转换为数值再应用改变；如果非有效的数值形式，则将变量的值设置为 NaN ，变量类型从字符串变成数值</li><li>对象，则调用其 <code>valueOf()</code> 方法取得可以操作的值。对得到的值应用上述规则。如果是 <code>NaN</code>，则调用 <code>toString()</code> 并再次应用其他规则</li></ul><h2 id="一元加和减操作符"><a href="#一元加和减操作符" class="headerlink" title="一元加和减操作符"></a>一元加和减操作符</h2><p>它们在 ECMAScript 中跟在高中数学中的用途一样。</p><p>一元加由一个加号（<code>+</code>）表示，放在变量前头，对数值没有任何影响。如果将一元加应用到非数值，则会执行与使用 <code>Number()</code> 转型函数一样的类型转换：布尔值 <code>false</code> 和 <code>true</code> 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 <code>valueOf()</code>或 <code>toString()</code><br>方法以得到可以转换的值。</p><p>一元减由一个减号（<code>-</code>）表示，放在变量前头，用于把数值变成负值。如果将一元减应用到非数值，一元减会遵循与一元加同样的规则，先进行转换然后取负值。</p><h1 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h1><p>下面介绍的操作符用于数值的底层操作，也就是操作内存中表示数据的比特（位）。</p><h1 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h1><p>对于编程语言来说，布尔操作符跟相等操作符同样重要。如果没有能力测试两个值的关系，那么像 <code>if-else</code> 和循环这样的语句也没什么用。布尔操作符一共有 3 个：逻辑非（<code>!</code>）、逻辑与（<code>&amp;&amp;</code>）和逻辑或（<code>||</code>）。</p><h2 id="逻辑非（-）"><a href="#逻辑非（-）" class="headerlink" title="逻辑非（!）"></a>逻辑非（<code>!</code>）</h2><p>可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反，遵循如下规则：</p><ul><li>如果操作数是对象，则返回 <code>false</code></li><li>如果操作数是符号，则返回 <code>false</code></li><li>如果操作数是空字符串，则返回 <code>true</code></li><li>如果操作数是非空字符串，则返回 <code>false</code></li><li>如果操作数是数值 0，则返回 <code>true</code></li><li>如果操作数是非 0 数值（包括 Infinity），则返回 <code>false</code></li><li>如果操作数是 <code>null</code>，则返回 <code>true</code></li><li>如果操作数是 <code>NaN</code>，则返回 <code>true</code></li><li>如果操作数是 <code>undefined</code>，则返回 <code>true</code></li></ul><p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（<code>!!</code>），相当于调用转型函数 <code>Boolean()</code>。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与使用 <code>Boolean()</code> 函数一样。</p><h2 id="逻辑与（-amp-amp-）"><a href="#逻辑与（-amp-amp-）" class="headerlink" title="逻辑与（&amp;&amp;）"></a>逻辑与（<code>&amp;&amp;</code>）</h2><p>逻辑与操作符可用于任何类型的操作数。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：</p><ul><li>如果有一个操作数是 <code>null</code>，则返回 <code>null</code></li><li>如果有一个操作数是 <code>NaN</code>，则返回 <code>NaN</code></li><li>如果有一个操作数是 <code>undefined</code>，则返回 <code>undefined</code></li><li>如果第一个操作数是对象，则返回第二个操作数</li><li>如果第二个操作数是对象，则只第一个操作数求值为 <code>true</code> 才会返回该对象</li><li>如果两个操作数都是对象，则返回第二个操作数</li></ul><p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 <code>false</code>，那么无论第二个操作数是什么值，结果也不可能等于 <code>true</code>。</p><h2 id="逻辑或（-）"><a href="#逻辑或（-）" class="headerlink" title="逻辑或（||）"></a>逻辑或（<code>||</code>）</h2><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则</p><ul><li>如果两个操作数都是 <code>null</code>，则返回 <code>null</code></li><li>如果两个操作数都是 <code>NaN</code>，则返回 <code>NaN</code></li><li>如果两个操作数都是 <code>undefined</code>，则返回 <code>undefined</code></li><li>如果第一个操作数求值为 <code>false</code>，则返回第二个操作数</li><li>如果第一个操作数是对象，则返回第一个操作数</li><li>如果两个操作数都是对象，则返回第一个操作数</li></ul><p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。第一个操作数求值为 <code>true</code>，第二个操作数就不会再被求值。</p><h1 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h1><p>ECMAScript 定义了 3 个乘性操作符：乘法、除法和取模。这些操作符跟它们在 Java、C 语言及 Perl 中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用 <code>Number()</code> 转型函数转换为数值。</p><h2 id="乘法操作符（-）"><a href="#乘法操作符（-）" class="headerlink" title="乘法操作符（*）"></a>乘法操作符（<code>*</code>）</h2><p>用于计算两个数值的乘积。乘法操作符在处理特殊值时也有一些特殊的行为：</p><ul><li>若操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity</li><li>若有任一操作数是 <code>NaN</code>，则返回 <code>NaN</code></li><li>若是 Infinity 乘以 0，则返回 <code>NaN</code></li><li>若是 Infinity 乘以非 0的有限数值，则根据第二个操作数的符号返回 Infinity 或 -Infinity</li><li>若是 Infinity 乘以 Infinity，则返回 Infinity</li><li>若有不是数值的操作数，则先用 <code>Number()</code> 将其转换为数值，然后再应用上述规则</li></ul><h2 id="除法操作符（-）"><a href="#除法操作符（-）" class="headerlink" title="除法操作符（/）"></a>除法操作符（<code>/</code>）</h2><p>用于计算第一个操作数除以第二个操作数的商。跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为：</p><ul><li>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回 Infinity 或 -Infinity。</li><li>如果有任一操作数是 <code>NaN</code>，则返回 <code>NaN</code></li><li>如果是 Infinity 除以 Infinity，则返回 <code>NaN</code></li><li>如果是 0 除以 0，则返回 <code>NaN</code></li><li>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或 -Infinity</li><li>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或 -Infinity</li><li>如果有不是数值的操作数，则先用 <code>Number()</code> 函数将其转换为数值，然后再用上述规则</li></ul><h2 id="取模操作符（-）"><a href="#取模操作符（-）" class="headerlink" title="取模操作符（%）"></a>取模操作符（<code>%</code>）</h2><p>与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为：</p><ul><li>如果操作数是数值，则执行常规除法运算，返回余数</li><li>如果被除数是无限值，除数是有限值，则返回 <code>NaN</code></li><li>如果被除数是有限值，除数是 0，则返回 <code>NaN</code></li><li>如果是 Infinity 除以 Infinity，则返回 <code>NaN</code></li><li>如果被除数是有限值，除数是无限值，则返回被除数</li><li>如果被除数是 0，除数不是 0，则返回 0</li><li>如果有不是数值的操作数，则先用 <code>Number()</code> 函数将其转换为数值，然后再用上述规则</li></ul><h1 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h1><p>ECMAScript 7 新增了指数操作符，<code>Math.pow()</code> 现在有了自己的操作符 <code>**</code>，两者计算结果一样。<br>而且，指数操作符也有自己的指数赋值操作符 <code>**=</code>，该操作符执行指数运算和结果的赋值操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">16</span>, <span class="hljs-number">0.5</span>)); <span class="hljs-comment">// 4 </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">16</span>** <span class="hljs-number">0.5</span>); <span class="hljs-comment">// 4 </span><br><br><span class="hljs-keyword">let</span> squared = <span class="hljs-number">3</span>; <br>squared **= <span class="hljs-number">2</span>; <br><span class="hljs-built_in">console</span>.log(squared); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h1 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h1><h2 id="加法操作符（-）"><a href="#加法操作符（-）" class="headerlink" title="加法操作符（+）"></a>加法操作符（<code>+</code>）</h2><p>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：</p><ul><li>如果有任一操作数是 <code>NaN</code>，则返回 <code>NaN</code></li><li>如果是 Infinity 加 Infinity，则返回 Infinity</li><li>如果是 -Infinity 加 -Infinity，则返回 -Infinity</li><li>如果是 Infinity 加 -Infinity，则返回 <code>NaN</code></li><li>如果是 +0 加 +0，则返回 +0</li><li>如果是 -0 加 +0，则返回 +0</li><li>如果是 -0 加 -0，则返回 -0</li></ul><p>不过，如果有一个操作数是字符串，则要应用如下规则：</p><ul><li>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面</li><li>如果只有一个操作数是字符串，则将另一个操作数转为字符串，再将两个字符串拼接在一起</li></ul><p>如果有任一操作数是对象、数值或布尔值，则调用它们 <code>toString()</code> 方法以获取字符串，然后再应用关于字符串的规则。对于 <code>undefined</code> 和 <code>null</code>，则调用 <code>String()</code> 函数，分别获取 <code>undefined</code> 和 <code>null</code>。</p><p>ECMAScript 中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。</p><h2 id="减法操作符（-）"><a href="#减法操作符（-）" class="headerlink" title="减法操作符（-）"></a>减法操作符（<code>-</code>）</h2><p>减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换：</p><ul><li>如果两个操作数都是数值，则执行数学减法运算并返回结果</li><li>如果有任一操作数是 <code>NaN</code>，则返回 <code>NaN</code></li><li>如果是 Infinity 减 Infinity，则返回 <code>NaN</code></li><li>如果是 -Infinity 减-Infinity，则返回 <code>NaN</code></li><li>如果是 Infinity 减-Infinity，则返回 Infinity</li><li>如果是 -Infinity 减 Infinity，则返回 -Infinity</li><li>如果是 +0 减 +0，则返回 +0</li><li>如果是 +0 减 -0，则返回 -0</li><li>如果是 -0 减 -0，则返回 +0</li><li>若有任一操作数是字符串、布尔值、<code>null</code> 或 <code>undefined</code>，则先使用 <code>Number()</code> 将其转为数值，然后再根据前面的规则执行数学运算。若转换结果是 <code>NaN</code>，则结果是 <code>NaN</code></li><li>若有任一操作数是对象，则调用其 <code>valueOf()</code> 方法取得表示它的数值。如果该值是 <code>NaN</code>，则计算的结果是 <code>NaN</code>。如果对象没有 <code>valueOf()</code> 方法，则调用其 <code>toString()</code> 方法，然后再将得到的字符串转换为数值</li></ul><h1 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h1><p>关系操作符执行比较两个值的操作。</p><p>包括小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）、大于等于（<code>&gt;=</code>），这几个操作符返回布尔值。</p><p>与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为：</p><ul><li>如果操作数都是数值，则执行数值比较</li><li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码</li><li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较</li><li>如果有任一操作数是对象，则调用其 <code>valueOf()</code> 方法，取得结果后根据前面规则执行比较。如果没有 <code>valueOf()</code> 方法，则调用 <code>toString()</code> 方法，取得结果后根据前面规则比较</li><li>如果有任一操作数是布尔值，则将其转换为数值再执行比较</li></ul><p>对字符串而言，关系操作符会比较字符串中对应字符的编码，而这些编码是数值。比较完后会返回布尔值。问题的关键在于大写字母的编码都小于小写字母的编码。如，字母 B 的编码是 66，字母 b 的编码是 98。要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式（全大写或全小写），然后再比较。</p><p>另一个奇怪的现象是在比较两个数值字符串的时候。在比较字符串 <code>&quot;23&quot; &lt; &quot;3&quot;</code> 时返回 <code>true</code>。因为两个操作数都是字符串，所以会逐个比较它们字符编码（字符”2”的编码是 50，而字符”3”的编码是 51）。不过如果有一个操作数是数值，那么比较的结果就对了，<code>&quot;23&quot; &lt; 3</code> 时返回 <code>false</code>。只要是数值和字符串比较，字符串就会先被转为数值，然后进行数值比较。对于数值字符串而言，这样能保证结果正确。</p><p>但如果字符串不能转换成数值呢？如果字符不能转换成任何有意义的数值只能转换为 <code>NaN</code>，有一个规则，即任何关系操作符在涉及比较 <code>NaN</code> 时都返回 <code>false</code>。在大多数比较的场景中，如果一个值不小于另一个值，那就一定大于或等于它。但在比较 <code>NaN</code> 时，无论是小于还是大于等于，比较的结果都会返回 <code>false</code>。</p><h1 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h1><p>判断两个变量是否相等是编程中最重要操作之一。</p><p>在比较字符串、数值和布尔值是否相等时过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂。ECMAScript 中的相等和不相等操作符，原本在比较之前会执行类型转换，但是有人质疑这种转换是否应该发生。最终，ECMAScript 提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换。</p><h2 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h2><p>等于操作符（<code>==</code>），如果操作数相等，则会返回 <code>true</code>；不等于操作符（<code>!=</code>），如果两个操作数不相等，则会返回 <code>true</code>。这两个操作符会先进行类型转换（称为强制类型转换）再确定操作数是否相等。</p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则：</p><ul><li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。<code>false</code> 转换为 0，<code>true</code> 转换为 1</li><li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等</li><li>如果一个操作数是对象，另一个操作数不是对象，则调用对象的 valueOf() 方法取得其原始值，再根据前面规则进行比较</li></ul><p>在进行比较时，这两个操作符会遵循如下规则：</p><ul><li><code>null</code> 和 <code>undefined</code> 相等</li><li><code>null</code> 和 <code>undefined</code> 不能转换为其他类型的值再进行比较</li><li>如果有任一操作数是 <code>NaN</code>，则相等操作符返回 <code>false</code>，不相等操作符返回 <code>true</code>。记住：即使两个操作数都是 <code>NaN</code>，相等操作符也返回 <code>false</code>，因为按照规则，<code>NaN</code> 不等于 <code>NaN</code></li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 <code>true</code>。否则，两者不相等</li></ul><p>下表总结了一些特殊情况及比较的结果：</p><table><thead><tr><th align="center">表达式</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center"><code>null == undefined</code></td><td align="center">true</td></tr><tr><td align="center"><code>&quot;NaN&quot; == NaN</code></td><td align="center">false</td></tr><tr><td align="center"><code>5 == NaN</code></td><td align="center">false</td></tr><tr><td align="center"><code>NaN == NaN</code></td><td align="center">false</td></tr><tr><td align="center"><code>NaN != NaN</code></td><td align="center">true</td></tr><tr><td align="center"><code>false == 0</code></td><td align="center">true</td></tr><tr><td align="center"><code>true == 1</code></td><td align="center">true</td></tr><tr><td align="center"><code>true == 2</code></td><td align="center">false</td></tr><tr><td align="center"><code>undefined == 0</code></td><td align="center">false</td></tr><tr><td align="center"><code>null == 0</code></td><td align="center">false</td></tr><tr><td align="center"><code>&quot;5&quot; == 5</code></td><td align="center">true</td></tr></tbody></table><h2 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h2><p>全等和不全等操作符与相等和不相等操作符类似，只不过在比较相等时不转换操作数。</p><p>全等操作符（<code>===</code>），只有两个操作数在不转换的前提下相等才返回 <code>true</code>。不全等操作（<code>!==</code>），只有两个操作数在不转换的前提下不相等才返回 <code>true</code>。由于相等和不相等操作符存在类型转换问题，推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性</p><h1 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h1><p>条件操作符是 ECMAScript 中用途最为广泛的操作符之一。</p><p><code>const variable = boolean_expression ? true_value : false_value;</code><br>如果 <code>boolean_expression</code> 是 <code>true</code> ，则赋 <code>variable</code> 值为 <code>true_value</code>；如果 <code>boolean_expression</code> 是 <code>false</code>，则赋 <code>variable</code> 值为 <code>false_value</code>。</p><h1 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h1><p>简单赋值（<code>=</code>），将右手边的值赋给左手边的变量。复合赋值使用乘性、加性或位操作符后跟等于号（<code>=</code>）表示。</p><p>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p><ul><li>乘后赋值（<code>*=</code>） </li><li>除后赋值（<code>/=</code>）</li><li>取模后赋值（<code>%=</code>）</li><li>加后赋值（<code>+=</code>）</li><li>减后赋值（<code>-=</code>）</li><li>指数赋值（<code>**=</code>）</li><li>左移后赋值（<code>&lt;&lt;=</code>）</li><li>右移后赋值（<code>&gt;&gt;=</code>）</li><li>无符号右移后赋值（<code>&gt;&gt;&gt;=</code>）</li></ul><p>这些操作符仅仅是简写语法，使用它们不会提升性能。</p><h1 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h1><p>逗号操作符可以用来在一条语句中执行多个操作。</p><p><code>let num1 = 1, num2 = 2, num3 = 3;</code><br>在一条语句中同时声明多个变量是逗号操作符最常用的场景。</p><p><code>let num = (5, 1, 4, 8, 0); // num 的值为 0</code><br>也可以使用逗号操作符来辅助赋值，赋值时最终会返回表达式中最后一个值。逗号操作符的这种使用场景并不多见，但这种行为的确存在。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语言基础之变量</title>
    <link href="/2023/01/20/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F/"/>
    <url>/2023/01/20/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。</p><p>有 3 个关键字可以声明变量：<code>var</code>、<code>const</code>、<code>let</code>。其中，<code>var</code> 在 ECMAScript 的所有版本中都可以使用，而 <code>const</code> 和 <code>let</code> 只能在 ECMAScript 6 及更晚的版本中使用。</p><h1 id="var"><a href="#var" class="headerlink" title="var"></a><code>var</code></h1><p>要定义变量，可以使用 <code>var</code> 后跟变量名，可以用它保存任何类型的值。（不初始化的情况下，变量会保存特殊值为 <code>undefined</code> ）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message;<br></code></pre></td></tr></table></figure><p>ECMAScript 实现变量初始化，因此可以同时定义变量并设置它的值。初始化变量并不会将它标识为某一类型，只是简单的赋值。随后，<strong>不仅可以改变</strong>保存的值，<strong>也可以改变</strong>值的类型。虽然不推荐改变变量保存值的类型，但这在 ECMAScript 中是完全有效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hi&quot;</span>; <br>message = <span class="hljs-number">100</span>; <span class="hljs-comment">// 合法，但不推荐</span><br></code></pre></td></tr></table></figure><h2 id="声明作用域"><a href="#声明作用域" class="headerlink" title="声明作用域"></a>声明作用域</h2><p>使用 <code>var</code> 定义的变量会成为包含它的函数的<strong>局部变量</strong>。比如，使用 <code>var</code> 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁。</p><p>不过在函数内定义变量时省略 <code>var</code> 可以创建一个全局变量。只要调用一次函数，就会定义这个变量，而且可以在函数外部访问到。虽然可以通过省略 <code>var</code> 定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略 <code>var</code> 是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hi&quot;</span>; <span class="hljs-comment">// 局部变量</span><br>&#125; <br>test1(); <br><span class="hljs-built_in">console</span>.log(message); <span class="hljs-comment">// Uncaught ReferenceError: message is not defined</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params"></span>) </span>&#123; <br>  message = <span class="hljs-string">&quot;hi&quot;</span>; <span class="hljs-comment">// 全局变量</span><br>&#125; <br>test2(); <br><span class="hljs-built_in">console</span>.log(message); <span class="hljs-comment">// &quot;hi&quot; </span><br></code></pre></td></tr></table></figure><p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）。</p><p>ECMAScript 是松散类型的，所以使用不同数据类型初始化的变量可以用一条语句来声明。插入换行和空格缩进并不是必需的，但这样有利于阅读理解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hi&quot;</span>,<br>    found = <span class="hljs-literal">false</span>,<br>    age = <span class="hljs-number">29</span>;<br></code></pre></td></tr></table></figure><p>在严格模式下，不能定义名为 eval 和 arguments 的变量，否则会导致语法错误。</p><h2 id="声明提升"><a href="#声明提升" class="headerlink" title="声明提升"></a>声明提升</h2><p>使用 <code>var</code> 声明的变量会自动被提升到作用域顶部，在声明前先读取变量不会报错；省略 <code>var</code> 声明会定义全局变量，但不会提升到作用域顶部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo1</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 等价于下面 foo2 代码</span><br>  <span class="hljs-built_in">console</span>.log(age); <br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">26</span>; <br>&#125; <br>foo1(); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params"></span>) </span>&#123; <br>  <span class="hljs-keyword">var</span> age; <br>  <span class="hljs-built_in">console</span>.log(age); <br>  age = <span class="hljs-number">26</span>; <br>&#125; <br>foo2(); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo3</span>(<span class="hljs-params"></span>) </span>&#123; <br>  <span class="hljs-built_in">console</span>.log(age); <br>  age = <span class="hljs-number">26</span>; <br>&#125; <br>foo3(); <span class="hljs-comment">// Uncaught ReferenceError: age is not defined</span><br></code></pre></td></tr></table></figure><h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>此外，反复多次使用 <code>var</code> 声明同一个变量也没有问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo4</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">16</span>; <br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">26</span>; <br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">36</span>; <br>  <span class="hljs-built_in">console</span>.log(age); <br>&#125; <br>foo4(); <span class="hljs-comment">// 36 </span><br><br><span class="hljs-keyword">let</span> age; <br><span class="hljs-keyword">var</span> age; <span class="hljs-comment">// Uncaught SyntaxError: Identifier &#x27;age&#x27; has already been declared</span><br></code></pre></td></tr></table></figure><h2 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h2><p><code>var</code> 在全局作用域中声明变量，该变量会成为 <code>window</code> 对象的属性。</p><h1 id="let"><a href="#let" class="headerlink" title="let"></a><code>let</code></h1><p><code>let</code> 跟 <code>var</code> 的作用差不多，但有着非常重要的区别。</p><h2 id="声明作用域-1"><a href="#声明作用域-1" class="headerlink" title="声明作用域"></a>声明作用域</h2><p>最明显的区别是，<code>let</code> 声明的范围是<strong>块作用域</strong>，<code>var</code> 声明的范围是<strong>函数作用域</strong>，块作用域是函数作用域的子集，因此适用于 <code>var</code> 的作用域限制同样也适用于 <code>let</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br>  <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// Matt </span><br>&#125; <br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// Matt </span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br>  <span class="hljs-keyword">let</span> age = <span class="hljs-number">26</span>; <br>  <span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// 26 </span><br>&#125; <br><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// Uncaught ReferenceError: age is not defined</span><br></code></pre></td></tr></table></figure><h2 id="声明提升-1"><a href="#声明提升-1" class="headerlink" title="声明提升"></a>声明提升</h2><p><code>let</code> 与 <code>var</code> 的另一个重要的区别，就是 <code>let</code> 声明的变量不会在作用域中被提升。</p><p>在解析代码时，JavaScript 引擎也会注意出现在块后面的 <code>let</code> 声明，只不过在此之前不能以任何方式来引用未声明的变量。在 <code>let</code> 声明之前的执行瞬间被称为“暂时性死区” ，此阶段引用任何后面才声明的变量都会抛出 ReferenceError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// name 会被提升</span><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// undefined </span><br><span class="hljs-comment">// age 不会被提升</span><br><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// Uncaught ReferenceError: age is not defined</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><span class="hljs-keyword">let</span> age = <span class="hljs-number">26</span>; <br></code></pre></td></tr></table></figure><h2 id="重复声明-1"><a href="#重复声明-1" class="headerlink" title="重复声明"></a>重复声明</h2><p><code>let</code> 不允许同一个块作用域中声明已被声明过的变量，这样会报错。而且，被 <code>let</code> 声明过的变量也不能被再次声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name; <br><span class="hljs-keyword">var</span> name; <br><br><span class="hljs-keyword">let</span> age; <br><span class="hljs-keyword">let</span> age; <span class="hljs-comment">// Uncaught SyntaxError: Identifier &#x27;age&#x27; has already been declared</span><br><br><span class="hljs-keyword">var</span> name; <br><span class="hljs-keyword">let</span> name; <span class="hljs-comment">// Uncaught SyntaxError: Identifier &#x27;name&#x27; has already been declared</span><br><br><span class="hljs-keyword">let</span> age; <br><span class="hljs-keyword">var</span> age; <span class="hljs-comment">// Uncaught SyntaxError: Identifier &#x27;age&#x27; has already been declared</span><br></code></pre></td></tr></table></figure><h2 id="全局声明-1"><a href="#全局声明-1" class="headerlink" title="全局声明"></a>全局声明</h2><p>与 <code>var</code> 不同，使用 <code>let</code> 在全局作用域中声明的变量不会成为 <code>window</code> 对象的属性。</p><h2 id="条件声明"><a href="#条件声明" class="headerlink" title="条件声明"></a>条件声明</h2><p>在使用 <code>var</code> 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 <code>let</code> 的作用域是块，所以不可能检查前面是否已经使用 <code>let</code> 声明过同名变量，同时也就不可能在没有声明的情况下声明它。</p><p>使用 <code>try/catch</code> 语句或 <code>typeof</code> 操作符也不能解决，因为条件块 <code>let</code> 声明的作用域仅限于该块。</p><h2 id="for-循环中"><a href="#for-循环中" class="headerlink" title="for 循环中"></a><code>for</code> 循环中</h2><p>在 <code>let</code> 出现之前，<code>for</code> 循环定义的迭代变量会渗透到循环体外部。改成使用 <code>let</code> 之后，这个问题就消失了，因为迭代变量的作用域仅限于 <code>for</code> 循环块内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123; <br>  <span class="hljs-comment">// 循环逻辑 </span><br>&#125; <br><span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 5 </span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> u = <span class="hljs-number">0</span>; u &lt; <span class="hljs-number">5</span>; ++u) &#123; <br>  <span class="hljs-comment">// 循环逻辑</span><br>&#125; <br><span class="hljs-built_in">console</span>.log(u); <span class="hljs-comment">// Uncaught SyntaxError: Identifier &#x27;u&#x27; has already been declared</span><br></code></pre></td></tr></table></figure><p>在使用 <code>var</code> 的时候，最常见的问题就是对迭代变量的奇特声明和修改。在退出循环时迭代变量保存的是导致循环退出的值。在之后执行超时逻辑时，所有的变量都是同一个变量，因而输出的都是同一个最终值。而在使用 <code>let</code> 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个超时逻辑引用的都是不同的变量实例。</p><p>这种每次迭代声明一个独立变量实例的行为适用于所有 <code>for</code> 循环，包括 <code>for-in</code> 和 <code>for-of</code> 循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123; <br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>) <br>&#125; <br><span class="hljs-comment">// 以为输出 0、1、2、3、4 </span><br><span class="hljs-comment">// 实际输出 5、5、5、5、5</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123; <br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>) <br>&#125; <br><span class="hljs-comment">// 输出 0、1、2、3、4 </span><br></code></pre></td></tr></table></figure><h1 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h1><p><code>const</code> 的行为与 <code>let</code> 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><p><code>const</code> 声明的限制只适用于它指向的变量的引用。换句话说，如果 <code>const</code> 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 <code>const</code> 的限制。</p><p>JavaScript 引擎会为 <code>for</code> 循环中的 <code>let</code> 声明分别创建独立的变量实例，虽然 <code>const</code> 变量跟 <code>let</code> 变量很相似，但是不能用 <code>const</code> 来声明迭代变量（因为迭代变量会自增）。</p><p>如果只想用 <code>const</code> 声明一个不会被修改的 <code>for</code> 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 <code>for-of</code> 和 <code>for-in</code> 循环特别有意义。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>ECMAScript 6 增加 <code>let</code> 和 <code>const</code> 从客观上为这门语言更精确地声明作用域和语义提供了更好支持。行为怪异的 <code>var</code> 所造成的各种问题，已经让 JavaScript 社区为之苦恼了很多年。随着这两个新关键字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。</p><ul><li><p>不使用 <code>var</code><br>限制自己只使用 <code>let</code> 和 <code>const</code> 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p></li><li><p><code>const</code> 优先，<code>let</code> 次之<br>使用 <code>const</code> 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 <code>const</code> 来声明变量，只在提前知道未来会有修改时，再使用 <code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML基础</title>
    <link href="/2023/01/02/HTML%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/02/HTML%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<ul><li>基础<ul><li>声明<ul><li><code>&lt;!doctype html&gt;</code></li></ul></li><li>开头<ul><li><code>&lt;html&gt;&lt;/html&gt;</code></li></ul></li><li>头部<ul><li><code>&lt;head&gt;&lt;/body&gt;</code></li></ul></li><li>页面<ul><li><code>&lt;body&gt;&lt;/body&gt;</code></li></ul></li><li>数据<ul><li><code>&lt;meta&gt;</code></li></ul></li><li>题目<ul><li><code>&lt;title&gt;&lt;/title&gt;</code></li></ul></li><li>标题<ul><li><code>&lt;h1&gt;&lt;/h1&gt;</code></li></ul></li><li>页眉<ul><li><code>&lt;header&gt;&lt;/header&gt;</code></li></ul></li><li>导航<ul><li><code>&lt;nav&gt;&lt;/nav&gt;</code></li></ul></li><li>主区<ul><li><code>&lt;main&gt;&lt;/main&gt;</code></li></ul></li><li>文章<ul><li><code>&lt;article&gt;&lt;/article&gt;</code></li></ul></li><li>区块<ul><li><code>&lt;section&gt;&lt;/section&gt;</code></li></ul></li><li>附注<ul><li><code>&lt;aside&gt;&lt;/aside&gt;</code></li></ul></li><li>页脚<ul><li><code>&lt;footer&gt;&lt;/footer&gt;</code></li></ul></li><li>通用<ul><li><code>&lt;div&gt;&lt;/div&gt;</code></li></ul></li><li>注释<ul><li><code>&lt;!----&gt;</code></li></ul></li></ul></li><li>文本<ul><li>新的段落<ul><li><code>&lt;p&gt;&lt;/p&gt;</code></li></ul></li><li>行内通用<ul><li><code>&lt;span&gt;&lt;/span&gt;</code></li></ul></li><li>细则旁注<ul><li><code>&lt;small&gt;&lt;/small&gt;</code><ul><li>元素内文本小字号显示，行内文本小块短语</li><li>输入表示免责声明、注意事项、法律限制、版权信息、署名、注解等文本</li></ul></li></ul></li><li>重要文本<ul><li><code>&lt;strong&gt;&lt;/strong&gt;</code><ul><li>元素内文本粗体显示，可以嵌套</li></ul></li></ul></li><li>提醒注意<ul><li><code>&lt;b&gt;&lt;/b&gt;</code><ul><li>元素内文本粗体显示</li></ul></li></ul></li><li>强调文本<ul><li><code>&lt;em&gt;&lt;/em&gt;</code><ul><li>元素内文本斜体显示，可以嵌套</li></ul></li></ul></li><li>不同常规<ul><li><code>&lt;i&gt;&lt;/i&gt;</code><ul><li>元素内文本斜体显示</li></ul></li></ul></li><li>创建图类<ul><li><code>&lt;figure&gt;&lt;/figure&gt;</code><ul><li>可选图类标题<code>&lt;figcaption&gt;&lt;/figcaption&gt;</code></li><li>用于图表、照片、视频、插图、代码片段等独立内容</li></ul></li></ul></li><li>引用参考<ul><li><code>&lt;cite&gt;&lt;/cite&gt;</code><ul><li>元素内文本斜体显示</li><li>指明对某内容源的引用或参考，不用于人名</li></ul></li></ul></li><li>块级引述<ul><li><code>&lt;blockquote&gt;&lt;/blockquote&gt;</code><ul><li>元素内文本缩进，可以嵌套</li><li>单独存在的引述，可长可短</li><li>属性<ul><li>cite：引述来源地址</li></ul></li></ul></li></ul></li><li>行内引述<ul><li><code>&lt;q&gt;&lt;/q&gt;</code><ul><li>元素内文本加引号，可以嵌套</li><li>短的引述，不可跨段</li><li>属性<ul><li>cite：引述来源地址</li></ul></li></ul></li></ul></li><li>指定时间<ul><li><code>&lt;time&gt;&lt;/time&gt;</code><ul><li>指定准确时间、日期或时间段</li><li>属性<ul><li>datetime<ul><li>时间格式：YYYY-MM-DDThh:mm:ss</li></ul></li></ul></li></ul></li></ul></li><li>解释缩写<ul><li><code>&lt;abbr&gt;&lt;/abbr&gt;</code><ul><li>元素内文本有虚线下划线显示</li><li>鼠标移到其上后显示解释</li></ul></li></ul></li><li>定义术语<ul><li><code>&lt;dfn&gt;&lt;/dfn&gt;</code><ul><li>元素内文本英语斜体显示汉语黑体显示</li><li>只包围术语词而非整个定义</li></ul></li></ul></li><li>创建上标<ul><li><code>&lt;sup&gt;&lt;/sup&gt;</code><ul><li>元素内文本字号减少几磅，会轻微扰乱行间距</li></ul></li></ul></li><li>创建下标<ul><li><code>&lt;sub&gt;&lt;/sub&gt;</code><ul><li>元素内文本字号减少几磅，会轻微扰乱行间距</li></ul></li></ul></li><li>联系作者<ul><li><code>&lt;address&gt;&lt;/address&gt;</code><ul><li>元素内文本斜体显示</li></ul></li></ul></li><li>新插文本<ul><li><code>&lt;ins&gt;&lt;/ins&gt;</code><ul><li>元素内文本显示下划线</li><li>属性<ul><li>cite：说明编辑原因</li><li>datatime：提供编辑时间</li></ul></li></ul></li></ul></li><li>已删文本<ul><li><code>&lt;del&gt;&lt;/del&gt;</code><ul><li>元素内文本显示删除线</li><li>属性<ul><li>cite：说明编辑原因</li><li>datatime：提供编辑时间</li></ul></li></ul></li></ul></li><li>无用文本<ul><li><code>&lt;s&gt;&lt;/s&gt;</code><ul><li>元素内文本显示删除线</li></ul></li></ul></li><li>标记代码<ul><li><code>&lt;code&gt;&lt;/code&gt;</code><ul><li>默认为等宽字体</li></ul></li></ul></li><li>预格式化<ul><li><code>&lt;pre&gt;&lt;/pre&gt;</code><ul><li>保持文本固有的换行和空格，一般用于代码</li><li>默认为等宽字体</li></ul></li></ul></li><li>荧光突出<ul><li><code>&lt;mark&gt;&lt;/marl&gt;</code><ul><li>元素内文本荧光笔样式背景显示</li></ul></li></ul></li><li>创建换行<ul><li><code>&lt;br&gt;</code><ul><li>需要换行地方使用</li></ul></li></ul></li><li>测量结果<ul><li><code>&lt;meter&gt;&lt;/meter&gt;</code><ul><li>表示分数的值或已知范围的测量结果</li><li>不提供定义好的单位，但可用title 属性指定单位</li><li>属性<ul><li>value</li><li>optimum</li><li>from</li><li>min</li><li>max</li><li>low</li><li>high</li></ul></li></ul></li></ul></li><li>完成进度<ul><li><code>&lt;progress&gt;&lt;/progress&gt;</code><ul><li>指示某项任务的完成进度，显示为进度条</li><li>属性<ul><li>value</li><li>max</li></ul></li></ul></li></ul></li><li>添加旁注<ul><li><code>&lt;ruby&gt;&lt;/ruby&gt;</code><ul><li>表示生僻字的发音，出现在标注字符的上方或右方</li></ul></li></ul></li><li>注解旁注<ul><li><code>&lt;rt&gt;&lt;/rt&gt;</code><ul><li>使用前有<code>&lt;ruby&gt;</code></li><li>对基准字符进行注解的旁注字符</li></ul></li></ul></li><li>辅助旁注<ul><li><code>&lt;rt&gt;&lt;/rt&gt;</code><ul><li>使用前有<code>&lt;ruby&gt;</code>和<code>&lt;rt&gt;</code></li><li>在不支持ruby浏览器的旁注文本周围显示括号</li></ul></li></ul></li></ul></li><li>链接<ul><li>指向网页<ul><li><code>&lt;a&gt;&lt;/a&gt;</code><ul><li>属性<ul><li>href：设置目标网页的URL<ul><li>可以使用井号和id属性值连接到特定锚</li></ul></li><li>target：打开连接时跳转到一个新网页<ul><li>可以设置新网页的窗口题目</li></ul></li></ul></li></ul></li></ul></li><li>指向其它<ul><li><code>&lt;a&gt;&lt;/a&gt;</code><ul><li>属性<ul><li>href：设置目标类型的URL<ul><li>可以指向文件，浏览器不会处理时便会下载它</li></ul></li></ul></li></ul></li></ul></li><li>外部资源链接<ul><li><code>&lt;link&gt;&lt;/link&gt;</code></li></ul></li></ul></li><li>列表<ul><li>有序列表<ul><li><code>&lt;ol&gt;&lt;/ol&gt;</code></li></ul></li><li>无序列表<ul><li><code>&lt;ul&gt;&lt;/ul&gt;</code></li></ul></li><li>列表项目<ul><li><code>&lt;li&gt;&lt;/li&gt;</code></li></ul></li><li>嵌套列表<ul><li>多个<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>或<code>&lt;dl&gt;</code></li></ul></li><li>描述列表<ul><li><code>&lt;dl&gt;&lt;/dl&gt;</code>：专门用于描述成组出现的名称（术语）</li><li><code>&lt;dt&gt;&lt;/dt&gt;</code>：名称或术语</li><li><code>&lt;dd&gt;&lt;/dd&gt;</code>：名称或术语的值</li></ul></li></ul></li><li>媒体<ul><li>图像<ul><li><code>&lt;img&gt;</code></li></ul></li><li>视频<ul><li><code>&lt;video&gt;&lt;/video&gt;</code></li></ul></li><li>音频<ul><li><code>&lt;audio&gt;&lt;/video&gt;</code></li></ul></li><li>多个播放源<ul><li><code>&lt;source&gt;</code><ul><li>使用前有<code>&lt;video&gt;</code>或<code>&lt;audio&gt;</code></li></ul></li></ul></li></ul></li><li>表单<ul><li>创建表单<ul><li><code>&lt;form&gt;&lt;/form&gt;</code><ul><li>包含一个或多个表单元素</li><li>属性<ul><li>accept-charset：规定服务器可处理的表单数据字符集</li><li>action：设置提交表单时向URL发送表单数据</li><li>autocomplete：是否启用表单的自动填写功能<ul><li>on</li><li>off</li></ul></li><li>enctype：规定在向服务器发送表单数据之前如何对其进行编码（适用于 method=”post” ）</li><li>method：发送表单数据的 HTTP 方法<ul><li>get</li><li>post</li></ul></li><li>name：规定表单的名称</li><li>novalidate：使用该属性则提交表单时不验证</li><li>target：规定在何处打开 action 的 URL</li></ul></li></ul></li></ul></li><li>表单分组<ul><li><code>&lt;fieldset&gt;&lt;/fieldset&gt;</code><ul><li>对表单中的相关表单元素分组，会在相关表单元素周围绘制边框</li><li>属性<ul><li>disabled：禁用本组中的某个表单元素</li><li>form：规定本组所属的一个或多个表单</li><li>name：规定本组的名称</li></ul></li></ul></li></ul></li><li>分组标题<ul><li><code>&lt;legend&gt;&lt;/legend&gt;</code><ul><li>为<code>&lt;fieldset&gt;</code>元素定标题</li></ul></li></ul></li><li>定义按钮<ul><li><code>&lt;button&gt;&lt;/button&gt;</code><ul><li>属性<ul><li>type：规定按钮的类型<ul><li>button</li><li>reset</li><li>submit</li></ul></li><li>autofocus：当页面加载时自动获得焦点</li><li>disabled：禁用按钮</li><li>form：规定按钮属的一个或多个表单</li><li>name：规定按钮的名称</li><li>value：按钮的初始值</li></ul></li></ul></li></ul></li><li>定义输入域<ul><li><code>&lt;input&gt;</code><ul><li><code>&lt;label&gt;</code> 为 <code>&lt;input&gt;</code> 定标注，<code>&lt;input&gt;</code> 的 id 属性与 <code>&lt;label&gt;</code> 的 for 属性通过相同值来绑定</li><li>属性<ul><li>type：提交元素的类型<ul><li>text：单行的文本区域，输入中的换行会被自动去除。默认值。</li><li>button：没有默认行为的按钮，上面显示 value 属性的值，默认为空</li><li>checkbox：复选框，可设为选中或未选中</li><li>color：用于指定颜色的控件；在支持的浏览器中，激活时会打开取色器</li><li>date：输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时会打开日期选择器或年月日的数字滚轮</li><li>datetime-local：输入日期和时间的控件，不包括时区。在支持的浏览器激活会时打开日期选择器或年月日的数字滚轮</li><li>email：编辑邮箱地址的区域。类似 text ，但在支持的浏览器和带有动态键盘的设备上会有确认参数和相应的键盘</li><li>file：让用户选择文件的控件。使用 accept 属性规定控件能选择的文件类型</li><li>hidden：不显示的控件，其值仍会提交到服务器</li><li>image：带图像的 submit 按钮。显示的图像由 src 属性规定。若 src 缺失，alt 属性显示</li><li>month：输入年和月的控件，没有时区</li><li>number：用于输入数字的控件。如果支持的话，会显示滚动按钮并提供缺省验证（即只能输入数字）。拥有动态键盘的设备上会显示数字键盘</li><li>password：单行的文本区域，其值会被遮盖。如果站点不安全，会警告用户</li><li>radio：单选框，允许在多个拥有相同 name 值的选项中选中其中一个</li><li>range：此控件用于输入不需要精确的数字。控件是一个范围组件，默认值为正中间值</li><li>reset：此按钮将表单的所有内容重置为默认值。不推荐。</li><li>search：用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标</li><li>submit：用于提交表单的按钮</li><li>tel：用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘</li><li>time：用于输入时间的控件，不包括时区</li><li>url：用于输入 URL 的控件。类似 text ，但有验证参数，在支持动态键盘的设备会上有相应的键盘</li><li>week：用于输入以年和周数组成的日期，不带时区</li></ul></li><li>id：规定 input 控件与哪个 label 标注绑定</li><li>form：规定 input 控件所属的一个或多个表单</li><li>name：input 表单控件的名字。以名字/值对的形式随表单一起提交</li><li>value：input 表单控件的值。以名字/值对的形式随表单一起提交</li><li>autocomplete：是否启用表单的自动填写功能</li><li>autofocus：当页面加载时自动获得焦点</li><li>disabled：规定表单控件是否被禁用</li><li>readonly：布尔值。存在时表示控件的值不可编辑</li><li>required：布尔值。表示此值为必填项或者提交表单前必须先检查该值</li><li>max：规定允许的最大数</li><li>min：规定允许的最小数</li><li>maxlength：规定允许的最多字符数</li><li>minlength：规定允许的最少字符数</li><li>multiple：规定允许用户输入的多个值</li><li>placeholder：当表单控件为空时，控件中显示的内容</li><li>checked：用于控制控件是否被选中</li></ul></li></ul></li></ul></li><li>输入域标注<ul><li><code>&lt;label&gt;&lt;/label&gt;</code><ul><li><code>&lt;label&gt;</code> 为 <code>&lt;input&gt;</code> 定标注，<code>&lt;input&gt;</code> 的 id 属性与 <code>&lt;label&gt;</code> 的 for 属性通过相同值来绑定</li><li>属性<ul><li>for：规定 label 标注与哪个 input 控件绑定</li><li>form：规定 label 标注所属的一个或多个表单</li></ul></li></ul></li></ul></li><li>定义文本域<ul><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code><ul><li>定义一个多行的文本输入控件</li><li>属性<ul><li>autofocus：当页面加载时自动获得焦点</li><li>cols：规定文本区域内可见的宽度</li><li>disabled：禁用文本区域</li><li>form：规定文本区域属的一个或多个表单</li><li>maxlength：规定文本区域允许的最大字符数</li><li>name：规定文本区域的名称</li><li>placeholder：提示，描述文本区域期望的输入值</li><li>readonly：规定文本区域为只读</li><li>required：规定用户提交表单前文本区域必填</li><li>rows：规定文本区域内可见的行数</li><li>wrap：规定当提交表单时，文本区域中怎样换行</li></ul></li></ul></li></ul></li><li>定义下拉列表<ul><li><code>&lt;select&gt;&lt;/select&gt;</code><ul><li>属性<ul><li>autofocus：当页面加载时自动获得焦点</li><li>disabled：禁用本按钮</li><li>form：规定按钮属的一个或多个表单</li><li>multiple：属性为true时可选择多个选项</li><li>name：规定下拉列表的名称</li><li>required：规定用户提交表单前必须选一个下拉列表中的项</li><li>size：规定下拉列表中可见选项的数目</li></ul></li></ul></li></ul></li><li>下拉列表选项组<ul><li><code>&lt;optgroup&gt;&lt;/optgroup&gt;</code><ul><li>把相关的选项组合在一起</li><li>属性<ul><li>disabled：禁用该选项组</li><li>label：标注值</li></ul></li></ul></li></ul></li><li>列表选项<ul><li><code>&lt;option&gt;&lt;/option&gt;</code><ul><li>为<code>&lt;select&gt;</code>或<code>&lt;datalist&gt;</code>使用</li><li>属性<ul><li>disabled：禁用选项</li><li>label：标注值</li><li>selected：规定选项表现为选中状态</li><li>value：选项值</li></ul></li></ul></li></ul></li><li>定义预定项<ul><li><code>&lt;datalist&gt;&lt;/datalist&gt;</code><ul><li>为 <code>&lt;input&gt;</code> 提供”自动完成”的特性</li></ul></li></ul></li></ul></li><li>表格<ul><li>创建<ul><li><code>&lt;table&gt;&lt;/table&gt;</code></li></ul></li><li>标题<ul><li><code>&lt;caption&gt;&lt;/caption&gt;</code><ul><li>为整个表格添加一个标题</li></ul></li></ul></li><li>行头部<ul><li><code>&lt;thead&gt;&lt;/thead&gt;</code><ul><li>将一行或多行标题标记为表格的头部，不影响表格布局</li></ul></li></ul></li><li>行数据<ul><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code><ul><li>用于包围所有数据行，不影响表格布局</li></ul></li></ul></li><li>行尾部<ul><li><code>&lt;tfoot&gt;&lt;/tfoot&gt;</code><ul><li>将一行或多行标记为表格的尾部，不影响表格布局</li></ul></li></ul></li><li>行<ul><li><code>&lt;tr&gt;&lt;/tr&gt;</code></li></ul></li><li>标题单元格<ul><li><code>&lt;th&gt;&lt;/th&gt;</code><ul><li>属性<ul><li>scope：告诉辅助设备当前标题是列的还是行的<ul><li>col：列的标题单元格</li><li>row：行的标题单元格</li></ul></li></ul></li></ul></li></ul></li><li>数据单元格<ul><li><code>&lt;td&gt;&lt;/td&gt;</code><ul><li>属性<ul><li>colspan：跨多行</li><li>rowspan：跨多列</li></ul></li></ul></li></ul></li></ul></li><li>标签全局属性<ul><li>accesskey</li><li>autocapitalize</li><li>class</li><li>contenteditable</li><li>data-*</li><li>dir</li><li>draggable</li><li>dropzone</li><li>exportparts</li><li>hidden</li><li>id</li><li>inputmode</li><li>is</li><li>itemid</li><li>itemprop</li><li>itemref</li><li>itemscope</li><li>itemtype</li><li>lang</li><li>part</li><li>slot</li><li>spellcheck</li><li>style</li><li>tabindex</li><li>title</li><li>translate</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2023/01/02/CSS%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/02/CSS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<ul><li><p>基础</p><ul><li>显示类型<ul><li>display<ul><li>display 属性可以设置元素的内部和外部显示类型。元素的外部显示类型将会决定该元素在流式布局中的表现；元素的内部显示类型可以控制其子元素的布局</li><li>display 属性使用关键字取值来指定，关键字取值被分为六类</li><li>display-outside（外部值）<ul><li>这些关键字指定了元素的外部显示类型</li><li>block：这个值会生成一个块级元素盒子，该元素之前和之后打断（换行）</li><li>inline：这个值会生成一个行内元素盒子，该元素之前和之后不会打断（换行）。如果空间充足，该元素后的元素将会在同一行显示</li><li>run-in：这个值生成一个 run-in 盒子。如果其后的兄弟元素是块级盒子，那么此 run-in 盒子就会以兄弟元素的第一个行内元素盒子的形式存在；如果其后的兄弟元素是行内元素，那么这个run-in盒子会变成块级元素。run-in元素的存在形式取决于相邻元素，如果它的内部存在 block box，那么它会变成块级元素盒子</li></ul></li><li>display-inside（内部值）<ul><li>这些关键字指定了元素的内部显示类型</li><li>flow：目前含义不清，实验室阶段产品</li><li>flow-root：可以让元素块状化，同时包含 BFC，可以用来清除浮动，去除 margin 合并，实现两栏自适应布局等</li><li>table：此元素作为块级表格来显示（类似 <code>&lt;table&gt;</code>），表格前后带有换行符</li><li>flex：此元素作为一个弹性布局盒子</li><li>grid：此元素作为一个网格布局盒子</li><li>ruby：此元素可以显示旁注标记，与 ruby 标签配合使用</li></ul></li><li>display-listitem（列表值）<ul><li>将这个元素的外部显示类型变为 block 盒，内部显示类型变为多个 list-item inline 盒</li><li>list-item：此元素作为列表显示</li></ul></li><li>display-internal（属性值）<ul><li>有些布局模型（如 table 和 ruby）有着复杂的内部结构，因此它们的子元素可能扮演着不同的角色。这一类关键字就是用来定义这些“内部”显示类型，并且只有在这些特定的布局模型中才有意义</li><li>table-row-group：此元素作为一个或多个行的分组来显示（类似 <code>&lt;tbody&gt;</code>）</li><li>table-header-group：此元素作为一个或多个行的分组显示（类似 <code>&lt;thead&gt;</code>）</li><li>table-footer-group：此元素作为一个或多个行的分组显示（类似 <code>&lt;tfoot&gt;</code>）</li><li>table-row：此元素作为一个表格行显示（类似 <code>&lt;tr&gt;</code>）</li><li>table-cell：此元素作为一个表格单元格显示（类似 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code>）</li><li>table-column-group：此元素作为一个或多个列的分组显示（类似 <code>&lt;colgroup&gt;</code>）</li><li>table-column：此元素作为一个单元格列显示（类似 <code>&lt;col&gt;</code>）</li><li>table-caption：此元素作为一个表格标题显示（类似 <code>&lt;caption&gt;</code>）</li><li>ruby-base：此元素的行为类似于 <code>&lt;rb&gt;</code></li><li>ruby-text：此元素的行为类似于 <code>&lt;rt&gt;</code></li><li>ruby-base-container：此元素的行为类似于 <code>&lt;rbc&gt;</code></li><li>ruby-text-container：此元素的行为类似 <code>&lt;rtc&gt;</code></li></ul></li><li>display-box（显示值）<ul><li>这些值决定元素是否使用盒模型</li><li>none：关闭此元素的显示，不影响布局（文件中没有该元素）。所有子项的显示也被关闭。要一个元素占据空间（文件中存在），但不渲染，使用 visibility 属性</li><li>contents：此元素自己不显示。它们被它们的伪盒和子项盒取代</li></ul></li><li>display-legacy（混合值）<ul><li>CSS Level 3 规范详细说明了 display 属性的两类取值——显式地指定了外部和内部显示属性的规范——但是还没有被浏览器广泛支持</li><li>inline-block：此元素会产生一个块元素盒子，并且像内联盒子一样（表现得更像一个被替换的元素），可以融入到周围内容中</li><li>inline-table：此元素作为内联表格显示（类似 <code>&lt;table&gt;</code>），表现为一个不同于块级盒子的内联盒子。表盒子内部是一个块级上下文</li><li>inline-flex：元素表现为一个内联元素，并对内容采用弹性盒子模型进行布局</li><li>inline-grid：元素表现为一个内联元素，并对内容采用网格模型进行布局</li></ul></li></ul></li></ul></li><li>可见性<ul><li>visibility<ul><li>visible：元素是可见的。默认值。</li><li>hidden：元素是不可见的</li><li>collapse：当在表格元素中使用时，此值可删除一行或一列，但它不影响表格布局。它被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上会呈现为 “hidden”</li></ul></li></ul></li><li>高度<ul><li>height<ul><li>不显式设置，浏览器会使用 auto</li></ul></li><li>min-height<ul><li>属性指定最小或最大值，而不是明确定义高度，元素就可以在这些界限内自动决定高度</li></ul></li><li>max-height<ul><li>属性指定最小或最大值，而不是明确定义高度，元素就可以在这些界限内自动决定高度</li><li>在小区域上会填满屏幕，在大区域上它会扩展到最大值。相比设置 height，这种方式能够有效避免在小区域上出现垂直滚动条</li></ul></li></ul></li><li>宽度<ul><li>width<ul><li>不显式设置，浏览器会使用 auto</li></ul></li><li>min-width<ul><li>属性指定最小或最大值，而不是明确定义宽度，元素就可以在这些界限内自动决定宽度</li></ul></li><li>max-width<ul><li>属性指定最小或最大值，而不是明确定义宽度，元素就可以在这些界限内自动决定宽度</li><li>在小视口上会填满屏幕，在大视口上它会扩展到最大值。相比设置 width，这种方式能够有效避免在小屏幕上出现水平滚动条</li></ul></li></ul></li><li>内边距<ul><li>padding<ul><li>简记法，同时设置四个边的内边距。如果需要，输入 -top、-right、-bottom、-left 将边框效果限制在某一条边上<ul><li>padding-top</li><li>padding-right</li><li>padding-bottom</li><li>padding-left</li></ul></li><li>padding 值为百分比时，其值是基于其父元素的宽度（width，不包含 padding 和 border）来定义的</li></ul></li></ul></li><li>外边距<ul><li>margin<ul><li>简记法，同时设置四个边的内边距。如果需要，输入 -top、-right、-bottom、-left 将边框效果限制在某一条边上<ul><li>margin-top</li><li>margin-right</li><li>margin-bottom</li><li>margin-left</li></ul></li></ul></li></ul></li><li>水平对齐<ul><li>text-align<ul><li>定义行内元素的内容如何相对它的块父元素对齐</li><li>left：行内内容向左侧边对齐。默认值由浏览器决定。</li><li>right：行内内容向右侧边对齐</li><li>center：行内内容居中</li><li>justify：文字向两侧对齐，对最后一行无效</li><li>justify-all：和 justify 一致，但是强制使最后一行两端对齐</li></ul></li></ul></li><li>垂直对齐<ul><li>vertical-align<ul><li>指定行内元素（inline）或表格单元格元素（table-cell）的垂直对齐方式</li><li>行内元素的值<ul><li>baseline：使元素的基线与父元素的基线对齐。默认值。</li><li>sub：使元素的基线与父元素的下标基线对齐</li><li>super：使元素的基线与父元素的上标基线对齐</li><li>text-top：使元素的顶部与父元素的字体顶部对齐</li><li>text-bottom：使元素的底部与父元素的字体底部对齐</li><li>top：使元素及其后代元素的顶部与整行的顶部对齐</li><li>middle：把此元素放置在父元素的中部</li><li>bottom：使元素及其后代元素的底部与整行的底部对齐</li><li><code>&lt;length&gt;</code>：将元素升高或降低指定的高度，可以是负数</li><li>%：使用 “line-height” 属性的百分比值来排列此元素，允许使用负值</li></ul></li><li>表格单元格元素的值<ul><li>baseline：使单元格的基线，与该行中所有以基线对齐的其它单元格的基线对齐</li><li>top：使单元格内边距的上边缘与该行顶部对齐</li><li>middle：使单元格内边距盒模型在该行内居中对齐</li><li>bottom：使单元格内边距的下边缘与该行底部对齐</li></ul></li></ul></li></ul></li><li>处理溢出<ul><li>overflow<ul><li>visible：内容不会被修剪，让元素盒子中的所有内容可见。默认值。</li><li>hidden：裁剪内容 - 不提供滚动机制</li><li>scroll：裁剪内容 - 提供滚动机制</li><li>auto：让滚动条仅在访问者访问溢出内容时出现</li></ul></li><li>overflow-x<ul><li>visible：内容不会被修剪，让元素盒子中的所有内容可见。默认值。</li><li>hidden：裁剪内容 - 不提供滚动机制</li><li>scroll：裁剪内容 - 提供滚动机制</li><li>auto：让滚动条仅在访问者访问溢出内容时出现</li><li>no-display：如果内容不适合内容框，则删除整个框</li><li>no-content：如果内容不适合内容框，则隐藏整个内容</li></ul></li><li>overflow-y<ul><li>visible：内容不会被修剪，让元素盒子中的所有内容可见。默认值。</li><li>hidden：裁剪内容 - 不提供滚动机制</li><li>scroll：裁剪内容 - 提供滚动机制</li><li>auto：让滚动条仅在访问者访问溢出内容时出现</li><li>no-display：如果内容不适合内容框，则删除整个框</li><li>no-content：如果内容不适合内容框，则隐藏整个内容</li></ul></li></ul></li><li>指针形状<ul><li>cursor<ul><li>default：默认光标</li><li>crosshair：光标呈现为十字线</li><li>move：此光标指示某对象可被移动</li><li>wait：此光标指示程序正忙（通常是一只表或沙漏）</li><li>help：此光标指示可用的帮助（通常是一个问号或一个气球）</li><li>text：此光标指示文本</li><li>x-resize：显示双向箭头，x是其中一个箭头需指向的方向，可以是 n、nw</li></ul></li></ul></li><li>边框<ul><li>border<ul><li>简记法，同时设置四个边框的 border-style、border-width、border-color 属性</li><li>如果需要，输入 -top、-right、-bottom、-left 将边框效果限制在某一条边上<ul><li>border-top<ul><li>简记法，同时设置上边框的 border-style、border-width、border-color 属性</li><li>border-top-style</li><li>border-top-width</li><li>border-top-color</li></ul></li><li>border-right<ul><li>简记法，同时设置右边框的 border-style、border-width、border-color 属性</li><li>border-right-style</li><li>border-right-width</li><li>border-right-color</li></ul></li><li>border-bottom<ul><li>简记法，同时设置下边框的 border-style、border-width、border-color 属性</li><li>border-bottom-style</li><li>border-bottom-width</li><li>border-bottom-color</li></ul></li><li>border-left<ul><li>简记法，同时设置左边框的 border-style、border-width、border-color 属性</li><li>border-left-style</li><li>border-left-width</li><li>border-left-color</li></ul></li></ul></li></ul></li></ul></li><li>边框风格<ul><li>border-style<ul><li>简记法，同时设置四个边框的风格属性。如果需要，输入 -top、-right、-bottom、-left 将边框效果限制在某一条边上<ul><li>border-top-style</li><li>border-right-style</li><li>border-bottom-style</li><li>border-left-style</li></ul></li><li>none：不显示边框。默认值。</li><li>dotted：点线</li><li>dashed：虚线</li><li>solid：实线</li><li>double：双线</li><li>groove：槽线</li><li>ridge：脊线</li><li>inset：凹边</li><li>outset：凸边</li></ul></li></ul></li><li>边框宽度<ul><li>border-width<ul><li>简记法，同时设置四个边框的宽度属性。如果需要，输入 -top、-right、-bottom、-left 将边框效果限制在某一条边上<ul><li>border-top-width</li><li>border-right-width</li><li>border-bottom-width</li><li>border-left-width</li></ul></li><li>medium：定义中等的边框。默认值。</li><li>thin：定义细的边框</li><li>thick：定义粗的边框</li><li>length：允许自定义边框的宽度</li></ul></li></ul></li><li>边框颜色<ul><li>border-color<ul><li>简记法，同时设置四个边框的颜色属性。如果需要，输入 -top、-right、-bottom、-left 将边框效果限制在某一条边上<ul><li>border-top-color</li><li>border-right-color</li><li>border-bottom-color</li><li>border-left-color</li></ul></li><li>transparent：指定边框的颜色应该是透明的。默认值。</li><li>colo：指定背景颜色</li></ul></li></ul></li><li>边框图像<ul><li>border-image<ul><li>简记法，同时设置四个边框的 border-image-source、border-image-slice、 border-image-width、border-image-outset、border-image-repeat 属性</li></ul></li></ul></li><li>边框图像位置<ul><li>border-image-source<ul><li>none：没有图像被使用。默认值。</li><li>image：边框使用图像的路径</li></ul></li></ul></li><li>边框图像边界向内偏移<ul><li>border-image-slice</li></ul></li><li>边框图像边界宽度<ul><li>border-image-width</li></ul></li><li>边框图像越界大小<ul><li>border-image-outset</li></ul></li><li>边框图像填充<ul><li>border-image-repea<ul><li>stretch：拉伸图像来填充区域。默认值。</li><li>repeat：平铺（repeated）图像来填充区域</li><li>round：类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域</li><li>space：类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围</li></ul></li></ul></li><li>背景<ul><li>background<ul><li>简记法，同时设置 background-color、background-image、background-size、background-repeat、background-position、background-origin、background-attachment、background-chip 属性</li></ul></li></ul></li><li>背景颜色<ul><li>background-color</li></ul></li><li>背景图像<ul><li>background-image</li></ul></li><li>背景图像重复<ul><li>background-repeat<ul><li>repeat：背景图像将向垂直和水平方向重复。这是默认</li><li>repeat-x：只有水平位置会重复背景图像</li><li>repeat-y：只有垂直位置会重复背景图像</li><li>no-repeat：不重复</li></ul></li></ul></li><li>背景图像滚动<ul><li>background-attachment<ul><li>scroll：背景图片随着页面的滚动而滚动，这是默认的</li><li>fixed：背景图片不会随着页面的滚动而滚动</li><li>local：背景图片会随着元素内容的滚动而滚动</li></ul></li></ul></li><li>背景图像位置<ul><li>background-position<ul><li>left top</li><li>left center</li><li>left bottom</li><li>right top</li><li>right center</li><li>right bottom</li><li>center top</li><li>center center</li><li>center bottom</li><li>x% y%<ul><li>第一个值是水平位置，第二个值是垂直。左上角是0％0％。右下角是100％100％。如果仅指定了一个值，其他值将是50％。 。默认值为：0％0％</li></ul></li><li>xpos ypos<ul><li>第一个值是水平位置，第二个值是垂直。左上角是0。</li></ul></li></ul></li></ul></li></ul></li><li><p>文本</p><ul><li>字体<ul><li>font<ul><li>简记法，同时设置字体 font-style、font-weight、font-size、font-height、font-family 属性</li><li>必须始终显式地声明文本大小和字体属性：先是字体大小，再是字体系列</li><li>行高是可选的，但它如果出现就必须紧跟在字体大小和斜杠后面</li></ul></li></ul></li><li>类型<ul><li>font-family</li></ul></li><li>斜体<ul><li>font-style<ul><li>normal：浏览器显示一个标准的字体样式，默认值</li><li>italic：浏览器会显示一个斜体的字体样式</li><li>oblique；浏览器会显示一个倾斜的字体样式</li></ul></li></ul></li><li>粗细<ul><li>font-weight<ul><li>normal：定义标准的字符。默认值。</li><li>bold：定义粗体字符，常用</li><li>bolder：定义更粗的字符</li><li>lighter：定义更细的字符</li><li>100-900：定义由细到粗的字符。400 等同于 normal，而 700 等同于 bold</li></ul></li></ul></li><li>大小<ul><li>font-size<ul><li>xx-small</li><li>x-small</li><li>small</li><li>medium：默认值</li><li>large</li><li>x-large</li><li>xx-large</li><li>smaller：设置为比父元素更小的尺寸</li><li>larger：设置为比父元素更大的尺寸</li><li>length：设置为一个固定的值</li></ul></li></ul></li><li>行高<ul><li>line-height<ul><li>normal：设置合理的行间距。默认。</li><li>number：设置数字，此数字会与当前的字体尺寸相乘来设置行间距</li><li>length：设置固定的行间距</li></ul></li></ul></li><li>颜色<ul><li>color</li></ul></li><li>字间距<ul><li>word-spacing</li></ul></li><li>字偶距<ul><li>letter-spacing</li></ul></li><li>首行缩进<ul><li>text-indent</li></ul></li><li>单词内断行<ul><li>word-break<ul><li>normal：使用浏览器默认的换行规则</li><li>break-all：可在任意字符间换行，允许在单词内换行</li><li>keep-all：文本不断行，只能在半角空格或连字符处换行</li></ul></li></ul></li><li>大小写<ul><li>text-transform<ul><li>none：定义带有小写字母和大写字母的标准的文本。默认</li><li>capitalize：文本中的每个单词以大写字母开头</li><li>uppercase：定义仅有大写字母</li><li>lowercase：定义仅有小写字母</li></ul></li></ul></li><li>小型大写<ul><li>font-variant<ul><li>normal：浏览器会显示一个标准的字体。默认值</li><li>small-caps：浏览器会显示小型大写字母的字体。并非所有的字体都有对应小型大写字母设计</li></ul></li></ul></li><li>文本线条<ul><li>text-decoration<ul><li>none<ul><li>定义标准的文本。默认。</li></ul></li><li>underline<ul><li>下划线</li></ul></li><li>overline<ul><li>上划线</li></ul></li><li>line-through<ul><li>删除线</li></ul></li><li>blink<ul><li>闪烁文本</li></ul></li><li>除了 a 元素外，也可以应用到其他元素</li></ul></li><li>text-decoration-style<ul><li>solid<ul><li>线条将显示为单线。默认值。</li></ul></li><li>double<ul><li>线条将显示为双线</li></ul></li><li>dotted<ul><li>线条将显示为点状线</li></ul></li><li>dashed<ul><li>线条将显示为虚线</li></ul></li><li>wavy<ul><li>线条将显示为波浪线</li></ul></li></ul></li><li>text-decoration-color</li></ul></li><li>空白属性<ul><li>white-space<ul><li>指定元素内的空白怎样处理</li><li>normal<ul><li>空白会被浏览器忽略。默认值。</li></ul></li><li>pre<ul><li>空白会被浏览器保留。类似 HTML 中 <pre> 标签</li></ul></li><li>nowrap<ul><li>文本不会换行，文本会在在同一行上继续直到遇到 <br> 标签</li></ul></li><li>pre-wrap<ul><li>保留空白符序列，但是正常地进行换行</li></ul></li><li>pre-line<ul><li>合并空白符序列，但是保留换行符</li></ul></li></ul></li></ul></li></ul></li><li><p>表格</p><ul><li>合并边框<ul><li>border-collapse<ul><li>separate：边框会被分开。不会忽略 border-spacing 和 empty-cells 属性。默认值。</li><li>collapse：如果可能边框会合并为一个单一边框。忽略 border-spacing 和 empty-cells 属性</li></ul></li></ul></li><li>边框间距<ul><li>border-spacing<ul><li>定义一个 length 参数，那么定义的是水平和垂直间距</li><li>如果定义两个 length 参数，那么第一个设置水平间距，而第二个设置垂直间距</li></ul></li></ul></li></ul></li><li><p>增强</p><ul><li>创建圆角<ul><li>border-radius: r<ul><li>border-top-left-radius</li><li>border-top-right -radius</li><li>border-bottom-right-radius</li><li>border-bottom-left-radius</li></ul></li></ul></li><li>创建椭圆形圆角<ul><li>border-radius: x/y</li></ul></li><li>创建圆形<ul><li>border-radius: r</li></ul></li><li>旋转缩放<ul><li>transform<ul><li>matrix(n,n,n,n,n,n)：定义 2D 转换，使用 6 个值的矩阵</li><li>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)：定义 3D 转换，使用 16 个值的 4x4 矩阵</li><li>translate(x,y)：定义 2D 转换</li><li>translate3d(x,y,z)：定义 3D 转换</li><li>translateX(x)：定义转换，只是用 X 轴的值</li><li>translateY(y)：定义转换，只是用 Y 轴的值</li><li>translateZ(z)：定义 3D 转换，只是用 Z 轴的值</li><li>scale(x[,y]?)：定义 2D 缩放转换</li><li>scale3d(x,y,z)：定义 3D 缩放转换</li><li>scaleX(x)：通过设置 X 轴的值来定义缩放转换</li><li>scaleY(y)：通过设置 Y 轴的值来定义缩放转换</li><li>scaleZ(z)：通过设置 Z 轴的值来定义 3D 缩放转换</li><li>rotate(angle)：定义 2D 旋转，在参数中规定角度</li><li>rotate3d(x,y,z,angle)：定义 3D 旋转</li><li>rotateX(angle)：定义沿着 X 轴的 3D 旋转</li><li>rotateY(angle)：定义沿着 Y 轴的 3D 旋转</li><li>rotateZ(angle)：定义沿着 Z 轴的 3D 旋转</li><li>skew(x-angle,y-angle)：定义沿着 X 和 Y 轴的 2D 倾斜转换</li><li>skewX(angle)：定义沿着 X 轴的 2D 倾斜转换</li><li>skewY(angle)：定义沿着 Y 轴的 2D 倾斜转换</li><li>perspective(n)：为 3D 转换元素定义透视视图</li></ul></li></ul></li><li>不透明度<ul><li>opacity<ul><li>默认值为 1 。当 opacity 属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待，即使这个值没有被子元素继承。因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的 opacity 属性值</li><li>使用 opacity 属性，当属性值不为 1 时，会把元素放置在一个新的层叠上下文中</li></ul></li></ul></li></ul></li><li><p>媒体</p><ul><li>渲染媒体<ul><li>object-fit<ul><li>两个概念要分清楚：盒子（由元素的宽和高决定）和渲染的媒体。默认情况二者大小相等</li><li>object-fit 属性让我们能在盒子内部控制渲染媒体的大小，同时又保持盒子的大小不变，即元素的内容应该如何适应指定容器的高度与宽度，元素主要用于图片和视频</li><li>fill<ul><li>不保证保持原有的比例，内容拉伸填充整个内容容器。默认值。</li></ul></li><li>none<ul><li>保留原有元素内容的长度和宽度，即不被重置</li></ul></li><li>cover<ul><li>保持原有尺寸比例，让它填满盒子（导致图片一部分被裁剪）</li></ul></li><li>contain<ul><li>保持原有尺寸比例，让它完整地填充盒子（导致盒子里出现空白）</li></ul></li><li>scale-down<ul><li>保持原有尺寸比例。内容的尺寸是 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之TypeScript</title>
    <link href="/2022/12/25/JavaScript%E4%B9%8BTypeScript/"/>
    <url>/2022/12/25/JavaScript%E4%B9%8BTypeScript/</url>
    
    <content type="html"><![CDATA[<p>进阶部分：<a href="http://ts.xcatliu.com/advanced/index.html%E3%80%82">http://ts.xcatliu.com/advanced/index.html。</a></p><p>基础部分：<br>（参考：<a href="http://ts.xcatliu.com/basics/index.html%EF%BC%89">http://ts.xcatliu.com/basics/index.html）</a></p><h1 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h1><p>JS 的数据类型两大类：原始数据类型和对象数据类型。</p><p>原始数据类型共七种：<code>Null</code>、<code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>BigInt</code>。</p><p>这里主要介绍前五种原始数据类型在 TS 中的应用。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>使用 boolean 来定义布尔值类型。直接调用 <code>Boolean()</code> 返回 <code>Boolean</code> 类型。但是，使用构造函数 <code>new Boolean()</code> 创造的对象不是布尔值，而是 Boolean <strong>对象</strong>。</p><p>这方面来说，其他类型的构造函数同理（除 null 和 undefined）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">let</span> createdByBoolean: <span class="hljs-built_in">boolean</span> = <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">let</span> createdBynewBoolean: <span class="hljs-built_in">boolean</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>使用 number 来定义数值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> decLiteral: <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span><br><span class="hljs-keyword">let</span> hexLiteral: <span class="hljs-built_in">number</span> = <span class="hljs-number">0xf00d</span>     <span class="hljs-comment">// ES6 中的二进制表示法，会被编译为十进制数字。</span><br><span class="hljs-keyword">let</span> binaryLinteral: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b1010</span> <span class="hljs-comment">// ES6 中的八进制表示法，会被编译为十进制数字。</span><br><span class="hljs-keyword">let</span> octalLiteral: <span class="hljs-built_in">number</span> = <span class="hljs-number">0o744</span><br><span class="hljs-keyword">let</span> notANumber: <span class="hljs-built_in">number</span> = <span class="hljs-literal">NaN</span><br><span class="hljs-keyword">let</span> infinityNumber: <span class="hljs-built_in">number</span> = <span class="hljs-literal">Infinity</span><br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>使用 string 来定义字符串类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> myName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Tom&#x27;</span><br><span class="hljs-keyword">let</span> myAge: <span class="hljs-built_in">number</span> = <span class="hljs-number">25</span><br><span class="hljs-keyword">let</span> sentence: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, I am <span class="hljs-subst">$&#123;myName&#125;</span>.I will be <span class="hljs-subst">$&#123;myAge + <span class="hljs-number">1</span>&#125;</span> years old tomorrow.`</span><br></code></pre></td></tr></table></figure><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>JS 中没有空值（Void）的概念，在 TS 中可用 void 表示没有任何返回值的函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertName</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>  alert(<span class="hljs-string">&#x27;Now is alerting!&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">let</span> unusable: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h2 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a><code>Null</code>和<code>Undefined</code></h2><p>使用 null 和 undefined 来定义这两个类型。</p><p>void、null 和 undefined， 这三个类型的变量，都不能赋值给其他类型的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br><span class="hljs-keyword">let</span> v: <span class="hljs-built_in">void</span><br><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">let</span> num1: <span class="hljs-built_in">number</span> = u <span class="hljs-comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;number&#x27;</span><br><span class="hljs-keyword">let</span> num2: <span class="hljs-built_in">number</span> = n <span class="hljs-comment">// Type &#x27;null&#x27; is not assignable to type &#x27;number&#x27;</span><br><span class="hljs-keyword">let</span> num4: <span class="hljs-built_in">number</span> = v <span class="hljs-comment">// Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h1><p>任意值用来表示允许赋值为任意类型。</p><h2 id="什么是任意值类型"><a href="#什么是任意值类型" class="headerlink" title="什么是任意值类型"></a>什么是任意值类型</h2><p>如果是普通类型，在赋值过程中改变类型是不被允许的。如果是 any 类型，则允许被赋值为任意类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> myNum1: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;seven&#x27;</span><br><span class="hljs-keyword">let</span> myNum2: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;seven&#x27;</span><br>myNum1 = <span class="hljs-number">7</span> <span class="hljs-comment">// error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;</span><br>myNum2 = <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="任意值的属性和方法"><a href="#任意值的属性和方法" class="headerlink" title="任意值的属性和方法"></a>任意值的属性和方法</h2><p>在任意值上访问任何属性和调用任何方法但是允许的。</p><p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> anyThing: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-built_in">console</span>.log(anyThing.myName) <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(anyThing.myName.firstName) <span class="hljs-comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;firstName&#x27;)</span><br>anyThing.setName(<span class="hljs-string">&#x27;Jerry&#x27;</span>)<br>anyThing.setName(<span class="hljs-string">&#x27;Jerry&#x27;</span>).sayHello()<br>anyThing.myName.setFirstName(<span class="hljs-string">&#x27;Tom&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="未声明类型的变量"><a href="#未声明类型的变量" class="headerlink" title="未声明类型的变量"></a>未声明类型的变量</h2><p>如果在声明变量时未指定其类型，则它会被识别为任意类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> something;<br>something = <span class="hljs-string">&#x27;seven&#x27;</span>;<br>something = <span class="hljs-number">7</span>;<br>something.setName(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><h1 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h1><p>如果没有明确的指定类型，那么 TS 会按照类型推论的规则推断出一个类型。</p><h2 id="什么是类型推论"><a href="#什么是类型推论" class="headerlink" title="什么是类型推论"></a>什么是类型推论</h2><p>TS 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p><p>如果定义时没有赋值，不管之后有无赋值，该变量都会被推断为 any 类型而不被类型检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> favoriteNum1 = <span class="hljs-string">&#x27;seven&#x27;</span><br><span class="hljs-keyword">let</span> favoriteNum2: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;seven&#x27;</span> <span class="hljs-comment">// 这两个赋值是等价的</span><br><span class="hljs-keyword">let</span> favoriteNum<br>favoriteNum1 = <span class="hljs-number">7</span> <span class="hljs-comment">// error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;</span><br>favoriteNum2 = <span class="hljs-number">7</span> <span class="hljs-comment">// error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;</span><br>favoriteNum = <span class="hljs-string">&#x27;seven&#x27;</span> <span class="hljs-comment">// 没问题</span><br>favoriteNum = <span class="hljs-number">7</span> <span class="hljs-comment">// 没问题</span><br></code></pre></td></tr></table></figure><h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p>联合类型表示取值可以为多种类型中的一种。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>联合类型使用 <code>|</code> 分隔每个类型。</p><p>下面的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> myFavoriteNumber: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<br>myFavoriteNumber = <span class="hljs-number">7</span>;<br>myFavoriteNumber = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span><br><span class="hljs-comment">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span><br></code></pre></td></tr></table></figure><h2 id="联合类型的属性或方法"><a href="#联合类型的属性或方法" class="headerlink" title="联合类型的属性或方法"></a>联合类型的属性或方法</h2><p>当 TS 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getString</span>(<span class="hljs-params">something: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> something.toString();<br>&#125;<br><span class="hljs-comment">// 没问题</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">something: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> something.length;<br>&#125;<br><span class="hljs-comment">// error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;</span><br><span class="hljs-comment">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;</span><br></code></pre></td></tr></table></figure><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> myFavoriteNumber: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 5</span><br>myFavoriteNumber = <span class="hljs-number">7</span>;<br><span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>在 TS 中，我们使用接口来定义对象的类型。</p><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体的行动需要类（classes）去实现（implement）。</p><p>TS 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p><h2 id="简单的例子-1"><a href="#简单的例子-1" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>接口一般首字母大写。定义的变量比接口少或是多了，都是不被允许的。</p><p>赋值的时候，变量的形状必须和接口的形状保持一致。少了或多了一些属性都是不允许的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> tomPerson: Person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>不希望完全匹配一个形状，可以用可选属性。</p><p>可选属性的含义是该属性可以不存在，但仍然不允许添加未定义的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person1 &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  age?: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> tom1: Person1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>希望接口允许有任意的属性，可以用任意属性。</p><p>使用 <code>[propName: string]</code> 定义任意属性取 <code>string</code> 类型的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person2 &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  age?: <span class="hljs-built_in">number</span><br>  [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span><br>&#125;<br><span class="hljs-keyword">let</span> tom2: Person2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集。</p><p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，可在任意属性中使用联合类型。</p><p>如果同时存在任意属性和可选属性，那么任意属性的数据类型要带 <code>undefined</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person3 &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  age?: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 类型“number | undefined”的属性“age”不能赋给“string”索引类型“string”。ts(2411)</span><br>  [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">let</span> tom3: Person3 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;<br><span class="hljs-comment">// 不能将类型“&#123; name: string; age: number; gender: string; &#125;”分配给类型“Person3”。</span><br><span class="hljs-comment">//   属性“age”与索引签名不兼容。</span><br><span class="hljs-comment">//     不能将类型“number”分配给类型“string”。ts(2322)</span><br><span class="hljs-keyword">interface</span> Person4 &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  age?: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 类型“number | undefined”的属性“age”不能赋给“string”索引类型“string | number”。ts(2411)</span><br>  [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> tom4: Person4 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;<br><span class="hljs-keyword">interface</span> Persons &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  age?: <span class="hljs-built_in">number</span><br>  [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span><br>&#125;<br><span class="hljs-keyword">let</span> toms: Persons = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span><br>&#125;<br><span class="hljs-comment">// 没问题</span><br></code></pre></td></tr></table></figure><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>希望对象中的一些字段只能在创建的时候被赋值，可以用 <code>readonly</code> 定义只读属性。</p><p>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person5 &#123;<br>  <span class="hljs-keyword">readonly</span> id: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  age?: <span class="hljs-built_in">number</span><br>  [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span><br>&#125;<br><br><span class="hljs-keyword">let</span> tom5: Person5 = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span><br>&#125;<br>tom5.id = <span class="hljs-number">1</span> <span class="hljs-comment">// 无法为“id”赋值，因为它是只读属性。ts(2540)</span><br><br><span class="hljs-keyword">let</span> tom6: Person5 = &#123; <span class="hljs-comment">// 类型 &quot;&#123; name: string; &#125;&quot; 中缺少属性 &quot;id&quot;，但类型 &quot;Person5&quot; 中需要该属性。ts(2741)</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span><br>&#125;<br>tom6.id = <span class="hljs-number">1</span> <span class="hljs-comment">// 无法为“id”赋值，因为它是只读属性。ts(2540)</span><br></code></pre></td></tr></table></figure><h1 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h1><p>在 TS 中，数组类型有多种定义方式，比较灵活。</p><h2 id="「类型-方括号」"><a href="#「类型-方括号」" class="headerlink" title="「类型 + 方括号」"></a>「类型 + 方括号」</h2><p>最简单的方法是使用「类型 + 方括号」来表示数组。数组的项中不允许出现其他的类型。</p><p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> arr1: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> arr2: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>]<br><span class="hljs-keyword">let</span> arr3: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">4</span>] <span class="hljs-comment">// 不能将类型“string”分配给类型“number”。ts(2322)</span><br>arr1.push(<span class="hljs-string">&#x27;arr&#x27;</span>) <span class="hljs-comment">// 类型“string”的参数不能赋给类型“number”的参数。ts(2345)</span><br></code></pre></td></tr></table></figure><h2 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h2><p>也可以使用数组泛型（Array Generic） <code>Array&lt;elemType&gt;</code> 来表示数组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> fibonacci: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><h2 id="用接口表示数组"><a href="#用接口表示数组" class="headerlink" title="用接口表示数组"></a>用接口表示数组</h2><p>虽然接口可以用来被描述数组，但因为很复杂，一般不这么做。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> NumberArray &#123;<br>  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> numberArray: NumberArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-keyword">interface</span> NumberArray2 &#123;<br>  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">let</span> numberArray2: NumberArray2 = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="any-在数组中"><a href="#any-在数组中" class="headerlink" title="any 在数组中"></a>any 在数组中</h2><p>常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kai&#x27;</span> &#125;]<br></code></pre></td></tr></table></figure><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p>类数组（Array-like Object）不是数组类型，如 <code>arguments</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">number</span>[] = <span class="hljs-built_in">arguments</span> <span class="hljs-comment">// 类型“IArguments”缺少类型“number[]”的以下属性: pop, push, concat, join 及其他 26 项。ts(2740)</span><br>  <span class="hljs-keyword">return</span> args<br>&#125;<br></code></pre></td></tr></table></figure><p><code>arguments</code>实际上是一个类数组，类数组不能用普通的数组的方式来描述，而应该用接口。</p><p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>，<code>NodeList</code>，<code>HTMLCollection</code> 等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> args: &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span><br>    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-attr">callee</span>: <span class="hljs-built_in">Function</span><br>  &#125; = <span class="hljs-built_in">arguments</span><br>&#125;<br><span class="hljs-keyword">interface</span> IArguments &#123;<br>  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span><br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">callee</span>: <span class="hljs-built_in">Function</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于内置对象，可以参考下方的内置对象章节。</p><h1 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）。</p><p>一个函数有输入和输出，要在 TS 中对其约束，输入和输出都要考虑到。</p><p>其中，函数声明的类型定义较简单。但是，输入多余的（或者少于要求的）参数，是不被允许的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum1</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br>sum1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>sum1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 应有 0-2 个参数，但获得 3 个。ts(2554)</span><br>sum1(<span class="hljs-number">1</span>)       <span class="hljs-comment">// 没有需要 1 参数的重载，但存在需要 0 或 2 参数的重载。ts(2575)</span><br></code></pre></td></tr></table></figure><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> sum2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-keyword">let</span> sum3: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><p>sum2 的代码只对等号右侧的匿名函数就行了类型定义，而等号左侧的 sum2 是通过赋值操作进行类型推论而推断出来的。如果需要手动添加类型，应该是 sum3 的代码。</p><p>在 TS 中，<code>=&gt;</code> 用来表示函数的定义，左侧是输入类型，需要用括号括起来，右侧是输出类型。</p><h2 id="用接口定义函数"><a href="#用接口定义函数" class="headerlink" title="用接口定义函数"></a>用接口定义函数</h2><p>采用函数表达式或接口定义函数的方式时，对等号左侧进行类型限制，</p><p>可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SearchFunc &#123;<br>  (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span><br>&#125;<br><span class="hljs-keyword">let</span> mySearch: SearchFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> source.search(subString) !== -<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>与接口中的可选属性类似，用 <code>?</code> 表示可选的参数。</p><p>可选参数必须接在必需参数后面，就是，可选参数后面不允许再出现必需参数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildNmae1</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (lastName) &#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> firstName<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> tomcatName = buildNmae1(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>)<br><span class="hljs-keyword">let</span> tomName = buildNmae1(<span class="hljs-string">&#x27;Tom&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>ES6 允许给函数添加默认值，TS 也会将添加了默认值的参数识别为可选参数。</p><p>此时，其不受「可选参数必须接在必需参数后面」的限制。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName2</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Cat&#x27;</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName3</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Tom&#x27;</span>, lastName: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>ES6 中可以使用 <code>...reat</code> 的方式获取函数找那个的剩余参数。</p><p>事实上，<code>rest</code> 是一个数组，所以我们可以用数组的类型来定义它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array: <span class="hljs-built_in">any</span>[], ...items: <span class="hljs-built_in">any</span>[]</span>) </span>&#123;<br>  items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>    array.push(item)<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">let</span> a = []<br>push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。利用联合类型，可以这么实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> | <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。这时，可以使用重载定义多个 <code>reverse</code> 的函数类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> | <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>))<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面当中，多次重复定义了 <code>reverse</code> 函数，前几次都是函数定义，最后一次是函数实现。</p><p>TS 优先从最前面的函数定义开始匹配，故多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p><h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>方式一：<code>值 as 类型</code>；方式二：<code>&lt;类型&gt;值</code>。在 tsx 中，必须使用前者：<code>值 as 类型</code>。</p><p>形如 <code>&lt;Foo&gt;</code> 的语法在 tsx 中表示的是一个 <code>ReactNode</code>，在 TS 中除了表示类型断言之外，也可能是表示一个泛型。因此，建议统一使用 <code>值 as 类型</code> 语法。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="将一个联合类型断言为其中一个类型"><a href="#将一个联合类型断言为其中一个类型" class="headerlink" title="将一个联合类型断言为其中一个类型"></a>将一个联合类型断言为其中一个类型</h3><p>当 TS 不确定一个联合类型的变量是哪个类型的时候，我们只能访问该联合类型的所有类型中共有的属性或方法。但有时，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法。此时可以使用类型断言。</p><p>需要注意的是，类型断言只能够欺骗 TS 编译器，无法避免运行时的错误，滥用类型断言可能会导致运行错误。使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Cat &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  run(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> Fish &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  swim(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFish1</span>(<span class="hljs-params">animal: Cat | Fish</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> animal.swim === <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>&#125;<br><span class="hljs-comment">// 类型“Cat | Fish”上不存在属性“swim”。</span><br><span class="hljs-comment">//   类型“Cat”上不存在属性“swim”。ts(2339)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFish2</span>(<span class="hljs-params">animal: Cat | Fish</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> (animal <span class="hljs-keyword">as</span> Fish).swim === <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将一个父类断言为更加具体的子类"><a href="#将一个父类断言为更加具体的子类" class="headerlink" title="将一个父类断言为更加具体的子类"></a>将一个父类断言为更加具体的子类</h3><p>当类之间有继承关系时，类型断言也很常见。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>&#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>&#123;<br>  <span class="hljs-attr">statusCode</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">200</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isApiError</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> (error <span class="hljs-keyword">as</span> ApiError).code === <span class="hljs-string">&#x27;number&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将任何一个类型断言为-any"><a href="#将任何一个类型断言为-any" class="headerlink" title="将任何一个类型断言为 any"></a>将任何一个类型断言为 any</h3><p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。将一个变量断言为 any 是解决 TS 中类型问题的最后一个手段。它极有可能掩盖了真正的类型错误，所以不是非常确定，就不要使用 <code>as any</code>。</p><p>一方面不能滥用 <code>as any</code>，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">window</span>.foo = <span class="hljs-number">1</span> <span class="hljs-comment">// 类型“Window &amp; typeof globalThis”上不存在属性“foo”。ts(2339)</span><br>(<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).foo = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="将-any-断言为一个具体的类型"><a href="#将-any-断言为一个具体的类型" class="headerlink" title="将 any 断言为一个具体的类型"></a>将 any 断言为一个具体的类型</h3><p>在开发中，非常有可能遇到 <code>any</code> 类型的变量。我们可以选择改进它，任由其滋生更多的 <code>any</code>，也可以选择改进它，通过断言类型及时的吧 <code>any</code> 断言为精确的类型，让我们的代码向着可维护性的目标发展。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCacheData</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).cache[key]<br>&#125;<br><span class="hljs-keyword">interface</span> Cat &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  run(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">const</span> tom = getCacheData(<span class="hljs-string">&#x27;tom&#x27;</span>) <span class="hljs-keyword">as</span> Cat<br>tom.run()<br></code></pre></td></tr></table></figure><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>由上，已知：</p><ul><li>联合类型可以被断言为其中一个类型</li><li>父类可以被断言为子类</li><li>任何类型都可以被断言为 any</li><li><code>any</code> 可以被断言为任何类型</li></ul><p>类型断言的限制，就是，并不是任何一个类型都可以被断言为另一个类型。具体而言，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。</p><p>下面例子当中，Cat 包含了 Animal 中的所有属性，初此之外，Cat 还有额外的方法，这等价于 <code>Cat extends Animal</code>，Cat 类型的 tomCat 可以赋值给 Animal 类型的 animal。</p><p>专业的说法是，Animal 兼容 Cat。这时，它们就可以相互进行类型断言。允许 <code>animal as Cat</code>，是因为「父类可以被断言为子类」。允许 <code>cat as Animal</code>，是因为子类拥有父类的属性和方法，则被断言为父类，获取父类的属性、调用父类的方法，不会有问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Animal &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">interface</span> Cat &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  run(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> Cat <span class="hljs-keyword">extends</span> Animal &#123;<br>  run(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">let</span> tomCat: Cat = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">run</span>: <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;run&#x27;</span>) &#125;<br>&#125;<br><span class="hljs-keyword">let</span> animal: Animal = tomCat<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testAniaml</span>(<span class="hljs-params">animal: Animal</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (animal <span class="hljs-keyword">as</span> Cat)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testCat</span>(<span class="hljs-params">cat: Cat</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (cat <span class="hljs-keyword">as</span> Animal)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，综上所述：要使得 A 能够内断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可。</p><h2 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h2><p>既然，任何类型都可以被断言为 <code>any</code>，且 <code>any</code> 可以被断言为任何类型。那么，我们能够将任何一个类型断言为任何另一个类型。但这种双重断言，十有八九十错误的。</p><p>除非迫不得已，千万别用双重断言。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Cat &#123;<br>  run(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Fish &#123;<br>  swim(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testCat1</span>(<span class="hljs-params">cat: Cat</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (cat <span class="hljs-keyword">as</span> Fish);<br>&#125;<br><span class="hljs-comment">// 类型 &quot;Cat&quot; 到类型 &quot;Fish&quot; 的转换可能是错误的，因为两种类型不能充分重叠。如果这是有意的，请先将表达式转换为 &quot;unknown&quot;。</span><br><span class="hljs-comment">//   类型 &quot;Cat&quot; 中缺少属性 &quot;swim&quot;，但类型 &quot;Fish&quot; 中需要该属性。ts(2352)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testCat2</span>(<span class="hljs-params">cat: Cat</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (cat <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span> <span class="hljs-keyword">as</span> Fish);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型断言-VS-类型转换"><a href="#类型断言-VS-类型转换" class="headerlink" title="类型断言 VS 类型转换"></a>类型断言 VS 类型转换</h2><p>类型断言只会影响编译时的类型，类型断言语句在编译结果中会被删除。</p><p>类型断言不是类型转换，不会真的影响到变量的类型。要进行类型转换，需要直接调用类型转换的方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toBoolean</span>(<span class="hljs-params">something: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">boolean</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Boolean</span>(something);<br>&#125;<br>toBoolean(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="类型断言-VS-类型声明"><a href="#类型断言-VS-类型声明" class="headerlink" title="类型断言 VS 类型声明"></a>类型断言 VS 类型声明</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCaCheData</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).cache[key]<br>&#125;<br><span class="hljs-keyword">interface</span> Cat &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  run(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">const</span> tomCat1 = getCaCheData(<span class="hljs-string">&#x27;tom&#x27;</span>) <span class="hljs-keyword">as</span> Cat<br><span class="hljs-keyword">const</span> tomCat2: Cat = getCaCheData(<span class="hljs-string">&#x27;tom&#x27;</span>)<br></code></pre></td></tr></table></figure><p>tomCat1 是用 <code>as Cat</code> 将 any 类型的 <code>getCaCheData(&#39;tom&#39;)</code> 断言为了 Cat 类型。<br>tomCat2 是用类型声明的方式，将 tomCat2 声明为 Cat，再将 any 类型的 <code>getCaCheData(&#39;tom&#39;)</code> 赋值给 Cat 类型的 tomCat2。</p><p>这两者是非常相似的，而且产生的结果也是一样的：tom 在接下来的代码中都变为了 Cat 类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Animal &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Cat &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  run(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">const</span> animalCat: Animal = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> tom111 = animalCat <span class="hljs-keyword">as</span> Cat <br><span class="hljs-keyword">let</span> tom222: Cat = animalCat  <span class="hljs-comment">// 类型 &quot;Animal&quot; 中缺少属性 &quot;run&quot;，但类型 &quot;Cat&quot; 中需要该属性。ts(2741)</span><br></code></pre></td></tr></table></figure><p>上方不允许将 animalCat 赋值为 Cat 类型的 tom222，是因为不能把父类的实例赋值给类型为子类的变量。</p><p>将 animalCat 断言为 Cat 类型，只需要满足任何一个兼容另一个即可。<br>将 animalCat 赋值为 Cat 类型的 tom222，需要满足 Cat 兼容 Animal。</p><p>因此，类型声明比类型断言更加严格。为了增加代码质量，优先那使用类型声明。</p><h2 id="类型断言-vs-泛型"><a href="#类型断言-vs-泛型" class="headerlink" title="类型断言 vs 泛型"></a>类型断言 vs 泛型</h2><p>对于</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCacheData</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).cache[key];<br>&#125;<br><br><span class="hljs-keyword">interface</span> Cat &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  run(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> tom = getCacheData(<span class="hljs-string">&#x27;tom&#x27;</span>) <span class="hljs-keyword">as</span> Cat;<br>tom.run();<br></code></pre></td></tr></table></figure><p>还有第三种方式可以解决这个问题，那就是泛型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCacheData</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).cache[key];<br>&#125;<br><br><span class="hljs-keyword">interface</span> Cat &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  run(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> tom = getCacheData&lt;Cat&gt;(<span class="hljs-string">&#x27;tom&#x27;</span>);<br>tom.run();<br></code></pre></td></tr></table></figure><p>通过给 <code>getCacheData</code> 函数添加了一个泛型 <code>&lt;T&gt;</code>，我们可以更加规范的实现对 <code>getCacheData</code> 返回值的约束，这也同时去除掉了代码中的 <code>any</code>，是最优的一个解决方案。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之RegExp与正则</title>
    <link href="/2022/12/10/JavaScript%E4%B9%8BRegExp%E4%B8%8E%E6%AD%A3%E5%88%99/"/>
    <url>/2022/12/10/JavaScript%E4%B9%8BRegExp%E4%B8%8E%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://juejin.cn/post/7153800580077453326%E3%80%82">https://juejin.cn/post/7153800580077453326。</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp。</a></li></ol><h1 id="正则的核心"><a href="#正则的核心" class="headerlink" title="正则的核心"></a>正则的核心</h1><p>正则就是匹配模式，要么<strong>匹配位置</strong>，要么<strong>匹配字符</strong>。划重点，牢记这个核心。</p><p>下图代表的是一个字符串：<code>I Love U</code>，箭头表示要匹配的位置，框框表示要匹配的字符（包括空格）。</p><p><img src="/images/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="正则表达式"></p><h2 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配位置</h2><table><thead><tr><th align="center">模式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">匹配开头的位置，当正则有修饰符 m 时(多行文本)，表示匹配行开头位置</td></tr><tr><td align="center">$</td><td align="center">匹配结尾的位置，当正则有修饰符 m 时(多行文本)，表示匹配行结尾位置</td></tr><tr><td align="center">\b</td><td align="center">匹配单词边界，即匹配上面示例中的 i、love、U 前后的位置</td></tr><tr><td align="center">\B</td><td align="center">匹配非单词边界，与 \b 相反，即匹配上面示例中的 o、v、e 前后的位置</td></tr><tr><td align="center">(?=表达式)</td><td align="center">正向先行断言，指在某个位置的右侧必须能匹配表达式</td></tr><tr><td align="center">(?!表达式)</td><td align="center">反向先行断言，指在某个位置的右侧不能匹配表达式</td></tr><tr><td align="center">(?&lt;=表达式)</td><td align="center">正向后行断言，指在某个位置的左侧必须能匹配表达式</td></tr><tr><td align="center">(?&lt;!表达式)</td><td align="center">反向后行断言，指在某个位置的左侧不能匹配表达式</td></tr></tbody></table><blockquote><p>匹配以 ‘javascript’ 开头的字符串<br>匹配以 ‘javascript’ 结尾的字符串</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">/^javascript/.test(<span class="hljs-string">&#x27;javascript is my favorite&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-regexp">/javascript$/</span>.test(<span class="hljs-string">&#x27;this code in javascript&#x27;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>匹配有边界的’code’单词</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">/\bcode\b/.test(<span class="hljs-string">&#x27;bar code&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-regexp">/\bcode\b/</span>.test(<span class="hljs-string">&#x27;barcode&#x27;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-regexp">/code\b/</span>.test(<span class="hljs-string">&#x27;barcode &#x27;</span>);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>匹配姓’李’的名字</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">/^李.+<span class="hljs-regexp">/.test(&#x27;李逍遥&#x27;);                  /</span><span class="hljs-regexp">/ true</span><br><span class="hljs-regexp">/</span>^李.+<span class="hljs-regexp">/.test(&#x27;李&#x27;);                     /</span><span class="hljs-regexp">/ false</span><br><span class="hljs-regexp">/</span>^李.+<span class="hljs-regexp">/.test(&#x27;慕容李逍遥&#x27;);             /</span><span class="hljs-regexp">/ false</span><br><span class="hljs-regexp">/</span>(?&lt;=[\s]?)(?&lt;!\S)李.+<span class="hljs-regexp">/.test(&#x27;李逍遥&#x27;);  /</span><span class="hljs-regexp">/ true   /</span><span class="hljs-regexp">/ &quot;李&quot; 左侧可以为空格不能为非空格字符</span><br></code></pre></td></tr></table></figure><h2 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><table><thead><tr><th align="center">模式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">字母、数字</td><td align="center">匹配字符本身</td></tr><tr><td align="center">\0</td><td align="center">匹配 NUL 字符</td></tr><tr><td align="center">\t</td><td align="center">匹配水平制表符</td></tr><tr><td align="center">\v</td><td align="center">匹配垂直制表符</td></tr><tr><td align="center">\n</td><td align="center">匹配换行符</td></tr><tr><td align="center">\r</td><td align="center">匹配回车符</td></tr><tr><td align="center">\f</td><td align="center">匹配换页符</td></tr><tr><td align="center">\xnn</td><td align="center">匹配拉丁字符nn</td></tr><tr><td align="center">\uxxxx</td><td align="center">匹配 Unicode 字符xxxx</td></tr><tr><td align="center">\cX</td><td align="center">匹配 ctrl+X</td></tr><tr><td align="center">[\b]</td><td align="center">匹配 Backspace 键（特殊记忆)</td></tr></tbody></table><h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><table><thead><tr><th align="center">模式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[abc]</td><td align="center">匹配 “a”、”b”、”c” 其中任何一个字符</td></tr><tr><td align="center">[a-d1-4]</td><td align="center">匹配 “a”、”b”、”c”、”d”、”1”、”2”、”3”、”4” 其中任何一个字符</td></tr><tr><td align="center">[^abc]</td><td align="center">匹配除了 “a”、”b”、”c” 之外的任何一个字符</td></tr><tr><td align="center">[^a-d1-4]</td><td align="center">匹配除了 “a”、”b”、”c”、”d”、”1”、”2”、”3”、”4” 之外的任何一个字符</td></tr><tr><td align="center">.</td><td align="center">通配符，匹配除了少数字符(\n)之外的任意字符</td></tr><tr><td align="center">\d</td><td align="center">匹配数字，等价于 [0-9]</td></tr><tr><td align="center">\D</td><td align="center">匹配非数字，等价于 [^0-9]</td></tr><tr><td align="center">\w</td><td align="center">匹配单词字符，等价于 [a-zA-Z0-9_]</td></tr><tr><td align="center">\W</td><td align="center">匹配非单词字符，等价于 [^a-zA-Z0-9_]</td></tr><tr><td align="center">\s</td><td align="center">匹配空白符，等价于 [ \t\v\n\r\f]</td></tr><tr><td align="center">\S</td><td align="center">匹配非空白符，等价于 [^ \t\v\n\r\f]</td></tr></tbody></table><p><code>[...]</code>字符组语法类似 javascript 中的数组。简单的理解就是正则表达式会匹配<code>[...]</code>中的某个字符/表达式，相当于将字符组内的字符遍历匹配。</p><blockquote><p>匹配 ‘Javascript’ 和 ‘javascript’</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/[jJ]avascript/</span>;   <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;javascript&#x27;</span>);        <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;Javascript&#x27;</span>);        <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/[jJ]ava/</span>;        <span class="hljs-comment">// true</span><br>regex1.test(<span class="hljs-string">&#x27;javascript&#x27;</span>);       <span class="hljs-comment">// true</span><br>regex1.test(<span class="hljs-string">&#x27;Javascript&#x27;</span>);       <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>匹配 ‘我爱你’ 或 ‘我想你’ 或 ‘我’+数字+’你’</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/我[\d爱想]你/</span>;<br>regex.test(<span class="hljs-string">&#x27;我爱你&#x27;</span>);    <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;我想你&#x27;</span>);    <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;520, 我2你&#x27;</span>);   <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;我打你&#x27;</span>);    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><blockquote><p>匹配’爱’后面不包含’你’</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/爱[^你]/</span>;<br>regex.test(<span class="hljs-string">&#x27;我爱你&#x27;</span>);   <span class="hljs-comment">// false</span><br>regex.test(<span class="hljs-string">&#x27;我爱他&#x27;</span>);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>贪婪模式――在匹配成功的前提下，尽可能多的去匹配。<br>惰性模式――在匹配成功的前提下，尽可能少的去匹配。</p><table><thead><tr><th align="center">模式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">{n,m}</td><td align="center">连续出现 n 到 m 次（贪婪模式）</td></tr><tr><td align="center">{n,}</td><td align="center">至少连续出现 n 次（贪婪模式）</td></tr><tr><td align="center">{n}</td><td align="center">连续出现 n 次（贪婪模式）</td></tr><tr><td align="center">?</td><td align="center">等价于 {0,1}（贪婪模式）</td></tr><tr><td align="center">+</td><td align="center">等价于 {1,}（贪婪模式）</td></tr><tr><td align="center">*</td><td align="center">等价于 {0,}（贪婪模式）</td></tr><tr><td align="center">{n,m}?</td><td align="center">连续出现 n 到 m 次（惰性模式）</td></tr><tr><td align="center">{n,}?</td><td align="center">至少连续出现 n 次（惰性模式）</td></tr><tr><td align="center">{n}?</td><td align="center">连续出现 n 次（惰性模式）</td></tr><tr><td align="center">??</td><td align="center">等价于 {0,1}?（惰性模式）</td></tr><tr><td align="center">+?</td><td align="center">等价于 {1,}?（惰性模式）</td></tr><tr><td align="center">*?</td><td align="center">等价于 {0,}?（惰性模式）</td></tr></tbody></table><blockquote><p>匹配手机号码，假设手机号码规则如下：</p><ul><li>必须是 11 位的数字；</li><li>第一位数字必须以 1 开头</li><li>第二位数字可以是 [3,4,5,7,8] 中的任意一个</li><li>后面 9 个数是 [0-9] 中的任意一个数字。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/^1[34578]\d&#123;9&#125;/</span>;<br>regex.test(<span class="hljs-string">&#x27;18711001111&#x27;</span>);   <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;13712345678&#x27;</span>);   <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;12345678911&#x27;</span>);   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>括号主要是用来分组。</p><table><thead><tr><th align="center">模式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">(ab)</td><td align="center">捕获型分组。把 “ab” 当成一个整体，表示 “ab” 至少连续出现一次</td></tr><tr><td align="center">(?:ab)</td><td align="center">非捕获型分组。与 (ab) 的区别是，它不捕获数据</td></tr><tr><td align="center">(good | nice)</td><td align="center">捕获型分支结构。匹配 “good” 或 “nice”</td></tr><tr><td align="center">(?:good | nice)</td><td align="center">非捕获型分支结构。与 (good</td></tr><tr><td align="center">\num</td><td align="center">反向引用。比如 \2，表示引用的是第二个括号里的捕获的数据</td></tr></tbody></table><blockquote><p>视频文件的后缀名有 <code>.mp4</code>、<code>.avi</code>、<code>.wmv</code>、<code>.rmvb</code> 用正则表达式提取所有的视频文件的后缀</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/.+(\.mp4|\.avi|.wmv|\.rmvb)/</span>;<br><br>regex.exec(<span class="hljs-string">&#x27;海贼王.avi&#x27;</span>);<br><span class="hljs-comment">// [&#x27;海贼王.avi&#x27;, &#x27;.avi&#x27;, index: 0, input: &#x27;海贼王.avi&#x27;, groups: undefined]</span><br>regex.test(<span class="hljs-string">&#x27;朋友.mp3&#x27;</span>);<br><span class="hljs-comment">// null</span><br>regex.test(<span class="hljs-string">&#x27;学习资料.rmvb&#x27;</span>);<br><span class="hljs-comment">// [&#x27;学习资料.rmvb&#x27;, &#x27;.rmvb&#x27;, index: 0, input: &#x27;学习资料.rmvb&#x27;, groups: undefined]</span><br></code></pre></td></tr></table></figure><h1 id="JS-API"><a href="#JS-API" class="headerlink" title="JS API"></a>JS API</h1><p>Javascript 中可以通过以下两种方式写正则:</p><ul><li>正则表达式字面量</li><li>通过构造函数 RegExp 的实例</li></ul><p>创建一个正则用于精确匹配字符串 ‘test’：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> regExp = <span class="hljs-regexp">/test/</span>;<br><span class="hljs-keyword">let</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br><span class="hljs-keyword">let</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/test/</span>);<br></code></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table><thead><tr><th align="center">模式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">g</td><td align="center">全局匹配，找到所有满足匹配的子串，而不是默认只匹配首次结果（global）</td></tr><tr><td align="center">i</td><td align="center">匹配过程中，忽略英文字母大小写（ignore case）</td></tr><tr><td align="center">m</td><td align="center">多行匹配，把 ^ 和 $ 变成行开头和行结尾（multiline）</td></tr><tr><td align="center">u</td><td align="center">匹配过程中，允许使用 Unicode 点转义符（unicode）</td></tr><tr><td align="center">y</td><td align="center">开启粘连匹配，正则表达式执行粘连匹配时试图从最后一个匹配位置开始（sticky）</td></tr></tbody></table><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">RegExp</span>.prototype.flags<br><span class="hljs-built_in">RegExp</span>.prototype.dotAll<br><span class="hljs-built_in">RegExp</span>.prototype.global<br><span class="hljs-built_in">RegExp</span>.prototype.ignoreCase<br><span class="hljs-built_in">RegExp</span>.prototype.multiline<br><span class="hljs-built_in">RegExp</span>.prototype.source<br><span class="hljs-built_in">RegExp</span>.prototype.sticky<br><span class="hljs-built_in">RegExp</span>.prototype.unicode<br></code></pre></td></tr></table></figure><h3 id="flags-标志"><a href="#flags-标志" class="headerlink" title="flags 标志"></a>flags 标志</h3><p>flags 属性返回一个字符串，由当前正则表达式对象的标志组成。</p><p>标志以字典序排序，从左到右，即”gimuy”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">/foo/ig.flags;   <span class="hljs-comment">// &quot;gi&quot;</span><br><span class="hljs-regexp">/bar/myu</span>.flags;  <span class="hljs-comment">// &quot;muy&quot;</span><br></code></pre></td></tr></table></figure><h3 id="dotAll-标志"><a href="#dotAll-标志" class="headerlink" title="dotAll 标志"></a>dotAll 标志</h3><p>dotAll 属性表明是否在正则表达式中一起使用”s”修饰符（引入/s 修饰符，使得可以匹配任意单个字符）。</p><p>dotAll 是一个只读的属性，属于单个正则表达式实例。</p><h3 id="global-全局匹配"><a href="#global-全局匹配" class="headerlink" title="global 全局匹配"></a>global 全局匹配</h3><p>global 属性表明正则表达式是否使用了 “g” 标志。</p><p>global 的值是布尔对象，是一个正则表达式实例的只读属性。</p><p>“g” 标志意味着正则表达式应该测试字符串中所有可能的匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>);<br>regex.global;   <span class="hljs-comment">// true</span><br><span class="hljs-regexp">/fool/g</span>.global; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="ignoreCase-忽略大小写"><a href="#ignoreCase-忽略大小写" class="headerlink" title="ignoreCase 忽略大小写"></a>ignoreCase 忽略大小写</h3><p>ignoreCase 属性表明正则表达式是否使用了 “i” 标志。</p><p>ignoreCase 的值是布尔对象，是一个正则表达式实例的只读属性。</p><p>“i” 标志意味着在字符串进行匹配时，应该忽略大小写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br>regex.ignoreCase;   <span class="hljs-comment">// true</span><br><span class="hljs-regexp">/fool/i</span>.ignoreCase; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="multiline-多行搜索"><a href="#multiline-多行搜索" class="headerlink" title="multiline 多行搜索"></a>multiline 多行搜索</h3><p>multiline 属性表明正则表达式是否使用了 “m” 标志。</p><p>multiline 的值是布尔对象，是一个正则表达式实例的只读属性。</p><p>“m” 标志意味着一个多行输入字符串被看作多行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;m&quot;</span>);<br>regex.multiline;   <span class="hljs-comment">// true</span><br><span class="hljs-regexp">/fool/m</span>.multiline; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="source-正则文本"><a href="#source-正则文本" class="headerlink" title="source 正则文本"></a>source 正则文本</h3><p>source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/fooBar/ig</span>;<br>regex.source; <span class="hljs-comment">// &quot;fooBar&quot;，不包含 /.../ 和 &quot;ig&quot;。</span><br></code></pre></td></tr></table></figure><h3 id="sticky-粘连匹配"><a href="#sticky-粘连匹配" class="headerlink" title="sticky 粘连匹配"></a>sticky 粘连匹配</h3><p>sticky 属性表明正则表达式是否使用了 “y” 标志。</p><p>sticky 的值是布尔对象，是一个正则表达式实例的只读属性。</p><p>“y” 标志意味着仅从正则表达式的 lastIndex 属性表示的索引处为目标字符串匹配（并且不会尝试从后续索引匹配）。如果一个表达式同时指定了 sticky 和 global，其将会忽略 global 标志。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;#foo#&#x27;</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/foo/y</span>;<br>regex.lastIndex = <span class="hljs-number">1</span>;<br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.lastIndex = <span class="hljs-number">5</span>;<br>regex.test(str); <span class="hljs-comment">// false（lastIndex 被 sticky 标志考虑到，从而导致匹配失败）</span><br>regex.lastIndex; <span class="hljs-comment">// 0（匹配失败后重置）</span><br></code></pre></td></tr></table></figure><h3 id="unicode-点转义符"><a href="#unicode-点转义符" class="headerlink" title="unicode 点转义符"></a>unicode 点转义符</h3><p>unicode 属性表明正则表达式是否使用了 “u” 标志。</p><p>unicode 的值是布尔对象，是一个正则表达式实例的只读属性。</p><p>“u” 标志开启了多种 Unicode 相关的特性。使用 “u” 标志，任何 Unicode 代码点的转义都会被解释。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;\u&#123;61&#125;&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>);<br>regex.unicode; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">RegExp</span>.prototype.exec()<br><span class="hljs-built_in">RegExp</span>.prototype.test()<br></code></pre></td></tr></table></figure><h3 id="exec-搜索匹配"><a href="#exec-搜索匹配" class="headerlink" title="exec() 搜索匹配"></a>exec() 搜索匹配</h3><p>exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。</p><p>接收一个参数：</p><ul><li>str（必需）：要匹配正则表达式的字符串。</li></ul><p>如果匹配失败，exec() 方法返回 null，并将正则表达式的 lastIndex 重置为 0。<br>如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的 lastIndex 属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应一个匹配的捕获组。数组还具有以下额外的属性：</p><ul><li>index：匹配到的字符位于原始字符串的基于 0 的索引值。</li><li>input：匹配的原始字符串。</li><li>groups：一个命名捕获组对象，其键是名称，值是捕获组。若没有定义命名捕获组，则 groups 的值为 undefined。</li><li>indices （可选）：此属性仅在设置了 <code>d</code> 标志位时存在。它是一个数组，其中每一个元素表示一个子字符串的边界。每个子字符串匹配本身就是一个数组，其中第一个元素表示起始索引，第二个元素表示结束索引。</li></ul><p>当正则表达式设置 <code>g</code> 标志位时，可以多次执行 exec() 方法来查找同一个字符串中的成功匹配。当这样做时，查找将从正则表达式的 lastIndex 属性指定的位置开始。（test() 也会更新 lastIndex 属性）。注意，即使再次查找的字符串不是原查找字符串时，lastIndex 也不会被重置，它依旧会从记录的 lastIndex 开始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> string = <span class="hljs-string">&#x27;table football, football&#x27;</span>;<br><span class="hljs-keyword">const</span> regex1 = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo*&#x27;</span>);<br><span class="hljs-keyword">const</span> regex2 = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo*&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>);<br><span class="hljs-keyword">let</span> array;<br>regex1.lastIndex;    <span class="hljs-comment">// 0</span><br>regex1.exec(string); <br><span class="hljs-comment">// [&#x27;foo&#x27;, index: 6, input: &#x27;table football, football&#x27;, groups: undefined]</span><br>regex1.lastIndex;    <span class="hljs-comment">// 0</span><br>regex1.exec(string); <br><span class="hljs-comment">// [&#x27;foo&#x27;, index: 6, input: &#x27;table football, football&#x27;, groups: undefined]</span><br>regex2.lastIndex;    <span class="hljs-comment">// 0</span><br>regex2.exec(string); <br><span class="hljs-comment">// [&#x27;foo&#x27;, index: 6, input: &#x27;table football, football&#x27;, groups: undefined]</span><br>regex2.lastIndex;    <span class="hljs-comment">// 9</span><br>regex2.exec(string);  <br><span class="hljs-comment">// [&#x27;foo&#x27;, index: 16, input: &#x27;table football, football&#x27;, groups: undefined]</span><br>regex2.lastIndex;    <span class="hljs-comment">// 19</span><br>regex2.exec(string);  <br><span class="hljs-comment">// null</span><br>regex2.lastIndex;    <span class="hljs-comment">// 0</span><br>regex2.exec(string); <br><span class="hljs-comment">// [&#x27;foo&#x27;, index: 6, input: &#x27;table football, football&#x27;, groups: undefined]</span><br><br><span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/quick\s(?&lt;color&gt;brown).+?(jumps)/ig</span>d;<br>re.exec(<span class="hljs-string">&#x27;The Quick Brown Fox Jumps Over The Lazy Dog&#x27;</span>);<br><span class="hljs-comment">//  [</span><br><span class="hljs-comment">//   &#x27;Quick Brown Fox Jumps&#x27;, </span><br><span class="hljs-comment">//   &#x27;Brown&#x27;, </span><br><span class="hljs-comment">//   &#x27;Jumps&#x27;, </span><br><span class="hljs-comment">//   index: 4, </span><br><span class="hljs-comment">//   input: &#x27;The Quick Brown Fox Jumps Over The Lazy Dog&#x27;, </span><br><span class="hljs-comment">//   groups: &#123; color: &quot;brown&quot; &#125;, </span><br><span class="hljs-comment">//   indices: [[4, 25], [10, 15], [20, 25], groups: &#123; color: [10, 15] &#125;]</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h3 id="test-是否匹配"><a href="#test-是否匹配" class="headerlink" title="test() 是否匹配"></a>test() 是否匹配</h3><p>test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 <code>true</code> 或 <code>false</code>。</p><p>接收一个参数：</p><ul><li>str（必需）：要匹配正则表达式的字符串。</li></ul><p>想要知道一个正则表达式是否与指定的字符串匹配时，可以使用 test()（类似 String.prototype.search() ），差别在于 test() 返回一个布尔值，而 search() 返回索引（如果找到）或者 -1（如果没找到）。</p><p>想要知道更多信息（然而执行比较慢），可使用 exec() 方法（类似 String.prototype.match() ）。和 exec() （或者组合使用）一样，在相同的全局正则表达式实例上多次调用 test() 将会越过之前的匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> string = <span class="hljs-string">&#x27;table football&#x27;</span>;<br><span class="hljs-keyword">const</span> regex1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo*&#x27;</span>);<br><span class="hljs-keyword">const</span> regex2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo*&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>);<br>regex1.lastIndex;    <span class="hljs-comment">// 0</span><br>regex1.test(string); <span class="hljs-comment">// true</span><br>regex1.lastIndex;    <span class="hljs-comment">// 0</span><br>regex1.test(string); <span class="hljs-comment">// true</span><br>regex2.lastIndex;    <span class="hljs-comment">// 0</span><br>regex2.test(string); <span class="hljs-comment">// true</span><br>regex2.lastIndex;    <span class="hljs-comment">// 9</span><br>regex2.test(string); <span class="hljs-comment">// flase</span><br>regex2.lastIndex;    <span class="hljs-comment">// 0</span><br>regex2.test(string); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote><p>匹配所有符合 XML 规则的标签</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/&lt;(\w+)&gt;.+&lt;\/(\1)&gt;/</span>);<br><br>regex.test(<span class="hljs-string">&#x27;&lt;div&gt;code&lt;/div&gt;&#x27;</span>)    <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;&lt;span&gt;I Love U&lt;/span&gt;&#x27;</span>)<span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;&lt;h1&gt;This is title&lt;/p&gt;&#x27;</span>)<span class="hljs-comment">// false</span><br>regex.test(<span class="hljs-string">&#x27;&lt;p&gt;1&lt;/p&gt;&#x27;</span>)            <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&#x27;</span>)              <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><blockquote><p>匹配所有的小数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/(?&lt;!\.)\d+\.\d+$/</span>);<br><br>regex.test(<span class="hljs-number">0.1</span>)    <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-number">1.30</span>)    <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-number">13.14</span>)    <span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;1.3.1.4&#x27;</span>)<span class="hljs-comment">// false</span><br>regex.test(<span class="hljs-number">1</span>)    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><blockquote><p>提取下列数据中所有人的生日，使用两个分组，第一个分组提取“月”，第二个分组提取“日”。 </p><ul><li>王伟 1993年1月2日 </li><li>张伟 1996.8.24 </li><li>李伟 1996.3.21 </li><li>李秀 1994-7-5</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/((?&lt;=[年.-])\d&#123;1,2&#125;)[月.-](\d&#123;1,2&#125;)/</span>);<br><br>regex.exec(<span class="hljs-string">&#x27;王伟 1993年1月2日&#x27;</span>)<br><span class="hljs-comment">// [&#x27;1月2&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, index: 8, input: &#x27;王伟 1993年1月2日&#x27;, groups: undefined]</span><br>regex.exec(<span class="hljs-string">&#x27;李伟 1996.3.21&#x27;</span>)<br><span class="hljs-comment">// [&#x27;3.21&#x27;, &#x27;3&#x27;, &#x27;21&#x27;, index: 8, input: &#x27;李伟 1996.3.21&#x27;, groups: undefined]</span><br></code></pre></td></tr></table></figure><blockquote><p>编写正则表达式进行密码强度的验证，规则如下：</p><ul><li>至少一个大写字母</li><li>至少一个小写字母</li><li>至少一个数字</li><li>至少 8 个字符</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/(?=.*?[a-z])(?=.*?[A-Z])(?=.*?[0-9]).&#123;8,&#125;/</span>);<br><br>regex.test(<span class="hljs-string">&#x27;123456789&#x27;</span>)  <span class="hljs-comment">// false</span><br>regex.test(<span class="hljs-string">&#x27;12ABab&#x27;</span>)    <span class="hljs-comment">// false</span><br>regex.test(<span class="hljs-string">&#x27;12345ABCabc&#x27;</span>)<span class="hljs-comment">// true</span><br>regex.test(<span class="hljs-string">&#x27;ADMIN1234()&#x27;</span>)<span class="hljs-comment">// false</span><br>regex.test(<span class="hljs-string">&#x27;Hmm5201314&#x27;</span>)<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>实现一个模板引擎，能够满足如下场景使用：</p><ul><li>let template = 我是，年龄，性别;</li><li>let data = { name: ‘姓名’, age: 18 } </li><li>render(template, data);</li><li>// 我是姓名，年龄18，性别undefined</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> render1 = <span class="hljs-function">(<span class="hljs-params">template, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> arr, res = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/([^ \w\s\&#123;，]+)\&#123;&#123;2&#125;([a-z]&#123;1,&#125;)\&#125;&#123;2&#125;/</span>, <span class="hljs-string">&#x27;g&#x27;</span>);<br>  <span class="hljs-keyword">while</span> ((arr = regex.exec(template)) !== <span class="hljs-literal">null</span>) &#123;<br>  res +=<span class="hljs-string">`<span class="hljs-subst">$&#123;arr[<span class="hljs-number">1</span>]&#125;</span><span class="hljs-subst">$&#123;data[arr[<span class="hljs-number">2</span>]]&#125;</span>，`</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(res.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">2</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render2</span>(<span class="hljs-params">template, data</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> template !== <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  &#125;<br><span class="hljs-keyword">return</span> template.replace(<span class="hljs-regexp">/&#123;&#123;(.*?)&#125;&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">match, $<span class="hljs-number">1</span></span>) =&gt;</span> data[$<span class="hljs-number">1</span>])<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写一个方法把下划线命名转成大驼峰命名</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strToCamel</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/(^|_)(\w)/g</span>, <span class="hljs-function">(<span class="hljs-params">m, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) =&gt;</span> $<span class="hljs-number">2.</span>toUpperCase());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>方法属性</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sass知识</title>
    <link href="/2022/12/07/Sass%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/12/07/Sass%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.sass.hk/docs/">https://www.sass.hk/docs/</a> 。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Sass 是一款强化 CSS 的辅助工具。它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p><h2 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h2><ul><li>完全兼容 CSS3</li><li>在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能</li><li>通过函数进行颜色值与属性值的运算</li><li>提供控制指令 (control directives)等高级功能</li><li>自定义输出格式</li></ul><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><ul><li>Sass 有两种语法格式。首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名</li><li>另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 “Sass”，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 the indented syntax reference。这种格式以 .sass 作为拓展名</li><li>任何一种格式可以直接导入 (@import) 到另一种格式中使用，或者通过 sass-convert 命令行工具转换成另一种格式</li></ul><h2 id="使用-Sass"><a href="#使用-Sass" class="headerlink" title="使用 Sass"></a>使用 Sass</h2><ul><li>Sass 可以通过以下三种方式使用：作为命令行工具；作为独立的 Ruby 模块 (Ruby module)；或者作为 Rack-enabled 框架的插件（例如 Ruby on Rails 与 Merb）。无论哪种方式都需要先安装 Sass gem （Windows 系统需要先安装 Ruby）</li></ul><h1 id="CSS-功能拓展"><a href="#CSS-功能拓展" class="headerlink" title="CSS 功能拓展"></a>CSS 功能拓展</h1><h2 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h2><p>Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器。<br>嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理。如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#main</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#00ff00</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">97%</span>;<br><br>  <span class="hljs-selector-class">.redbox</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000000</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-id">#main</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#00ff00</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">97%</span>;<br>&#125;<br><span class="hljs-selector-id">#main</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-class">.redbox</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#000000</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="父选择器-amp"><a href="#父选择器-amp" class="headerlink" title="父选择器&amp;"></a>父选择器&amp;</h2><p>在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 &amp; 代表嵌套规则外层的父选择器。</p><p>编译后的 CSS 文件中 &amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递。</p><p>注意，&amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器。当父选择器含有不合适的后缀时，Sass 将会报错。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; <br>    <span class="hljs-attribute">text-decoration</span>: underline; <br>  &#125;<br>  <span class="hljs-selector-tag">body</span><span class="hljs-selector-class">.firefox</span> &amp; &#123; <span class="hljs-comment">/* 注意此用法 */</span><br>    <span class="hljs-attribute">font-weight</span>: normal; <br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">text-decoration</span>: none; <br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">text-decoration</span>: underline; <br>&#125;<br><span class="hljs-selector-tag">body</span><span class="hljs-selector-class">.firefox</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: normal; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h2><p>有些 CSS 属性遵循相同的命名空间 (namespace)，比如 <code>font-family</code>, <code>font-size</code>, <code>font-weight</code> 都以 <code>font</code> 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中。</p><p>其中，命名空间也可以包含自己的属性值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.funky</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">20px</span>/<span class="hljs-number">24px</span> &#123;<br>    family: fantasy;<br>    weight: bold;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.funky</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">20px</span>/<span class="hljs-number">24px</span>;<br>  <span class="hljs-attribute">font-family</span>: fantasy;<br>  <span class="hljs-attribute">font-weight</span>: bold; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="占位符选择器-foo"><a href="#占位符选择器-foo" class="headerlink" title="占位符选择器 %foo"></a>占位符选择器 %foo</h2><p>Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。</p><p>与常用的 id 与 class 选择器写法相似，只是 <code>#</code> 或 <code>.</code> 替换成了 <code>%</code>。必须通过 @extend 指令调用，更多介绍请查阅 @extend-Only Selectors。</p><p>当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。</p><h1 id="注释-与"><a href="#注释-与" class="headerlink" title="注释 /* */ 与 //"></a>注释 /* */ 与 //</h1><p>Sass 支持标准的 CSS 多行注释 <code>/* */</code>，以及单行注释<code>//</code>，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。</p><p>将 <code>!</code> 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</p><p>此外，插值语句 (interpolation) 也可写进多行注释中输出变量值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* This comment is</span><br><span class="hljs-comment"> * several lines long.</span><br><span class="hljs-comment"> * since it uses the CSS comment syntax,</span><br><span class="hljs-comment"> * it will appear in the CSS output. */</span><br><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">color</span>: black; &#125;<br><br>// These comments are only one line long each.<br>// They won&#x27;t appear in the CSS output,<br>// since they use the single-line comment syntax.<br><span class="hljs-selector-tag">a</span> &#123; <span class="hljs-attribute">color</span>: green; &#125;<br><br>$version: <span class="hljs-string">&quot;1.2.3&quot;</span>;<br><span class="hljs-comment">/* This CSS is generated by My Snazzy Framework version #&#123;$version&#125;. */</span><br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-comment">/* This comment is</span><br><span class="hljs-comment"> * several lines long.</span><br><span class="hljs-comment"> * since it uses the CSS comment syntax,</span><br><span class="hljs-comment"> * it will appear in the CSS output. */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: black; <br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: green; <br>&#125;<br><br><span class="hljs-comment">/* This CSS is generated by My Snazzy Framework version 1.2.3. */</span><br></code></pre></td></tr></table></figure><h1 id="SassScript"><a href="#SassScript" class="headerlink" title="SassScript"></a>SassScript</h1><p>在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。</p><p>通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。</p><h2 id="Interactive-Shell"><a href="#Interactive-Shell" class="headerlink" title="Interactive Shell"></a>Interactive Shell</h2><p>少用，暂无介绍，仅占坑。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量 $"></a>变量 $</h2><p>SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样。</p><p>直接使用即调用变量。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">$<span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span>;<br><br><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-attribute">width</span>: $width;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。</p><p>将局部变量转换为全局变量可以添加 <code>!global</code> 声明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#main</span> &#123;<br>  $<span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span> !global;<br>  <span class="hljs-attribute">width</span>: $width;<br>&#125;<br><br><span class="hljs-selector-id">#sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: $width;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-id">#sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p><p>注意，变量是 <code>null</code> 空值时将视为未被 <code>!default</code> 赋值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">$cont: <span class="hljs-string">&quot;First content&quot;</span>;<br>$cont: <span class="hljs-string">&quot;Second content?&quot;</span> !default;<br>$new_cont: <span class="hljs-string">&quot;First time reference&quot;</span> !default;<br>$old_cont: null;<br>$old_cont: <span class="hljs-string">&quot;Non-null content&quot;</span> !default;<br><br><span class="hljs-selector-id">#main</span> &#123;<br>  cont: $cont;<br>  new-cont: $new_cont;<br>  old_cont: $old_cont;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-id">#main</span> &#123;<br>  cont: <span class="hljs-string">&quot;First content&quot;</span>;<br>  new-cont: <span class="hljs-string">&quot;First time reference&quot;</span>; <br>  old_cont: <span class="hljs-string">&quot;Non-null content&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>少用，暂无介绍，仅占坑。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>少用，暂无介绍，仅占坑。</p><h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>圆括号可以用来影响运算的顺序。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">1em</span> + (<span class="hljs-number">2em</span> * <span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">7em</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>少用，暂无介绍，仅占坑。</p><h2 id="插值语句"><a href="#插值语句" class="headerlink" title="插值语句 #{}"></a>插值语句 #{}</h2><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器或属性名中使用变量。</p><p><code>#&#123;&#125;</code> 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css">$name: foo;<br>$attr: border;<br><span class="hljs-selector-tag">p</span>.#&#123;$name&#125; &#123;<br>  #&#123;$attr&#125;-<span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  $<span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>  $<span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">font</span>: #&#123;$font-size&#125;/#&#123;$<span class="hljs-attribute">line-height</span>&#125;;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.foo</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: blue; <br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">12px</span>/<span class="hljs-number">30px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="amp-in-SassScript"><a href="#amp-in-SassScript" class="headerlink" title="&amp; in SassScript"></a>&amp; in SassScript</h2><p>少用，暂无介绍，仅占坑。</p><h1 id="Rules-与指令"><a href="#Rules-与指令" class="headerlink" title="@-Rules 与指令"></a>@-Rules 与指令</h1><p>Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。</p><h2 id="import"><a href="#import" class="headerlink" title="@import"></a><code>@import</code></h2><p>Sass 拓展了 <code>@import</code> 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中。另外，被导入的文件中所包含的变量和混合指令 (mixin) 都可以在导入的文件中使用。</p><p>Sass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 <code>:load_paths</code> 选项，或者在命令行中输入 <code>--load-path</code> 命令。</p><p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。</p><ul><li>文件拓展名是 <code>.css</code></li><li>文件名以 <code>http://</code> 开头</li><li>文件名是 <code>url()</code></li><li><code>@import</code> 包含 media queries</li></ul><p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;index.scss&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;index.scss&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo.scss&quot;</span>;<br></code></pre></td></tr></table></figure><p>Sass 允许同时导入多个文件。同时，导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 <code>url()</code> 导入方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;rounded-corners&quot;</span>, <span class="hljs-string">&quot;text-shadow&quot;</span>;<br><br>$family: <span class="hljs-built_in">unquote</span>(<span class="hljs-string">&quot;Droid+Sans&quot;</span>);<br><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;http://fonts.googleapis.com/css?family=\#&#123;$family&#125;&quot;</span>);<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;rounded-corners&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;text-shadow&quot;</span>;<br><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="分音"><a href="#分音" class="headerlink" title="分音"></a>分音</h3><p>如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但<strong>导入语句中却不需要添加下划线</strong>。</p><p>例如，将文件命名为 <code>_colors.scss</code>，并像如下导入。导入的是 <code>_colors.scss</code> 文件，但不会将其编译成 <code>_colours.css</code> 文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;colors&quot;</span>;<br></code></pre></td></tr></table></figure><p>但是注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 <code>@import</code>，其实，也可以将 <code>@import</code> 嵌套进 CSS 样式或者 <code>@media</code> 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* example.scss 文件 */</span><br><span class="hljs-selector-class">.example</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 另一个非 example.scss 文件 */</span><br><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;example&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-comment">/* 另一个非 example.scss 文件 */</span><br><span class="hljs-selector-id">#main</span> <span class="hljs-selector-class">.example</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 <code>@import</code>。</p><h2 id="media"><a href="#media" class="headerlink" title="@media"></a><code>@media</code></h2><p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。</p><p>如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>; <br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><code>@media</code> 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><code>@media</code> 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">$media: screen;<br>$feature: -webkit-min-device-pixel-ratio;<br>$value: <span class="hljs-number">1.5</span>;<br><br><span class="hljs-keyword">@media</span> #&#123;$media&#125; and ($feature: $value) &#123;<br>  .sidebar &#123;<br>    width: <span class="hljs-number">500px</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">1.5</span>) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="extend"><a href="#extend" class="headerlink" title="@extend"></a><code>@extend</code></h2><p>在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。比如，要设计一个普通错误样式与一个严重错误样式，一般会写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.error</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>;<br>&#125;<br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>麻烦的是，这样做必须时刻记住使用 <code>.seriousError</code> 时需要参考 <code>.error</code> 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 <code>@extend</code> 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.error</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>;<br>&#125;<br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .error;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="How-it-Works"><a href="#How-it-Works" class="headerlink" title="How it Works"></a>How it Works</h3><p><code>@extend</code> 的作用是将重复使用的样式 (<code>.error</code>) 延伸 (extend) 给需要包含这个样式的特殊样式（<code>.seriousError</code>）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.error</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>;<br>&#125;<br><br><span class="hljs-selector-class">.error</span><span class="hljs-selector-class">.intrusion</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/image/hacked.png&quot;</span>);<br>&#125;<br><br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .error;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.error</span>, <br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>; <br>&#125;<br><br><span class="hljs-selector-class">.error</span><span class="hljs-selector-class">.intrusion</span>, <br><span class="hljs-selector-class">.seriousError</span><span class="hljs-selector-class">.intrusion</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/image/hacked.png&quot;</span>); <br>&#125;<br><br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="延伸复杂的选择器"><a href="#延伸复杂的选择器" class="headerlink" title="延伸复杂的选择器"></a>延伸复杂的选择器</h3><p>class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 <code>.special.cool</code>，<code>a:hover</code> 或者 <code>a.user[href^=&quot;http://&quot;]</code> 等。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.hoverlink</span> &#123;<br>  <span class="hljs-keyword">@extend</span> <span class="hljs-attribute">a</span>:<span class="hljs-attribute">hover</span>;<br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">text-decoration</span>: underline;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>, <br><span class="hljs-selector-class">.hoverlink</span> &#123;<br>  <span class="hljs-attribute">text-decoration</span>: underline; <br>&#125;<br></code></pre></td></tr></table></figure><p>跟上面 <code>.error.intrusion</code> 一样，所有 <code>a:hover</code> 的样式将继承给 <code>.hoverlink</code>，包括其他使用到 <code>a:hover</code> 的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.hoverlink</span> &#123;<br>  <span class="hljs-keyword">@extend</span> <span class="hljs-attribute">a</span>:<span class="hljs-attribute">hover</span>;<br>&#125;<br><span class="hljs-selector-class">.comment</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.comment</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-pseudo">:hover</span>, <br><span class="hljs-selector-class">.comment</span> <span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.hoverlink</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重延伸"><a href="#多重延伸" class="headerlink" title="多重延伸"></a>多重延伸</h3><p>同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器。</p><p>多重延伸可以使用逗号分隔选择器名，如 <code>@extend .error, .attention;</code> 与 <code>@extend .error; @extend.attention</code> 有相同的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.error</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>;<br>&#125;<br><span class="hljs-selector-class">.attention</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3em</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0</span>;<br>&#125;<br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .error;<br>  <span class="hljs-keyword">@extend</span> .attention;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.error</span>, <br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>; <br>&#125;<br><br><span class="hljs-selector-class">.attention</span>, <br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3em</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0</span>; &#125;<br><br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继续延伸"><a href="#继续延伸" class="headerlink" title="继续延伸"></a>继续延伸</h3><p>当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.error</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>;<br>&#125;<br><span class="hljs-selector-class">.seriousError</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .error;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>;<br>&#125;<br><span class="hljs-selector-class">.criticalError</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .seriousError;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">10%</span>;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.error</span>, <br><span class="hljs-selector-class">.seriousError</span>, <br><span class="hljs-selector-class">.criticalError</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>; <br>&#125;<br><span class="hljs-selector-class">.seriousError</span>, <br><span class="hljs-selector-class">.criticalError</span> &#123;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>; <br>&#125;<br><span class="hljs-selector-class">.criticalError</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">10%</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择器列"><a href="#选择器列" class="headerlink" title="选择器列"></a>选择器列</h3><p>暂时不可以将选择器列，比如 <code>.foo .bar</code> 或 <code>.foo + .bar</code> 延伸给其他元素，但是，却可以将其他元素延伸给选择器列：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#fake-links</span> <span class="hljs-selector-class">.link</span> &#123;<br>  <span class="hljs-keyword">@extend</span> a;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-tag">a</span>, <br><span class="hljs-selector-id">#fake-links</span> <span class="hljs-selector-class">.link</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue; <br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>, <br><span class="hljs-selector-id">#fake-links</span> <span class="hljs-selector-class">.link</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">text-decoration</span>: underline; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="extend-Only"><a href="#extend-Only" class="headerlink" title="@extend-Only"></a><code>@extend-Only</code></h3><p>有时，需要定义一套样式并不是给某个元素用，而是只通过 <code>@extend</code> 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。</p><p>如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” ，看起来很像普通的 id 或 class 选择器，只是 <code>#</code> 或 <code>.</code> 被替换成了 <code>%</code>。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。</p><p>占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#context</span> <span class="hljs-selector-tag">a</span>%extreme &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;<br>&#125;<br><span class="hljs-selector-class">.notice</span> &#123;<br>  <span class="hljs-keyword">@extend</span> %extreme;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-id">#context</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.notice</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="optional"><a href="#optional" class="headerlink" title="!optional"></a><code>!optional</code></h3><p>如果 <code>@extend</code> 失败会收到错误提示，比如，这样写 <code>a.important &#123; @extend .notice &#125;</code>，当没有 <code>.notice</code> 选择器时，将会报错，只有 <code>h1.notice</code> 包含 <code>.notice</code> 时也会报错，因为 <code>h1</code> 与 <code>a</code> 冲突，会生成新的选择器。</p><p>如果要求 <code>@extend</code> 不生成新选择器，可以通过 <code>!optional</code> 声明达到这个目的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.important</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .notice !optional;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在指令中延伸"><a href="#在指令中延伸" class="headerlink" title="在指令中延伸"></a>在指令中延伸</h3><p>在指令中使用 <code>@extend</code> 时（比如在 <code>@media</code> 中）有一些限制：Sass 不可以将 <code>@media</code> 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。</p><p>也就是说，如果在 <code>@media</code> （或者其他 CSS 指令）中使用 <code>@extend</code>，必须延伸给相同指令层中的选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* ---如下可行--- */</span><br><br><span class="hljs-keyword">@media</span> print &#123;<br>  <span class="hljs-selector-class">.error</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.seriousError</span> &#123;<br>    <span class="hljs-keyword">@extend</span> .error; <span class="hljs-comment">/* 可行 */</span><br>    <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---如下不可行--- */</span><br><br><span class="hljs-selector-class">.error</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#f00</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fdd</span>;<br>&#125;<br><br><span class="hljs-keyword">@media</span> print &#123;<br>  <span class="hljs-selector-class">.seriousError</span> &#123;<br>    <span class="hljs-keyword">@extend</span> .error; <span class="hljs-comment">/* 不可行 */</span><br>    <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="at-root"><a href="#at-root" class="headerlink" title="@at-root"></a>@at-root</h2><p>少用，暂无介绍，仅占坑。</p><h2 id="debug"><a href="#debug" class="headerlink" title="@debug"></a>@debug</h2><p>少用，暂无介绍，仅占坑。</p><h2 id="warn"><a href="#warn" class="headerlink" title="@warn"></a>@warn</h2><p>少用，暂无介绍，仅占坑。</p><h2 id="error"><a href="#error" class="headerlink" title="@error"></a>@error</h2><p>少用，暂无介绍，仅占坑。</p><h1 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h1><p>少用，暂无介绍，仅占坑。</p><h1 id="混合指令"><a href="#混合指令" class="headerlink" title="混合指令"></a>混合指令</h1><p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left</code>。</p><p>混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式。</p><p>混合也需要包含选择器和属性，甚至可以用 <code>&amp;</code> 引用父选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> large-text &#123;<br>  <span class="hljs-attribute">font</span>: &#123;<br>    family: Arial;<br>    size: <span class="hljs-number">20px</span>;<br>    weight: bold;<br>  &#125;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> clearfix &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  &amp;:after &#123;<br>    content: <span class="hljs-string">&quot;.&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>: both;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>  &#125;<br>  * <span class="hljs-selector-tag">html</span> &amp; &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span> <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p><p>也可以在最外层引用混合样式，这样不会直接定义属性，也不可以使用父选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.page-title</span> &#123;<br>  <span class="hljs-keyword">@include</span> large-text;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> silly-links &#123;<br>  <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>    <span class="hljs-attribute">background-color</span>: red;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">@include</span> silly-links;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.page-title</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: Arial;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>; <br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>  <span class="hljs-attribute">background-color</span>: red; <br>&#125;<br></code></pre></td></tr></table></figure><p>混合样式中也可以包含其他混合样式。所以，混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> compound &#123;<br>  <span class="hljs-keyword">@include</span> highlighted-background;<br>  <span class="hljs-keyword">@include</span> header-text;<br>&#125;<br><span class="hljs-keyword">@mixin</span> highlighted-background &#123; <br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fc0</span>; <br>&#125;<br><span class="hljs-keyword">@mixin</span> header-text &#123; <br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数用于给混合指令中的样式设定变量，并且赋值使用。</p><p>在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> sexy-border($<span class="hljs-attribute">color</span>, $<span class="hljs-attribute">width</span>) &#123;<br>  <span class="hljs-attribute">border</span>: &#123;<br>    color: $color;<br>    <span class="hljs-attribute">width</span>: $width;<br>    style: dashed;<br>  &#125;<br>&#125;<br><span class="hljs-selector-tag">p</span> &#123; <br>  <span class="hljs-keyword">@include</span> sexy-border(blue, <span class="hljs-number">1in</span>); <br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: blue;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">1in</span>;<br>  <span class="hljs-attribute">border-style</span>: dashed; <br>&#125;<br></code></pre></td></tr></table></figure><p>混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> sexy-border($<span class="hljs-attribute">color</span>, $<span class="hljs-attribute">width</span>: <span class="hljs-number">1in</span>) &#123;<br>  <span class="hljs-attribute">border</span>: &#123;<br>    color: $color;<br>    <span class="hljs-attribute">width</span>: $width;<br>    style: dashed;<br>  &#125;<br>&#125;<br><span class="hljs-selector-tag">p</span> &#123; <br>  <span class="hljs-keyword">@include</span> sexy-border(blue); <br>&#125;<br><span class="hljs-selector-tag">h1</span> &#123; <br>  <span class="hljs-keyword">@include</span> sexy-border(blue, <span class="hljs-number">2in</span>); <br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: blue;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">1in</span>;<br>  <span class="hljs-attribute">border-style</span>: dashed; <br>&#125;<br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: blue;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">2in</span>;<br>  <span class="hljs-attribute">border-style</span>: dashed; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键词参数"><a href="#关键词参数" class="headerlink" title="关键词参数"></a>关键词参数</h3><p>混合指令也可以使用关键词参数，上面的例子也可以写成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123; <br>  <span class="hljs-keyword">@include</span> sexy-border($<span class="hljs-attribute">color</span>: blue); <br>&#125;<br><span class="hljs-selector-tag">h1</span> &#123; <br>  <span class="hljs-keyword">@include</span> sexy-border($<span class="hljs-attribute">color</span>: blue, $<span class="hljs-attribute">width</span>: <span class="hljs-number">2in</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>虽然不够简明，但是阅读起来会更方便。</p><p>关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。</p><h3 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h3><p>有时，不能确定混合指令需要使用多少个参数，比如一个关于 <code>box-shadow</code> 的混合指令不能确定有多少个 ‘shadow’ 会被用到。</p><p>这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> box-shadow($shadows...) &#123;<br>  -moz-<span class="hljs-attribute">box-shadow</span>: $shadows;<br>  -webkit-<span class="hljs-attribute">box-shadow</span>: $shadows;<br>  <span class="hljs-attribute">box-shadow</span>: $shadows;<br>&#125;<br><span class="hljs-selector-class">.shadows</span> &#123;<br>  <span class="hljs-keyword">@include</span> box-shadow(<span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">5px</span> #<span class="hljs-number">666</span>, <span class="hljs-number">2px</span> <span class="hljs-number">6px</span> <span class="hljs-number">10px</span> #<span class="hljs-number">999</span>);<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.shadowed</span> &#123;<br>  -moz-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#666</span>, <span class="hljs-number">2px</span> <span class="hljs-number">6px</span> <span class="hljs-number">10px</span> <span class="hljs-number">#999</span>;<br>  -webkit-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#666</span>, <span class="hljs-number">2px</span> <span class="hljs-number">6px</span> <span class="hljs-number">10px</span> <span class="hljs-number">#999</span>;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#666</span>, <span class="hljs-number">2px</span> <span class="hljs-number">6px</span> <span class="hljs-number">10px</span> <span class="hljs-number">#999</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数变量也可以用在引用混合指令的时候 (<code>@include</code>)，与平时用法一样，将一串值列表中的值逐条作为参数引用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> colors($text, $background, $border) &#123;<br>  <span class="hljs-attribute">color</span>: $text;<br>  <span class="hljs-attribute">background-color</span>: $background;<br>  <span class="hljs-attribute">border-color</span>: $border;<br>&#125;<br><br>$values: <span class="hljs-number">#ff0000</span>, <span class="hljs-number">#00ff00</span>, <span class="hljs-number">#0000ff</span>;<br><br><span class="hljs-selector-class">.primary</span> &#123;<br>  <span class="hljs-keyword">@include</span> colors($values...);<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.primary</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00ff00</span>;<br>  <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#0000ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用变量参数来包装混合器，并在不改变混合器的参数的情况下添加额外的样式。如果这样做，即使是关键字参数也会被传递到被包裹的混合器中。</p><p>下面的 <code>$width</code> 参数将会传递给 <code>stylish-mixin</code> 作为关键词。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> wrapped-stylish-mixin($args...) &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-keyword">@include</span> stylish-mixin($args...);<br>&#125;<br><br><span class="hljs-selector-class">.stylish</span> &#123;<br>  <span class="hljs-keyword">@include</span> wrapped-stylish-mixin(#<span class="hljs-number">00</span>ff00, $<span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="向混合样式导入内容"><a href="#向混合样式导入内容" class="headerlink" title="向混合样式导入内容"></a>向混合样式导入内容</h2><p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 <code>@content</code> 标志的地方。</p><p>注意： 当 <code>@content</code> 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。</p><p>此外，为便于书写，<code>@mixin</code> 可以用 <code>=</code> 表示，而 <code>@include</code> 可以用 <code>+</code> 表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> apply-to-ie6-only &#123;<br>  * <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-keyword">@content</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">@include</span> apply-to-ie6-only &#123;<br>  <span class="hljs-selector-id">#logo</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/logo.gif</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br>* <span class="hljs-selector-tag">html</span> <span class="hljs-selector-id">#logo</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/logo.gif</span>);<br>&#125;<br><br><span class="hljs-comment">/* ---最上面的可以写成如下--- */</span><br><br>=apply-<span class="hljs-selector-tag">to</span>-ie6-only<br>  * <span class="hljs-selector-tag">html</span><br>    <span class="hljs-keyword">@content</span><br><br>+apply-to-ie6-only<br>  #logo<br>    <span class="hljs-attribute">background-image</span>: url(/logo.gif)<br></code></pre></td></tr></table></figure><p>传递给 <code>@mixin</code> 的内容块在定义该块的范围内被评估，而不是在 <code>@mixin</code> 的范围内。这意味着 <code>@mixin</code> 的本地变量不能在传递的样式块中使用，变量将解析为全局值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">$<span class="hljs-attribute">color</span>: white;<br><span class="hljs-keyword">@mixin</span> colors($<span class="hljs-attribute">color</span>: blue) &#123;<br>  <span class="hljs-attribute">background-color</span>: $color;<br>  <span class="hljs-keyword">@content</span>;<br>  <span class="hljs-attribute">border-color</span>: $color;<br>&#125;<br><span class="hljs-selector-class">.colors</span> &#123;<br>  <span class="hljs-keyword">@include</span> colors &#123; <span class="hljs-attribute">color</span>: $color; &#125;<br>&#125;<br><br><span class="hljs-comment">/* ---编译为如下--- */</span><br><br><span class="hljs-selector-class">.colors</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">border-color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外这也清楚地表明，在传递的块中使用的变量和混合元素与定义块的周围的其他样式有关。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#sidebar</span> &#123;<br>  $sidebar-<span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">width</span>: $sidebar-width;<br>  <span class="hljs-keyword">@include</span> smartphone &#123;<br>    <span class="hljs-attribute">width</span>: $sidebar-width / <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数指令"><a href="#函数指令" class="headerlink" title="函数指令"></a>函数指令</h1><p>少用，暂无介绍，仅占坑。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>少用，暂无介绍，仅占坑。</p><h1 id="扩展Sass"><a href="#扩展Sass" class="headerlink" title="扩展Sass"></a>扩展Sass</h1><p>少用，暂无介绍，仅占坑。</p>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>知识技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React生命周期</title>
    <link href="/2022/12/04/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/12/04/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://juejin.cn/post/7096137407409422344">https://juejin.cn/post/7096137407409422344</a></li><li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></li><li><a href="https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle">https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle</a></li></ul><p>Demo：</p><ul><li><a href="https://github.com/xuekeven/learn-react/blob/main/src/hook/lifeCycle/index.tsx">https://github.com/xuekeven/learn-react/blob/main/src/hook/lifeCycle/index.tsx</a> 。</li></ul><h1 id="总括"><a href="#总括" class="headerlink" title="总括"></a>总括</h1><p>在 React 中，对于每一次由状态改变导致页面视图的改变，都会经历两个阶段：<code>render 阶段</code>和 <code>commit 阶段</code>。</p><p>只有 class 组件才有生命周期，因为 class 组件会创建对应的实例，而函数组件不会。组件实例从被创建到被销毁的过程称为<strong>组件的生命周期</strong>。</p><p>由 class 组件创建的实例具有生命周期，它的 render 函数在 render 阶段执行，并在此阶段进行 DOM 节点的 diff（diff 算法就是在此阶段进行的），找出需要改变的 DOM 操作。然后在 commit 阶段将对应的 DOM 操作提交至视图中。class 组件实例的所有生命周期函数，都会在 render 阶段和 commit 阶段执行。</p><p>生命周期图：</p><ul><li>在首次渲染页面时，会调用 Mount 相关生命周期钩子；在之后的页面渲染中，会调用 Update 相关生命周期钩子。所以与 Mount 相关的生命周期钩子只会被调用一次。</li><li>红色为 React 17 已经废弃的生命周期钩子，绿色为新增的生命周期钩子。且被废弃的生命周期钩子和新增的生命周期钩子不能同时出现在代码中。</li></ul><p><img src="/images/ReactLifeCycle.png" alt="ReactLifeCycle"></p><h1 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h1><p>在首次渲染时有生命周期：</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>componentWillMount</li><li>render</li></ul><p>在更新时有生命周期：</p><ul><li>componentWillReceiveProps</li><li>getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li></ul><p>在捕捉到错误时有生命周期：</p><ul><li>getDerivedStateFromError</li></ul><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>该方法只会执行一次，调用该方法会返回一个组件实例。</p><p>在初始化阶段执行，可直接对 <code>this.state</code> 赋值。其它生命周期函数中只能通过 <code>this.setState</code> 修改 state，不能直接为 <code>this.state</code> 赋值。</p><p><strong>使用场景</strong>：一般在 constructor 中做一些组件的初始化工作，例如：初始化组件的 state。</p><h2 id="componentWillReceiveProps-UNSAFE"><a href="#componentWillReceiveProps-UNSAFE" class="headerlink" title="componentWillReceiveProps(UNSAFE)"></a>componentWillReceiveProps(UNSAFE)</h2><p>在已挂载组件接收到新的 props 之前调用。你可以在这个函数中比较新旧 props，并根据新旧 props 更改 state。但是它会<strong>破坏 props 数据的单一数据源</strong>。</p><p>在首次渲染组件时，不会调用此生命周期钩子；使用 <code>this.setState</code> 触发组件更新时，也不会调用此生命周期钩子。不过要注意：如果是父组件渲染导致了组件的重新渲染，即使传给该组件的 props 没变，该组件中的这个生命周期函数也会被调用。</p><p>我们一般不使用此生命周期函数，因为它通常会破坏数据源的单一性。</p><h2 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h2><p>这是一个<strong>静态方法</strong>，接收 props 和 state 两个参数。它会在调用 render 方法之前被调用，不管是在初始挂载时还是在后续组件更新时都会被调用。</p><p>它的调用时机和 componentWillMount、componentWillUpdate、componentWillReceiveProps 一样都是在 render 方法被调用之前，它可以作为 componentWillMount、componentWillUpdate、componentWillReceiveProps 的替代方案。</p><p>当然它的作用不止如此，它可以返回一个对象，用来更新 state，就像它的名字一样，从 props 中获取衍生的 state。如果不需要更新 state 则可以返回 null。</p><p>需要<strong>注意</strong>的是：这个生命周期函数是类的<strong>静态方法</strong>，并不是原型中的方法，所以在其内部使用 this 访问到的不是组件实例。此生命周期钩子不常用，如果可以的话，我们也尽可能不会使用它。</p><p>为什么要废弃 componentWillMount、componentWillUpdate、componentWillReceiveProps 生命周期钩子而新增 getDerivedStateFromProps 生命周期钩子，后面会说明原因。</p><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>在组件准备更新之前调用，但是首次渲染或者使用 forceUpdate 函数时不会被调用。跟它的名字一样，它用来判断一个组件是否应该更新。</p><p>默认情况下，当组件的 props 或者 state 变化时，都会导致组件更新。它在 render 方法之前执行，如果它的返回值为 false，则不会更新组件，也不会执行后面关于更新组件的相关方法。</p><p>它接收两个参数，nextProps 和 nextState，即下一次更新的 props 和下一次更新的 state。我们可以将 <code>this.props</code> 和 nextProps 比较，以及将 <code>this.state</code> 与 nextState 比较，并返回 false，让组件跳过更新。不过<strong>注意</strong>：它并不会阻止子组件因为 state 改变而导致的更新。</p><p>使用场景：这个生命周期方法通常用来做性能优化。</p><h2 id="componentWillMount-UNSAFE"><a href="#componentWillMount-UNSAFE" class="headerlink" title="componentWillMount(UNSAFE)"></a>componentWillMount(UNSAFE)</h2><p>在组件挂载至 DOM 之前调用，并且只会调用一次。它在 render 方法之前调用，因此在 componentWillMount 中调用 <code>this.setState</code> 不会触发额外的渲染。</p><p>我们一般在 constructor 中初始化 state，在 componentDidMount 中<strong>引入副作用</strong>或者<strong>订阅内容</strong>，所以这个生命周期钩子使用频率较小。</p><h2 id="componentWillUpdate-UNSAFE"><a href="#componentWillUpdate-UNSAFE" class="headerlink" title="componentWillUpdate(UNSAFE)"></a>componentWillUpdate(UNSAFE)</h2><p>在组件即将更新之前执行，如果 shouldComponentUpdate 函数返回 false，则不会调用本方法。</p><p>这个生命周期钩子和 componentWillMount 类似，执行的时机是相同的，只不过 componentWillMount 在组件首次渲染时执行，而 componentWillUpdate 在组件后续更新时执行。这两个生命周期函数都不经常使用。</p><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>render 方法是 class 组件中唯一必须实现的方法，它的返回值将作为页面渲染的视图。render 函数应该为纯函数，也就是对于相同的 state 和 props，它总是返回相同的渲染结果。</p><p>render 函数被调用时，会返回以下四种类型之一：</p><ul><li>React 元素：通常为 JSX 语法。例如：<code>&lt;div /&gt;</code>、<code>&lt;MyComponent&gt;</code> 等。</li><li>数组或者 fragments：render 方法可以通过数组返回多个元素。</li><li>Portals：渲染子节点至不同的子树中。</li><li>字符串或者数值：会作为文本节点被渲染。</li><li>boolean 类型或者 null：什么都不渲染。</li></ul><p>需要<strong>注意</strong>的是：如果 shouldComponentUpdate 生命周期钩子返回 false，则不会执行关于更新组件的相关方法。</p><h1 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h1><p>在首次渲染时有生命周期：</p><ul><li>componentDidMount</li></ul><p>在更新时有生命周期：</p><ul><li>getSnapshotBeforeUpdate </li><li>componentDidUpdate</li></ul><p>在卸载时有生命周期：</p><ul><li>componentWillUnmount</li></ul><p>在捕捉到错误时有生命周期：</p><ul><li>componentDidCatch</li></ul><h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p>该生命周期方法会在组件挂载之后执行，也只会执行一次，也就是将组件对应的 DOM 插入 DOM 树中之后调用。</p><p>它会在浏览器更新视图之前调用，如果在 componentDidMount 中<strong>直接调用</strong> <code>this.setState</code>，它会触发额外的渲染，会再一次调用 render 函数，但是浏览器中视图的更新只会执行一次。</p><p><strong>使用场景</strong>：<strong>依赖于 DOM 的初始化</strong>操作应该放在这里，我们一般在这个生命周期方法中<strong>发送网络请求</strong>、<strong>添加订阅</strong>等。</p><h2 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h2><p>此生命周期函数在最近一次渲染提交至 DOM 树之前执行，此时 DOM 树还未改变，我们可以在这里获取 DOM 改变前的信息，例如：更新前的 DOM 的滚动位置。</p><p>它接收两个参数，分别是：prevProps 和 prevState（上一个状态的 props 和上一个状态的 state）。它的返回值将会传递给 componentDidUpdate 生命周期钩子的第三个参数。</p><p>使用场景：需要<strong>获取更新前 DOM 的信息</strong>时。例如：需要以特殊方式处理滚动位置的聊天线程等。</p><h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><p>在组件更新后立即调用。它的执行时机和 componentDidMount 一致，只是 componentDidMount 在首次渲染时调用，而 componentDidUpdate 在后续的组件更新时调用。</p><p>可以在这个生命周期中直接调用 <code>this.setState</code>，但是必须包裹在一个条件语句中，否则会导致死循环。</p><p>componentDidUpdate 接收三个参数，分别是 prevProps、prevState、snapshot，即：前一个状态的 props，前一个状态的 state、getSnapshotBeforeUpdate 的返回值。</p><p>使用场景：在这个生命周期方法中，可以<strong>对 DOM 进行操作</strong>或者进行<strong>网络请求</strong>。</p><h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><p>这个生命周期函数会在组件卸载以及销毁之前调用。</p><p>使用场景：通常用来执行组件的<strong>清理操作</strong>，例如：清除 timer、取消网络请求、清除订阅等。</p><h1 id="废弃"><a href="#废弃" class="headerlink" title="废弃"></a>废弃</h1><h2 id="在-16-3-版本"><a href="#在-16-3-版本" class="headerlink" title="在 16.3 版本"></a>在 16.3 版本</h2><p>React 将 componentWillMount、componentWillReceiveProps、componentWillUpdate 三个生命周期钩子加上了 UNSAFE 前缀，变为 UNSAFE_componentWillMount、UNSAFE_componentWillReceiveProps、UNSAFE_componentWillUpdate。并引入了一个新的生命周期钩子：getDerivedStateFromProps。</p><h2 id="在-17-0-及之后版本"><a href="#在-17-0-及之后版本" class="headerlink" title="在 17.0 及之后版本"></a>在 17.0 及之后版本</h2><p>React 删除了 componentWillMount、componentWillReceiveProps、componentWillUpdate 这三个生命周期钩子。不过 UNSAFE_componentWillMount、UNSAFE_componentWillReceiveProps 和 UNSAFE_componentWillUpdate 还是可以用的。</p><h2 id="为什么要废弃"><a href="#为什么要废弃" class="headerlink" title="为什么要废弃"></a>为什么要废弃</h2><p>我们知道 React 的更新流程分为：render 阶段和 commit 阶段。componentWillMount、componentWillReceiveProps、componentWillUpdate 这三个生命周期钩子都是在 render 阶段执行的。</p><p>在 fiber 架构被应用之前，render 阶段是不能被打断的。当页面逐渐复杂之后，就有可能会阻塞页面的渲染，于是 React 推出了 fiber 架构。在应用 fiber 架构之后，低优先级任务的 render 阶段可以被高优先级任务打断。</p><p>而这导致的<strong>问题</strong>就是：<strong>在 render 阶段执行的生命周期函数可能被执行多次</strong>。像 componentWillMount、componentWillReceiveProps、componentWillUpdate 这三个生命周期钩子，如果我们在其中执行一些具有副作用的操作，例如发送网络请求，就有可能导致一个同样的网络请求被执行多次，这显然不是我们想看到的。</p><p>而 React 又没法强迫开发者不去这样做，因为怎么样使用 React 是开发者的自由，所以 React 就新增了一个静态的生命周期 getDerivedStateFromProps，来解决这个问题。</p><p>用一个静态函数 getDerivedStateFromProps 来取代被废弃的几个生命周期函数，这样开发者就无法通过 this 获取到组件的实例，也不能发送网络请求以及调用 <code>this.setState</code>。它就是强制开发者在 render 之前只做无副作用的操作，间接强制我们无法进行这些不合理不规范的操作，从而避免对生命周期的滥用。</p><h1 id="父子组件调用顺序"><a href="#父子组件调用顺序" class="headerlink" title="父子组件调用顺序"></a>父子组件调用顺序</h1><p>由不同的原因导致的组件渲染，React 会执行不同的生命周期函数。</p><h2 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h2><ul><li>首先<strong>依次</strong>执行父组件 render 阶段的生命周期函数；</li><li>然后<strong>依次</strong>执行子组件 render 阶段的生命周期函数；</li><li>最后<strong>交叉</strong>执行子组件和父组件 commit 阶段的生命周期函数。</li></ul><p>React Fiber 树的构建、更新类似于树的先序遍历（深度优先搜索）。在“递归”时，执行 render 阶段的生命周期函数；在“回溯”时，执行 commit 阶段的生命周期函数。</p><p>对于 render 阶段的生命周期函数，其顺序是 父组件 -&gt; 子组件；而对于 commit 阶段的生命周期函数，其顺序是 子组件 -&gt; 父组件。</p><p>需要<strong>注意</strong>的是：这里的执行顺序并不是真正的树的先序遍历。在“回溯”时，是交叉执行各子组件和父组件 commit 阶段的生命周期函数。</p><h2 id="子组件状态改变"><a href="#子组件状态改变" class="headerlink" title="子组件状态改变"></a>子组件状态改变</h2><p>子组件的状态发生改变，只会重新渲染子组件，执行该子组件对应的生命周期函数，而不会执行其父组件或其兄弟组件的生命周期函数。</p><h2 id="父组件状态改变"><a href="#父组件状态改变" class="headerlink" title="父组件状态改变"></a>父组件状态改变</h2><p>它们的执行顺序和首次渲染中得到的结论一样，还是满足如下特点：</p><ul><li>首先<strong>依次</strong>执行父组件 render 阶段的生命周期函数；</li><li>然后<strong>依次</strong>执行子组件 render 阶段的生命周期函数；</li><li>最后<strong>交叉</strong>执行子组件和父组件 commit 阶段的生命周期函数。</li></ul><p>注意：如果使用 React.memo() 将子组件包裹，且父组件传给子组件的 props 没有变，则子组件不会重新渲染，不会执行相关的生命周期函数。</p>]]></content>
    
    
    <categories>
      
      <category>框架和类库</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>框架和类库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hook</title>
    <link href="/2022/12/03/React%20Hook/"/>
    <url>/2022/12/03/React%20Hook/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">https://zh-hans.reactjs.org/docs/hooks-reference.html</a> 。</p><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>参考：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate">https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate</a> 。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [state, setState] = useState(initialState);<br></code></pre></td></tr></table></figure><p>传入一个 <code>initialState</code> （也可以不传）；返回一个 <code>state</code>，以及更新 <code>state</code> 的函数 <code>setState</code>。在初始渲染期间，返回的状态 <code>state</code> 与传入的第一个参数 <code>initialState</code> 值相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">setState(newState);<br></code></pre></td></tr></table></figure><p><code>setState</code> 函数用于更新 <code>state</code>，它接收一个新的 <code>newState</code> 值并将组件的一次重新渲染加入队列。在后续的重新渲染中，<code>useState</code> 返回的第一个值将始终是更新后最新的 <code>state</code>。不过，如果 <code>setState</code> 函数接受的值与当前 <code>state</code> 值完全相同，则随后的重渲染会被完全跳过。</p><p>注意，React 会确保 <code>setState</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>setState</code>。</p><h2 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h2><p>如果新的 <code>state</code> 需要通过使用先前的 <code>state</code> 计算得出，那么可以将<strong>函数</strong>传递给 <code>setState</code>。该函数将接收先前的 <code>state</code>，并返回一个更新后的值。实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(initialCount);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      Count: &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(initialCount)&#125;&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count - 1)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，与 class 组件中的 <code>setState</code> 方法不同，<code>useState</code> 不会自动合并更新对象。可以用函数式的 <code>setState</code> 结合展开运算符来达到合并更新对象的效果。（<code>useReducer</code> 是另一种可选方案，它更适合用于管理包含多个子值的 <code>state</code> 对象。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [state, setState] = useState(&#123;&#125;);<br><span class="hljs-comment">// ...</span><br>setState(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;...prevState, ...updatedValues&#125;; <span class="hljs-comment">// 也可以使用 Object.assign</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="惰性初始-state"><a href="#惰性初始-state" class="headerlink" title="惰性初始 state"></a>惰性初始 <code>state</code></h2><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 <code>state</code> 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 <code>state</code>，此函数只在初始渲染时被调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [state, setState] = useState(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> initialState = someExpensiveComputation(props);<br>  <span class="hljs-keyword">return</span> initialState;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="跳过-state-更新"><a href="#跳过-state-更新" class="headerlink" title="跳过 state 更新"></a>跳过 <code>state</code> 更新</h2><p>如前所述，如果更新 State Hook 后的 <code>state</code> 与当前的 <code>state</code> 相同时，React 将跳过子组件的渲染并且不会触发 effect 的执行。（React 使用 <code>Object.is</code> 比较算法 来比较 <code>state</code>）</p><p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><h2 id="Batching-of-state-updates"><a href="#Batching-of-state-updates" class="headerlink" title="Batching of state updates"></a>Batching of state updates</h2><p>React may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.</p><p>Before React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.</p><p>In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in flushSync. However, this can hurt performance so do this only where needed.</p><p>React 可以将多个状态更新分组到单个重新渲染中以提高性能。通常，这会提高性能，并且不会影响应用程序的行为。</p><p>在 React 18 之前，只有 React 事件处理程序中的更新被批处理。从 React 18 开始，默认情况下为所有更新启用批处理。请注意，React 确保来自几个不同用户启动的事件的更新——例如，单击一个按钮两次——总是单独处理的，不会被批处理。这可以防止逻辑错误。</p><p>在极少数情况下，您需要强制同步应用 DOM 更新，您可以将其包装在 flushSync 中。但是，这可能会损害性能，因此请仅在需要时执行此操作。</p><h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><p>参考：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect">https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect</a> 。</p><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">useEffect(didUpdate);<br></code></pre></td></tr></table></figure><p>该 Hook 接收一个包含命令式、且可能有副作用代码的函数。</p><p>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。</p><p>使用 <code>useEffect</code> 完成副作用操作。赋值给 <code>useEffect</code> 的函数会在<strong>组件渲染到屏幕之后</strong>执行。你可以把 <code>effect</code> 看作从 React 的纯函数式世界通往命令式世界的逃生通道。</p><p>默认情况下，<code>effect</code> 将在每轮渲染结束后执行，但你可以选择让它 [在只有某些值改变的时候()] 才执行。</p><h2 id="清除-effect"><a href="#清除-effect" class="headerlink" title="清除 effect"></a>清除 <code>effect</code></h2><p>通常，组件卸载时需要清除 <code>effect</code> 创建的诸如订阅或计时器 ID 等资源。要实现这一点，<code>useEffect</code> 函数需<strong>返回一个清除函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> subscription = props.source.subscribe();<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 清除订阅</span><br>    subscription.unsubscribe();<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 <code>effect</code> 之前，上一个 <code>effect</code> 就已被清除。在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都触发 <code>effect</code> 的执行，请参阅下一小节。</p><h2 id="effect-的执行时机"><a href="#effect-的执行时机" class="headerlink" title="effect 的执行时机"></a><code>effect</code> 的执行时机</h2><p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，传给 <code>useEffect</code> 的函数会<strong>在浏览器完成布局与绘制之后、在一个延迟事件中被调用</strong>。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作<strong>不应阻塞</strong>浏览器对屏幕的更新。</p><p>然而，并非所有 <code>effect</code> 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别）React 为此提供了一个额外的 <code>useLayoutEffect</code> Hook 来处理这类 <code>effect</code>。它和 <code>useEffect</code> 的结构相同，区别只是调用时机不同。</p><p>此外，从 React 18 开始，当它是离散的用户输入（如点击）的结果时，或者当它是由 flushSync 包装的更新结果时，传递给 <code>useEffect</code> 的函数将在屏幕布局和绘制之前同步执行。这种行为便于事件系统或 flushSync 的调用者观察该效果的结果。</p><p>即使在 <code>useEffect</code> 被推迟到浏览器绘制之后的情况下，它也能保证在任何新的渲染前启动执行。React 在开始新的更新前，总会先刷新之前的渲染的 <code>effect</code>。</p><h2 id="effect-的条件执行"><a href="#effect-的条件执行" class="headerlink" title="effect 的条件执行"></a><code>effect</code> 的条件执行</h2><p>默认情况下，<code>effect</code> 会在每轮组件渲染完成后执行。这样的话，一旦 <code>effect</code> 的依赖发生变化，它就会被重新创建。然而，在某些场景下这么做可能会矫枉过正。比如，我们可能不需要在每次组件更新时都创建新的订阅，而是仅需要在一些值改变时重新创建。</p><p>要实现这一点，可以给 <code>useEffect</code> 传递第二个参数，它是 <code>effect</code> 所依赖的值数组。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">useEffect(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> subscription = props.source.subscribe();<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      subscription.unsubscribe();<br>    &#125;;<br>  &#125;,<br>  [props.source],<br>);<br></code></pre></td></tr></table></figure><p>依赖项数组不会作为参数传给 <code>effect</code> 函数。虽然从概念上来说它表现为：所有 <code>effect</code> 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p><p>注意，如果要使用此优化方式，请确保数组中包含了所有外部作用域中会发生变化且在 <code>effect</code> 中使用的变量，否则代码会引用到先前渲染中的旧变量。</p><p>如果想执行只运行一次的 <code>effect</code>（仅在组件挂载和卸载时执行），可以传递一个空数组作为第二个参数。这就告诉 React 你的 <code>effect</code> 不依赖于 <code>props</code> 和 <code>state</code> 中的任何值，所以它永远都不需要重复执行。</p><p>如果传入了一个空数组，<code>effect</code> 内部的 <code>props</code> 和 <code>state</code> 就会一直持有其初始值。尽管传入空数组作为第二个参数有点类似于 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 的思维模式，但我们有更好的方式 来避免过于频繁的重复调用 <code>effect</code>。除此之外，记得 React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code>，因此会使得处理额外操作很方便。</p><p>不传依赖项数组：<code>effct</code>会在每轮组件渲染完成后执行；传依赖项数组为空数组：<code>effct</code>会在组件挂载时仅执行一次。两者不同！</p><h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><p>参考：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext</a> 。</p><h2 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> value = useContext(MyContext);<br></code></pre></td></tr></table></figure><p>接收一个 <code>context</code> 对象（<code>React.createContext</code> 的返回值 <code>MyContext</code>）并返回该 <code>context</code> 的当前值。当前的 <code>context</code> 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 <code>context</code> <code>value</code> 值。即使祖先使用 <code>React.memo</code> 或 <code>shouldComponentUpdate</code>，也会在组件本身使用 <code>useContext</code> 时重新渲染。<code>useContext(MyContext)</code> 相当于 class 组件中的 <code>static contextType = MyContext</code> 或者 <code>&lt;MyContext.Consumer&gt;</code>。</p><p>注意，<code>useContext</code> 的参数必须是 <code>context</code> 对象本身，正确使用方法是 <code>useContext(MyContext)</code>，<code>useContext(MyContext.Consumer)</code>和<code>useContext(MyContext.Provider)</code> 都是错误的。</p><p>调用了 <code>useContext</code> 的组件总会在 <code>context</code> 值变化时重新渲染。如果重渲染组件的开销较大，可以通过使用 <code>memoization</code> 来优化。</p><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> themes = &#123;<br>  <span class="hljs-attr">light</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;white&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">dark</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;black&quot;</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> ThemeContext = React.createContext(themes.light);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GroundFather</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;themes.dark&#125;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">GroundSon</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GroundSon</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> theme = useContext(ThemeContext);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">background:</span> <span class="hljs-attr">theme.background</span>, <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.foreground</span> &#125;&#125;&gt;</span></span><br><span class="xml">      I am styled by theme context!</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><p>参考：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer</a> 。</p><h2 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);<br></code></pre></td></tr></table></figure><p>这是 useState 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 <code>reducer</code>，并返回当前的 <code>state</code> 以及与其配套的 <code>dispatch</code> 方法。</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 <code>state</code> 逻辑较复杂且包含多个子值，或者下一个 <code>state</code> 依赖于之前的 <code>state</code> 等。并且使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数。</p><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> initialState = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      Count: &#123;state.count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>意，React 会确保 <code>dispatch</code> 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code>。</p><h2 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h2><p>可以选择惰性地创建初始 <code>state</code>。为此，需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 <code>state</code> 将被设置为 <code>init(initialArg)</code>。</p><p>这么做可以将用于计算 <code>state</code> 的逻辑提取到 <code>reducer</code> 外部，这也为将来对重置 <code>state</code> 的 <code>action</code> 做处理提供了便利：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">initialCount</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: initialCount &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>      <span class="hljs-keyword">return</span> init(action.payload);<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">&#123; initialCount &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      Count: &#123;state.count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27;, payload: initialCount &#125;)&#125;&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="跳过-dispatch"><a href="#跳过-dispatch" class="headerlink" title="跳过 dispatch"></a>跳过 dispatch</h2><p>如前所述，如果更新 Reducer Hook 后的 <code>state</code> 与当前的 <code>state</code> 相同时，React 将跳过子组件的渲染及副作用的执行。（React 使用 <code>Object.is</code> 比较算法来比较 <code>state</code>）</p><p>需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p>参考：</p><ul><li><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback">https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback</a></li><li><a href="https://juejin.cn/post/6844904101445124110">https://juejin.cn/post/6844904101445124110</a></li></ul><p>Demo：<a href="https://github.com/xuekeven/learn-react/blob/main/src/hook/useCallBack/index.tsx">https://github.com/xuekeven/learn-react/blob/main/src/hook/useCallBack/index.tsx</a> 。</p><h2 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> memoizedCallback = useCallback(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    doSomething(a, b);<br>  &#125;,<br>  [a, b],<br>);<br></code></pre></td></tr></table></figure><p>简单来说就是传递一个返回的函数和依赖项，只有在依赖项发生变化的时候才会更新（返回一个新的函数），否则返回的原函数不变。</p><p>依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有的回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p><p>不要把所有的方法都包上 <code>useCallback</code>。<code>useCallback</code> 是要配合子组件的 <code>shouldComponentUpdate</code> 或 <code>React.memo</code> 一起来使用的，否则就是反向优化。</p><p>组件重新渲染时，<code>useCallback</code> 里面的函数也会声明一个新的函数，并被传入到 <code>useCallback</code> 中，尽管这个新的函数有可能因为依赖项没有发生改变不会被返回到定义的变量上。那么在这种情况下，它返回新的函数和老的函数也都一样，如果子组件没有使用 <code>shouldComponentUpdate</code> 或 <code>React.memo</code>，子组件都会被重新渲染，这时使用 <code>useCallback</code> 后每次执行到这里内部要要比对依赖项是否变化，还要存一下之前的函数，消耗更大了。</p><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><p>参考：</p><ul><li><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo">https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo</a></li><li><a href="https://juejin.cn/post/6844904101445124110">https://juejin.cn/post/6844904101445124110</a></li></ul><p>Demo：<a href="https://github.com/xuekeven/learn-react/blob/main/src/hook/useMemo/index.tsx">https://github.com/xuekeven/learn-react/blob/main/src/hook/useMemo/index.tsx</a> 。</p><h2 id="基础-5"><a href="#基础-5" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> memoizedValue = useMemo(<span class="hljs-function">() =&gt;</span> computeExpensiveValue(a, b), [a, b]);<br></code></pre></td></tr></table></figure><p>简单来说就是传递一个创建函数和依赖项，创建函数需要返回一个值，只有在依赖项发生改变的时候，才会重新调用此函数返回一个新的值，否则返回的原值不变。</p><p><code>useMemo</code> 与 <code>useCallback</code> 很像，根据 <code>useCallback</code> 可以想到 <code>useMemo</code> 也能针对传入子组件的值进行缓存优化，有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行不应该在渲染期间内执行的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值。</p><p>依赖项数组不会作为参数传给“创建”函数。虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>可以把一些昂贵的计算逻辑放到 <code>useMemo</code> 中，只有当依赖值发生改变的时候才去更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> num = useMemo(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 这里使用 count 针对 num 做一些很复杂的计算，</span><br>  <span class="hljs-comment">// 当 count 没改变的时候，组件重新渲染就会直接返回之前缓存的值。</span><br>  <span class="hljs-keyword">return</span> num;<br>&#125;, [count]);<br><br><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>事实上在使用中 <code>useMemo</code> 的场景远比 <code>useCallback</code> 要广泛的很多，我们可以将 <code>useMemo</code> 的返回值定义为返回一个函数这样就可以变通的实现了 <code>useCallback</code>。在开发中当我们有部分变量改变时会影响到多个地方的更新那我们就可以返回一个对象或者数组，通过解构赋值的方式来实现同时对多个数据的缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [age, followUser] = useMemo(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> [<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear() - userInfo.birth, <span class="hljs-comment">// 根据生日计算年龄</span><br>    <span class="hljs-keyword">async</span> () =&gt; &#123; <span class="hljs-comment">// 关注用户</span><br>      <span class="hljs-keyword">await</span> request(<span class="hljs-string">&#x27;/follow&#x27;</span>, &#123; <span class="hljs-attr">uid</span>: userInfo.id &#125;);<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  ];<br>&#125;, [userInfo]);<br><br><span class="hljs-keyword">return</span> (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>name: &#123;userInfo.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>age: &#123;age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">followUser</span>=<span class="hljs-string">&#123;followUser&#125;/</span>&gt;</span></span><br><span class="xml">    &#123;</span><br><span class="xml">      useMemo(() =&gt; (</span><br><span class="xml">        // 如果 Card1 组件内部没有使用 React.memo 函数，那还可以通过这种方式在父组件减少子组件的渲染</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Card1</span> <span class="hljs-attr">followUser</span>=<span class="hljs-string">&#123;followUser&#125;/</span>&gt;</span></span><br><span class="xml">      ), [followUser])</span><br><span class="xml">    &#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br></code></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><code>useCallback</code> 与 <code>useMemo</code> 一个缓存的是函数，一个缓存的是函数的返回值。<br><code>useCallback</code> 是来优化子组件的，防止子组件的重复渲染。<code>useMemo</code> 可以优化当前组件也可以优化子组件，优化当前组件主要是通过 memoize 来将一些复杂的计算逻辑进行缓存。当然如果只是进行一些简单的计算也没必要使用 <code>useMemo</code>，这里可以考虑一些计算的性能消耗和比较依赖项的性能消耗来做一个权衡。</p><p>参考：<a href="https://juejin.cn/post/7104436526494253087">https://juejin.cn/post/7104436526494253087</a> 。</p><p>但是，关于是否使用这些，或许可以用一句话来总结：<br>如果没有性能瓶颈，那就建议不用，大部分项目你可能并不需要考虑以阻止 React 的渲染来提高性能 ———— 甚至可以说如果你不能保证收获比成本大的“多”，那就尽量不用。<br>其实这上面这句话也藏着性能优化的原则之一：不要过早优化。</p><h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p>参考：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useref">https://zh-hans.reactjs.org/docs/hooks-reference.html#useref</a> 。</p><h2 id="基础-6"><a href="#基础-6" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> refContainer = useRef(initialValue);<br></code></pre></td></tr></table></figure><p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 <code>ref</code> 对象在组件的整个生命周期内持续存在。</p><p>一个常见的用例便是命令式地访问子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> inputEl = useRef(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span><br>    inputEl.current.focus();<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputEl&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。</p><p>应当熟悉 <code>ref</code> 这一种访问 DOM 的主要方式。如果将 <code>ref</code> 对象以<code> &lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 <code>ref</code> 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p><p>然而，<code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。这是因为它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 <code>ref</code> 对象。</p><p>当 <code>ref</code> 对象内容发生变化时，<code>useRef</code> 并不会通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 <code>ref</code> 时运行某些代码，则需要使用回调 <code>ref</code> 来实现。</p><h1 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h1><p>参考：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle">https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle</a> 。</p><h2 id="基础-7"><a href="#基础-7" class="headerlink" title="基础"></a>基础</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">useImperativeHandle(ref, createHandle, [deps])<br></code></pre></td></tr></table></figure><p><code>useImperativeHandle</code> 可以在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 <code>ref</code> 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code> 一起使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> inputRef = useRef(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">const</span> onClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    (inputRef <span class="hljs-keyword">as</span> any).current.focus()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;inputRef---&#x27;</span>, inputRef)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>Father<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">SonWrapper</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/&gt;</span></span> <br>&#125;<br><br><span class="hljs-keyword">const</span> SonWrapper = forwardRef(Son);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span> (<span class="hljs-params">props: any, ref: any</span>) </span>&#123;<br><br>  <span class="hljs-keyword">const</span> mouseIn = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;useImperativeHandle---mouseIn&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> mouseOut = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;useImperativeHandle---mouseOut&#x27;</span>)<br>  &#125;<br><br>  useImperativeHandle(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;useImperativeHandle---focus&#x27;</span>)<br>    &#125;, <br>    mouseOut<br>  &#125;), [mouseOut]);<br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Son<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><p>参考：<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect">https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect</a> 。</p><h2 id="基础-8"><a href="#基础-8" class="headerlink" title="基础"></a>基础</h2><p>其函数签名与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 <code>effect</code>。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</p><p>尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p><p>注意，虽然 <code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的。但还是推荐先用 <code>useEffect</code>，当出现问题的时候再尝试使用 <code>useLayoutEffect</code>。</p>]]></content>
    
    
    <categories>
      
      <category>框架和类库</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>框架和类库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript知识</title>
    <link href="/2022/10/24/JavaScript%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/10/24/JavaScript%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="解析连接URL"><a href="#解析连接URL" class="headerlink" title="解析连接URL"></a>解析连接URL</h1><p>可以通过创建 a 标签，给 a 标签赋值 href 属性的方式，获取到协议、pathname、origin等location对象上的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> aEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);<br>aEle.href =  <span class="hljs-string">&#x27;https://www.baidu.com/s?tn=68018901_2_oem_dg&amp;ie=utf-8&amp;wd=china&#x27;</span> ;<br><br>aEle.protocol; <span class="hljs-comment">// &#x27;https:&#x27;</span><br>aEle.port; <span class="hljs-comment">// &#x27;&#x27;</span><br>aEle.pathname; <span class="hljs-comment">// &#x27;/s&#x27;</span><br>aEle.origin; <span class="hljs-comment">// &#x27;https://www.baidu.com&#x27;</span><br>aEle.host; <span class="hljs-comment">// &#x27;www.baidu.com&#x27;</span><br>aEle.hostname; <span class="hljs-comment">// &#x27;www.baidu.com&#x27;</span><br>aEle.search; <span class="hljs-comment">// &#x27;?tn=68018901_2_oem_dg&amp;ie=utf-8&amp;wd=china&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="复制文字到剪切板"><a href="#复制文字到剪切板" class="headerlink" title="复制文字到剪切板"></a>复制文字到剪切板</h1><p>参考：<a href="https://www.zhangxinxu.com/wordpress/2021/10/js-copy-paste-clipboard/">https://www.zhangxinxu.com/wordpress/2021/10/js-copy-paste-clipboard/</a> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> execCommandCopy = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> textarea = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;textarea&#x27;</span>);<br>  <span class="hljs-built_in">document</span>.body.appendChild(textarea);<br>  <span class="hljs-comment">// 隐藏此输入框</span><br>  textarea.style.position = <span class="hljs-string">&#x27;fixed&#x27;</span>;<br>  textarea.style.clip = <span class="hljs-string">&#x27;rect(0 0 0 0)&#x27;</span>;<br>  textarea.style.top = <span class="hljs-string">&#x27;10px&#x27;</span>;<br>  <span class="hljs-comment">// 赋值</span><br>  textarea.value = text;<br>  <span class="hljs-comment">// 选中</span><br>  textarea.select();<br>  <span class="hljs-comment">// 复制</span><br>  <span class="hljs-built_in">document</span>.execCommand(<span class="hljs-string">&#x27;copy&#x27;</span>, <span class="hljs-literal">true</span>);<br>  <span class="hljs-comment">// 移除输入框</span><br>  <span class="hljs-built_in">document</span>.body.removeChild(textarea);<br>&#125;;<br><br><span class="hljs-comment">// clipboard api</span><br><span class="hljs-keyword">if</span> (navigator.clipboard) &#123;<br>  navigator.clipboard.writeText(text).then(<br>    <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res---&#x27;</span>, res)<br>    &#125;, <br>    <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err---&#x27;</span>, err)<br>      execCommandCopy();<br>    &#125;<br>  )<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  execCommandCopy();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h1><p>参考：<a href="https://juejin.cn/post/6946022649768181774">https://juejin.cn/post/6946022649768181774</a> 。<br>Demo：<a href="https://xuekeven.github.io/dome/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html">防抖和节流</a></p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖：事件被触发 n 秒之后再执行函数。</p><p>如果在这 n 秒内事件又被触发，则重新计时 n 秒，之后再执行函数。加入了防抖以后，频繁触发事件并不会一直执行函数，只有在指定间隔内没有再次触发事件，才会执行对应的函数。</p><h3 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h3><p>简单版：函数内部支持使用 this 和 event 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fun, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>,<br>    args = <span class="hljs-built_in">arguments</span>,<br>    timeout;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      fun.apply(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickDeBounce</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是简单版防抖函数&quot;</span>);<br>&#125;<br><span class="hljs-keyword">const</span> de = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;de&quot;</span>);<br>de.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, debounce(clickDeBounce, <span class="hljs-number">3000</span>), <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h3><p>升级版增加功能：</p><ul><li>支持立即执行</li><li>函数可能有返回值</li><li>支持取消功能</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait, immediate</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>,<br>    args = <span class="hljs-built_in">arguments</span>,<br>    timeout,<br>    result;<br><br>  <span class="hljs-keyword">let</span> debounced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      <span class="hljs-comment">// 如果已经执行过，不再执行</span><br>      <span class="hljs-keyword">let</span> callNow = !timeout;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        timeout = <span class="hljs-literal">null</span>;<br>      &#125;, wait);<br>      <span class="hljs-keyword">if</span> (callNow) result = func.apply(context, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        func.apply(context, args);<br>      &#125;, wait);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br><br>  debounced.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    timeout = <span class="hljs-literal">null</span>;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> debounced;<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">let</span> setUseAction = debounce(getUserAction, <span class="hljs-number">3000</span>, <span class="hljs-literal">true</span>);<br>node.onmousemove = setUseAction; <span class="hljs-comment">// 使用防抖</span><br>setUseAction.cancel(); <span class="hljs-comment">// 取消防抖</span><br></code></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>节流：事件在 n 秒内最多只能执行一次函数。</p><p>事件第一次被触发立即执行函数，想要再次执行函数，需等待 n 秒，之后再次触发事件才能再次执行函数。在 n 秒内连续多次触发事件，只有第一次执行函数。加入了节流以后，触频繁发事件并不会一直执行函数，一段时间内只执行一次函数。</p><h3 id="简单版-1"><a href="#简单版-1" class="headerlink" title="简单版"></a>简单版</h3><p>简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fun, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>,<br>    args = <span class="hljs-built_in">arguments</span>,<br>    previous = <span class="hljs-number">0</span>,<br>    now;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-keyword">if</span> (now - previous &gt; wait) &#123;<br>      fun.apply(context, args);<br>      previous = now;<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickThrottle</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是简单版节流函数&quot;</span>);<br>&#125;<br><span class="hljs-keyword">const</span> thro = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;thro&quot;</span>);<br>thro.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, throttle(clickThrottle, <span class="hljs-number">3000</span>), <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="升级版-1"><a href="#升级版-1" class="headerlink" title="升级版"></a>升级版</h3><p>升级版增加功能：支持取消节流；通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。（注意设置的时候不能同时将 leading 或 trailing 设置为 false。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait, options</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout, context, args, result;<br>  <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!options) options = &#123;&#125;;<br><br>  <span class="hljs-keyword">let</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    previous = options.leading === <span class="hljs-literal">false</span> ? <span class="hljs-number">0</span> : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>    timeout = <span class="hljs-literal">null</span>;<br>    func.apply(context, args);<br>    <span class="hljs-keyword">if</span> (!timeout) context = args = <span class="hljs-literal">null</span>;<br>  &#125;;<br><br>  <span class="hljs-keyword">let</span> throttled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>    <span class="hljs-keyword">if</span> (!previous &amp;&amp; options.leading === <span class="hljs-literal">false</span>) previous = now;<br>    <span class="hljs-keyword">let</span> remaining = wait - (now - previous);<br>    context = <span class="hljs-built_in">this</span>;<br>    args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; wait) &#123;<br>      <span class="hljs-keyword">if</span> (timeout) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        timeout = <span class="hljs-literal">null</span>;<br>      &#125;<br>      previous = now;<br>      func.apply(context, args);<br>      <span class="hljs-keyword">if</span> (!timeout) context = args = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="hljs-literal">false</span>) &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(later, remaining);<br>    &#125;<br>  &#125;;<br><br>  throttled.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    previous = <span class="hljs-number">0</span>;<br>    timeout = <span class="hljs-literal">null</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> throttled;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数防抖和函数节流都是防止某一时间频繁触发，稀释函数的执行频率，但是原理不一样。</p><ul><li>防抖 debounce 结合应用场景<ul><li>search 搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li><li>window 触发 resize 时，不断的调整浏览器窗口大小会不断触发事件，用防抖来让只触发一次。</li></ul></li><li>节流 throttle 结合应用场景<ul><li>鼠标不断点击触发，mousedown（单位时间内只触发一次）。</li><li>监听滚动事件，比如是否滑到底部自动加载更多，用节流来判断。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>知识技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步JavaScript</title>
    <link href="/2022/08/24/%E5%BC%82%E6%AD%A5JavaScript/"/>
    <url>/2022/08/24/%E5%BC%82%E6%AD%A5JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>城市生活</title>
    <link href="/2022/02/15/%E5%9F%8E%E5%B8%82%E6%AF%94%E8%BE%83/"/>
    <url>/2022/02/15/%E5%9F%8E%E5%B8%82%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<p>比较城市：<strong>北京</strong>、天津、上海、<strong>成都</strong>、<strong>杭州</strong>、苏州、广州。<br>比较维度：<strong>城市地位</strong>、<strong>城市气候</strong>、<strong>幸福感排名</strong>、<strong>司法文明指数排名</strong>、<strong>教育水平</strong>、<strong>医疗水平</strong>、<strong>户籍迁入政策</strong>、<strong>购房资格</strong>、<strong>公积金提取</strong>等。</p><h1 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h1><p>参考：</p><ul><li><a href="https://baike.baidu.com/item/%E5%8C%97%E4%BA%AC/128981">https://baike.baidu.com/item/%E5%8C%97%E4%BA%AC/128981</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8C%97%E4%BA%AC%E5%B8%82">https://zh.wikipedia.org/wiki/%E5%8C%97%E4%BA%AC%E5%B8%82</a></li></ul><h2 id="城市地位"><a href="#城市地位" class="headerlink" title="城市地位"></a>城市地位</h2><ul><li>中国首都、直辖市、<a href="https://baike.baidu.com/item/%E5%9B%BD%E5%AE%B6%E4%B8%AD%E5%BF%83%E5%9F%8E%E5%B8%82/842500">国家中心城市</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="国家中心城市：北京、天津、上海、广州、重庆、成都、武汉、郑州、西安">[1]</span></a></sup>、<a href="https://baike.baidu.com/item/%E8%B6%85%E5%A4%A7%E5%9F%8E%E5%B8%82/413865">超大城市</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="超大城市：北京、天津、上海、广州、重庆、成都、深圳">[2]</span></a></sup></li><li>中国政治中心、文化中心、国际交往中心、科技创新中心</li><li><a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E4%B8%80%E7%BA%BF%E5%9F%8E%E5%B8%82/4722524#3">世界一线城市</a>（GaWC 中国城市排名 Alpha+）</li></ul><h2 id="城市气候"><a href="#城市气候" class="headerlink" title="城市气候"></a>城市气候</h2><p>温带季风气候（夏季高温多雨，冬季寒冷干燥）</p><h2 id="幸福感排名"><a href="#幸福感排名" class="headerlink" title="幸福感排名"></a>幸福感排名</h2><p>暂无。</p><h2 id="司法文明指数排名"><a href="#司法文明指数排名" class="headerlink" title="司法文明指数排名"></a>司法文明指数排名</h2><p>2019 北京市排名：11<br>2018 北京市排名：7<br>2017 北京市排名：26<br>更多详情：<a href="https://zhuanlan.zhihu.com/p/409173066">https://zhuanlan.zhihu.com/p/409173066</a></p><h2 id="教育水平"><a href="#教育水平" class="headerlink" title="教育水平"></a>教育水平</h2><p>Top1</p><h2 id="医疗水平"><a href="#医疗水平" class="headerlink" title="医疗水平"></a>医疗水平</h2><p>Top1</p><h2 id="户籍迁入政策"><a href="#户籍迁入政策" class="headerlink" title="户籍迁入政策"></a>户籍迁入政策</h2><p>暂无。</p><h2 id="购房资格"><a href="#购房资格" class="headerlink" title="购房资格"></a>购房资格</h2><p>暂无。</p><h2 id="公积金提取"><a href="#公积金提取" class="headerlink" title="公积金提取"></a>公积金提取</h2><p>租房每月可提一次，每次 1500 元。<br>更多详情：<a href="http://gjj.beijing.gov.cn/web/zwfw5/386727/386730/386732/index.html">http://gjj.beijing.gov.cn/web/zwfw5/386727/386730/386732/index.html</a></p><h1 id="天津"><a href="#天津" class="headerlink" title="天津"></a>天津</h1><h1 id="上海"><a href="#上海" class="headerlink" title="上海"></a>上海</h1><h1 id="成都"><a href="#成都" class="headerlink" title="成都"></a>成都</h1><p>参考：</p><ul><li><a href="https://baike.baidu.com/item/%E5%8C%97%E4%BA%AC/128981">https://baike.baidu.com/item/%E5%8C%97%E4%BA%AC/128981</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%88%90%E9%83%BD%E5%B8%82">https://zh.wikipedia.org/wiki/%E6%88%90%E9%83%BD%E5%B8%82</a></li></ul><h2 id="城市地位-1"><a href="#城市地位-1" class="headerlink" title="城市地位"></a>城市地位</h2><ul><li>四川省辖地级市、省会、副省级市、<a href="https://baike.baidu.com/item/%E5%9B%BD%E5%AE%B6%E4%B8%AD%E5%BF%83%E5%9F%8E%E5%B8%82/842500">国家中心城市</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="国家中心城市：北京、天津、上海、广州、重庆、成都、武汉、郑州、西安">[1]</span></a></sup>、<a href="https://baike.baidu.com/item/%E8%B6%85%E5%A4%A7%E5%9F%8E%E5%B8%82/413865">超大城市</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="超大城市：北京、天津、上海、广州、重庆、成都、深圳">[2]</span></a></sup></li><li>成渝地区双城经济圈核心城市</li><li><a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E4%B8%80%E7%BA%BF%E5%9F%8E%E5%B8%82/4722524#3">世界二线城市</a>（GaWC 中国城市排名 Beta+）</li></ul><h2 id="城市气候-1"><a href="#城市气候-1" class="headerlink" title="城市气候"></a>城市气候</h2><p>亚热带季风气候（夏季高温多雨，冬季温暖湿润）</p><h2 id="幸福感排名-1"><a href="#幸福感排名-1" class="headerlink" title="幸福感排名"></a>幸福感排名</h2><ul><li><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E6%9C%80%E5%85%B7%E5%B9%B8%E7%A6%8F%E6%84%9F%E5%9F%8E%E5%B8%82/23186310#viewPageContent">中国最具幸福感城市（新华社瞭望东方周刊、瞭望智库共同主办）</a></li></ul><p>2021 年 12 月 30 日，“2021 中国最具幸福感城市”榜单在北京揭晓，成都获得第一名。<br>至此，成都已连续 13 年荣膺“中国最具幸福感城市”冠军。</p><p>“2021 中国最具幸福感城市”的十大省会及计划单列市是：<br>成都、杭州、宁波、长沙、武汉、南京、青岛、贵阳、西宁、哈尔滨。<br>“2020 中国最具幸福感城市”的十大省会及计划单列市是：<br>成都、杭州、宁波、广州、长沙、南京、郑州、西宁、青岛、西安。<br>“2019 中国最具幸福感城市”的十大省会及计划单列市是：<br>成都、杭州、宁波、西安、广州、长沙、温州、台州、铜川、徐州。</p><h2 id="司法文明指数排名-1"><a href="#司法文明指数排名-1" class="headerlink" title="司法文明指数排名"></a>司法文明指数排名</h2><p>2019 四川省排名：3<br>2018 四川省排名：5<br>2017 四川省排名：25<br>更多详情：<a href="https://zhuanlan.zhihu.com/p/409173066">https://zhuanlan.zhihu.com/p/409173066</a></p><h2 id="教育水平-1"><a href="#教育水平-1" class="headerlink" title="教育水平"></a>教育水平</h2><h2 id="医疗水平-1"><a href="#医疗水平-1" class="headerlink" title="医疗水平"></a>医疗水平</h2><h2 id="户籍迁入政策-1"><a href="#户籍迁入政策-1" class="headerlink" title="户籍迁入政策"></a>户籍迁入政策</h2><p>45 周岁以下的全日制普通大学本科及以上学历毕业生（含经教育部留学服务中心认证的国（境）外取得同等学历人员），按本人或直系亲属拥有的合法稳定住所、单位集体户、人才流动服务中心集体户的顺序申请本人入户。<br>更多详情：<a href="http://gk.chengdu.gov.cn/govInfo/detail.action?id=135066&amp;tn=6">http://gk.chengdu.gov.cn/govInfo/detail.action?id=135066&amp;tn=6</a></p><h2 id="购房资格-1"><a href="#购房资格-1" class="headerlink" title="购房资格"></a>购房资格</h2><p>满足以下条件其中之一：<br>① 户口：两年及以上户口<br>② 社保：两年大成都范围内稳定就业且连续缴纳社保<br>③ 户口+社保：落户不满两年，大成都范围内社保一年及以上（落户+社保 1 年）<br>更多详情：<a href="https://zhuanlan.zhihu.com/p/341571210">https://zhuanlan.zhihu.com/p/341571210</a></p><h2 id="公积金提取-1"><a href="#公积金提取-1" class="headerlink" title="公积金提取"></a>公积金提取</h2><p>租房每月可提一次，具体金额看租房合同租金。<br>更多详情：<a href="http://cdzfgjj.chengdu.gov.cn/cdgjj/c1156359/news_dfwj.shtml">http://cdzfgjj.chengdu.gov.cn/cdgjj/c1156359/news_dfwj.shtml</a></p><h1 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h1><p>参考：</p><ul><li><a href="https://baike.baidu.com/item/%E6%9D%AD%E5%B7%9E/147639">https://baike.baidu.com/item/%E6%9D%AD%E5%B7%9E/147639</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E6%9D%AD%E5%B7%9E%E5%B8%82">https://zh.wikipedia.org/zh-hans/%E6%9D%AD%E5%B7%9E%E5%B8%82</a></li></ul><h2 id="城市地位-2"><a href="#城市地位-2" class="headerlink" title="城市地位"></a>城市地位</h2><ul><li>浙江省辖地级市、省会、副省级市、<a href="https://baike.baidu.com/item/%E7%89%B9%E5%A4%A7%E5%9F%8E%E5%B8%82/1491">特大城市</a><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="特大城市：武汉、东莞、西安、杭州、佛山、南京、沈阳、青岛、济南、长沙、哈尔滨、郑州、昆明、大连">[3]</span></a></sup></li><li>杭州都市圈核心城市</li><li><a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E4%B8%80%E7%BA%BF%E5%9F%8E%E5%B8%82/4722524#3">世界二线城市</a>（GaWC 中国城市排名 Beta）</li></ul><h2 id="城市气候-2"><a href="#城市气候-2" class="headerlink" title="城市气候"></a>城市气候</h2><p>亚热带湿润季风气候，亦有海洋性气候的部分特征（夏季高温多雨，冬季温暖湿润）</p><h2 id="幸福感排名-2"><a href="#幸福感排名-2" class="headerlink" title="幸福感排名"></a>幸福感排名</h2><ul><li><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E6%9C%80%E5%85%B7%E5%B9%B8%E7%A6%8F%E6%84%9F%E5%9F%8E%E5%B8%82/23186310#viewPageContent">中国最具幸福感城市（新华社瞭望东方周刊、瞭望智库共同主办）</a></li></ul><p>2021 年 12 月 30 日，“2021 中国最具幸福感城市”榜单在北京揭晓，杭州获得第二名。</p><p>“2021 中国最具幸福感城市”的十大省会及计划单列市是：<br>成都、杭州、宁波、长沙、武汉、南京、青岛、贵阳、西宁、哈尔滨。<br>“2020 中国最具幸福感城市”的十大省会及计划单列市是：<br>成都、杭州、宁波、广州、长沙、南京、郑州、西宁、青岛、西安。<br>“2019 中国最具幸福感城市”的十大省会及计划单列市是：<br>成都、杭州、宁波、西安、广州、长沙、温州、台州、铜川、徐州。</p><h2 id="司法文明指数排名-2"><a href="#司法文明指数排名-2" class="headerlink" title="司法文明指数排名"></a>司法文明指数排名</h2><p>2019 浙江省排名：1<br>2018 浙江省排名：18<br>2017 浙江省排名：2<br>更多详情：<a href="https://zhuanlan.zhihu.com/p/409173066">https://zhuanlan.zhihu.com/p/409173066</a></p><h2 id="教育水平-2"><a href="#教育水平-2" class="headerlink" title="教育水平"></a>教育水平</h2><h2 id="医疗水平-2"><a href="#医疗水平-2" class="headerlink" title="医疗水平"></a>医疗水平</h2><h2 id="户籍迁入政策-2"><a href="#户籍迁入政策-2" class="headerlink" title="户籍迁入政策"></a>户籍迁入政策</h2><p>具有全日制普通高校本科以上学历者（本科 45 周岁以下；硕士 50 周岁以下），在杭州市区落实工作单位并由用人单位正常缴纳社保的可以落户杭州市区。<br>更多详情：<a href="https://mp.weixin.qq.com/s/g0c3XbVmYba7EkcTIeuFZw">https://mp.weixin.qq.com/s/g0c3XbVmYba7EkcTIeuFZw</a></p><h2 id="购房资格-2"><a href="#购房资格-2" class="headerlink" title="购房资格"></a>购房资格</h2><p>落户杭州市未满 5 年的户籍家庭，在购房之日前 2 年起已在本市限购范围内连续缴纳城镇社保满 24 个月，方可在本市限购范围内限购 1 套住房。<br>更多详情：<a href="https://zhuanlan.zhihu.com/p/142977813">https://zhuanlan.zhihu.com/p/142977813</a></p><h2 id="公积金提取-2"><a href="#公积金提取-2" class="headerlink" title="公积金提取"></a>公积金提取</h2><p>租房每年提取一次，提取限额不超过 12 个月，1200 元/月。<br>更多详情：<a href="https://mp.weixin.qq.com/s/bMAlymjVYhKpAYzY9CGdCA">https://mp.weixin.qq.com/s/bMAlymjVYhKpAYzY9CGdCA</a></p><h1 id="苏州"><a href="#苏州" class="headerlink" title="苏州"></a>苏州</h1><h1 id="广州"><a href="#广州" class="headerlink" title="广州"></a>广州</h1><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>国家中心城市：北京、天津、上海、广州、重庆、成都、武汉、郑州、西安<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>超大城市：北京、天津、上海、广州、重庆、成都、深圳<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>特大城市：武汉、东莞、西安、杭州、佛山、南京、沈阳、青岛、济南、长沙、哈尔滨、郑州、昆明、大连<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript词法结构</title>
    <link href="/2022/01/25/JavaScript%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/25/JavaScript%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://book.douban.com/subject/35396470/">《JavaScript权威指南（原书第 7 版）》</a>。</p><p>编程语言的词法结构是一套基本规则，规定了如何使用这门语言编写程序。<br>词法结构是一门语言最低级的语法，规定了变量如何命名、注释的界定符，以及如何分割程序的语句等等。</p><h1 id="JavaScript程序的文本"><a href="#JavaScript程序的文本" class="headerlink" title="JavaScript程序的文本"></a>JavaScript程序的文本</h1><p>JavaScript区分大小写。这意味着它的关键字、变量、函数名和其他标识符必须始终保持一致的大小写形式。例如，<code>online</code>、<code>Online</code>、<code>OnLine</code>、<code>ONLINE</code> 是 4 个完全不同的变量名。</p><p>JavaScript忽略程序记号之间的<strong>空格</strong>。很大程度上也忽略<strong>换行符</strong>。因为可以在程序中随意使用空格和换行符，所以可以按照便于阅读理解的方式对程序进行格式化和缩进。</p><p>除了<strong>常规空格</strong>（\u0020），JavaScript也将<strong>制表符</strong>、<strong>各种 ASCII 控制符</strong>和 <strong>Unicode 间格</strong>识别为空格。JavaScript将<strong>换行符</strong>、<strong>回车符</strong>和<strong>回车 / 换行序列</strong>识别为行终止符。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>JavaScript支持两种注释，<strong>单行注释</strong>和<strong>多行注释</strong>。</p><ul><li>单行注释是以 <code>//</code> 开头到一行末尾的内容。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单行注释</span><br></code></pre></td></tr></table></figure><ul><li>多行注释位于 <code>/*</code> 和 <code>*/</code> 之间，可以跨行，但是不能嵌套。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  多行注释</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/* 多行注释 */</span> <span class="hljs-comment">// 另一个注释（单行注释）</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 多行注释（美观）</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>字面量是一种直接出现在程序中的<strong>数据值</strong>。如有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">12</span>;              <span class="hljs-comment">// 数值12</span><br><span class="hljs-number">1.2</span>;             <span class="hljs-comment">// 数值1.2</span><br><span class="hljs-string">&quot;hi&quot;</span>;          <span class="hljs-comment">// 字符串&quot;hi&quot;</span><br><span class="hljs-string">&quot;hello world&quot;</span>; <span class="hljs-comment">// 字符串&quot;hello world&quot;</span><br><span class="hljs-literal">true</span>;            <span class="hljs-comment">// 布尔值</span><br><span class="hljs-literal">null</span>;            <span class="hljs-comment">// 空对象</span><br></code></pre></td></tr></table></figure><h1 id="标识符和保留字"><a href="#标识符和保留字" class="headerlink" title="标识符和保留字"></a>标识符和保留字</h1><p>简单来说，标识符就是一个名字。在JavaScript中，标识符用于在JavaScript代码中命名<br><strong>常量</strong>、<strong>变量</strong>、<strong>属性</strong>、<strong>函数</strong>、<strong>类</strong>，以及为某些循环提供<strong>标记</strong>。</p><p>JavaScript标识符必须以<strong>字母</strong>、<strong>下划线</strong>（_）、<strong>美元符号</strong>（$）开头，<br>后续的字符可以是<strong>数字</strong>、<strong>字母</strong>、<strong>下划线</strong>、<strong>美元符号</strong>。（数字不能作首个字符，以便区分标识符和数值）</p><p>与其他语言一样，JavaScript为语言自身使用保留了某些标识符。这些“保留字”不能作为常规标识符使用。</p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>JavaScript程序是使用<strong>Unicode字符集</strong>编写的，因此在<strong>字符串</strong>和<strong>注释</strong>中可以使用<strong>任意Unicode字符</strong>。考虑到可移植性和易于编辑，建议在标识符中只使用<strong>ASCII字母</strong>和<strong>数字</strong>。</p><p>但这只是一个编程惯例，语言本身支持在<strong>标识符</strong>中使用<strong>Unicode字母</strong>、<strong>数字</strong>、<strong>象形文字</strong>（但是这不支持表情符号）。这意味着常量或变量的名字中可以包含数字符号或非英语文字。</p><h2 id="Unicode转义序列"><a href="#Unicode转义序列" class="headerlink" title="Unicode转义序列"></a>Unicode转义序列</h2><h2 id="Unicode归一化"><a href="#Unicode归一化" class="headerlink" title="Unicode归一化"></a>Unicode归一化</h2><h1 id="可选的分号"><a href="#可选的分号" class="headerlink" title="可选的分号"></a>可选的分号</h1><p>JavaScript使用<strong>分号</strong>（;）分隔语句，这对于保持代码清晰很重要：如果没有分隔符，一条语句的结尾可能是另一条语句的开头，反之亦然。</p><p>在JavaScript中，如果两条语句分别写在两行，通常可以省略它们之间的分号。在程序末尾，如果接下来的记号是<strong>右花括号</strong>（}），那么也可以省略分号。</p><ul><li>一种风格是，使用分号明确标识语句结束，即使这些分号并非必需。</li><li>另一种风格是，尽可能地省略分号，只在少数必要情况下采用。</li></ul><p>无论哪种风格，都需要了解一些关于JavaScript中可选分号的细节。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 第一个分号可以省略</span><br>b = <span class="hljs-number">4</span>;<br><br>a = <span class="hljs-number">3</span>; b = <span class="hljs-number">4</span>; <span class="hljs-comment">// 分号不能省略</span><br></code></pre></td></tr></table></figure><p>JavaScript并非任何时候都把换行符当作分号，而只是在不隐式添加分号就无法解析代码的情况下才这么做。更准确地讲，只在下一个非空格字符无法被解释为当前语句的一部分时才把换行符当作分号。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a<br>a <br>= <br><span class="hljs-number">3</span><br><span class="hljs-built_in">console</span>.log(a)<br><span class="hljs-comment">// JavaScript将上方代码解释为：</span><br><span class="hljs-keyword">let</span> a; a = <span class="hljs-number">3</span>; <span class="hljs-built_in">console</span>.log(a); <br></code></pre></td></tr></table></figure><p>但是，这些语句终止规则会导致某些意外情形。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> y = x + f<br>(a + b).toString()<br><span class="hljs-comment">// 上面代码看起来是两条位于两行的语句，但是第二行的圆括号可以被解释为第一行f的函数调用。</span><br><span class="hljs-comment">// 所以，JavaScript将上方代码解释为：</span><br><span class="hljs-keyword">let</span> y = x + f(a + b).toString(); <br></code></pre></td></tr></table></figure><p>而这很有可能不是代码作者的意图。为了保证代码能按代码作者的意图指向，必须在相应的地方添加分号。</p><p>通常，如果语句以 <strong>(<strong>、</strong>[<strong>、</strong>/<strong>、</strong>+<strong>、</strong>-</strong> 开头，就有可能被解释为之前语句的一部分。实践中，以 <strong>/<strong>、</strong>+<strong>、</strong>-</strong> 开头的语句极少，但以 <strong>(<strong>、</strong>[</strong> 开头的语句则并不鲜见。可以在所以这些语句前面都防御性地添加一个分号，这样即使它前面的语句被修改，删掉了之前末尾的分号，也不会影响当前语句。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>                                  <span class="hljs-comment">// 这里省略分号</span><br>;[x, x + <span class="hljs-number">1</span>, x + <span class="hljs-number">2</span>].forEach(<span class="hljs-built_in">console</span>.log()); <span class="hljs-comment">// 防御：保证这条语句独立</span><br></code></pre></td></tr></table></figure><p>JavaScript在不能把第二行解析为第一行的连续部分时，对换行符的解释有三种例外情况。</p><p>第一种情况涉及 <code>return</code>、<code>throw</code>、<code>yield</code>、<code>break</code>、<code>continue</code> 语句。这些语句通常独立存在，但是有时候后面也会跟一个标识符或表达式。如果这几个单词后面（任何其他标记前面）有换行符，JavaScript就会把这个换行符解释为分号。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">return</span><br><span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// JavaScript假设你的意图是：</span><br><span class="hljs-keyword">return</span>; <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 但你的意图可能是：</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br></code></pre></td></tr></table></figure><p>这意味着，一定不能在 <code>return</code>、<code>break</code> 等以上关键字和它们后面的表达式之间添加换行符。那如果加入了换行符，那代码出错后的调试会非常麻烦，因为错误不明显。</p><p>第二种情况涉及 <code>++</code> 和 <code>--</code> 操作。这些操作符既可以放在表达式前面，也可以放在表达式后面，如果想把这两个操作符作为后置操作符，那它们必须与自己操作的表达式位于同一行。</p><p>第三种情况涉及箭头函数，箭头 <code>=&gt;</code> 必须跟参数列表在同一行。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>JavaScript权威指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript内存泄漏</title>
    <link href="/2021/11/09/JavaScript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2021/11/09/JavaScript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://juejin.cn/post/6947841638118998029">https://juejin.cn/post/6947841638118998029</a> 。</p><p>内存泄漏就是指由于疏忽或者程序的某些错误造成未能释放已经不再使用的内存的情况。简单来讲就是假设某个变量占用 100M 的内存，而你又用不到这个变量，但是这个变量没有被手动的回收或自动回收，即仍然占用 100M 的内存空间，这就是一种内存的浪费，即内存泄漏。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript类数组对象</title>
    <link href="/2021/11/08/JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/11/08/JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>类数组对象（伪数组对象）是指可以通过索引属性访问元素并且拥有一个 <code>length</code> 属性的对象。<br>注意，区分可迭代对象。可迭代对象是指实现了<code>[Symbol.iterator]</code>方法属性的对象。<br>可迭代对象和类数组对象并非是相互排斥的。比如，字符串既是可迭代对象又是类数组对象。</p><p>类数组对象有<code>arguments</code>对象、<code>NodeList</code>对象、<code>HTMLCollection</code>对象、<code>DOMTokenList</code>对象、<code>typedArray</code>对象等。</p><h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><h1 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h1><p>文档的每个节点都有一个 childNodes 属性，指向其所有子节点，其中包含一个 NodeList 的实例。NodeList 是一个类数组对象，可以使用中括号和 item() 方法访问它的值，而且它也有 length 属性。</p><h1 id="HTMLCollection"><a href="#HTMLCollection" class="headerlink" title="HTMLCollection"></a>HTMLCollection</h1><p>getElementsByTagName() 方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的 NodeList。在 HTML 文档中，该方法返回 HTMLCollection 对象。可以使用中括号或 item() 方法从 HTMLCollection 取得特定的元素。而取得元素的数量同样可以通过 length 属性得知。HTMLCollection 对象还有一个额外的方法 namedItem()，可通过标签的 name 属性取得某一项的引用。这样，就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了便利。对于 name 属性的元素，还可以直接使用中括号来获取。对 HTMLCollection 对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台，数值索引会调用 item()，字符串索引会调用 namedItem()。</p><h1 id="DOMTokenList"><a href="#DOMTokenList" class="headerlink" title="DOMTokenList"></a>DOMTokenList</h1><p>classList 属性返回是一个新的集合类型 DOMTokenList 的实例。与其他 DOM 集合类型一样，DOMTokenList 也有 length 属性表示自己包含多少项，也可以通过 item() 或中括号取得个别的元素。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之Function方法属性</title>
    <link href="/2021/11/06/JavaScript%E4%B9%8BFunction%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/11/06/JavaScript%E4%B9%8BFunction%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function</a> 。</p><h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.length<br><span class="hljs-built_in">Function</span>.name<br></code></pre></td></tr></table></figure><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>length 属性指明函数的形参个数。</p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>name 属性返回函数的名称。</p><h1 id="函数实例方法"><a href="#函数实例方法" class="headerlink" title="函数实例方法"></a>函数实例方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.apply()<br><span class="hljs-built_in">Function</span>.prototype.call()<br><span class="hljs-built_in">Function</span>.prototype.bind()<br><span class="hljs-built_in">Function</span>.prototype.toString()<br></code></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>apply() 方法用一个指定的 this 值和以及以一个数组（或类数组对象）的形式提供的参数用一个函数。</p><p>接收两个参数：</p><ul><li>thisArg（必需）：执行函数时 this 绑定对象的值。</li><li>argsArray（可选）：一个数组或者类数组对象，其中的元素将作为单独的参数传给函数。</li></ul><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>call() 方法用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</p><p>接收参数：</p><ul><li>thisArg（可选）：执行函数时 this 绑定对象的值。</li><li>arg1, arg2, …（可选）：指定的参数列表。</li></ul><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，其余参数将作为新函数的参数，供调用时使用，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。</p><p>接收参数：</p><ul><li>thisArg（可选）：调用绑定函数时作为 this 参数传递给目标函数的值。 </li><li>arg1, arg2, …（可选）：当目标函数被调用时，被预置入绑定函数的参数列表中的参数。</li></ul><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>toString() 方法用于返回一个表示当前函数源代码的字符串。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Function</tag>
      
      <tag>方法属性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的组件库</title>
    <link href="/2021/11/01/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <url>/2021/11/01/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><ul><li><a href="https://bttn.surge.sh/">bttn.css</a></li><li><a href="https://zhuanlan.zhihu.com/p/25597059">创建漂亮的 CSS 按钮的 10 个代码片段</a></li></ul><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><ul><li><a href="https://arco.design/react/docs/start">Arco Design</a>：react &gt;= 16.8 &amp; react-dom &gt;= 16.8</li></ul><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><ul><li><a href="https://vueuse.org/guide">VueUse</a>：Vue2 &amp; Vue3</li></ul><ul><li><p><a href="https://next.antdv.com/components/overview-cn">Ant-Design-Vue</a>：Vue2 &amp; Vue3</p></li><li><p><a href="https://vuetifyjs.com/zh-Hans/getting-started/installation">Vuetify</a>：Vue2</p></li><li><p><a href="https://at-ui.github.io/at-ui/#/zh/docs/introduction">AT-UI</a>：Vue2 &amp; 桌面端</p></li><li><p><a href="https://www.iviewui.com/docs/introduce">View UI</a>：Vue2 &amp; 桌面端</p></li><li><p><a href="https://element.eleme.cn/#/zh-CN/component/installation">Element</a>：Vue2 &amp; 桌面端</p></li><li><p><a href="https://mint-ui.github.io/docs/#/zh-cn2">Mint UI</a>：Vue2 &amp; 移动端</p></li><li><p><a href="https://didi.github.io/cube-ui/#/zh-CN/docs/introduction">Cube-UI</a>：：Vue2 &amp; 移动端</p></li><li><p><a href="https://vuetifyjs.com/zh-Hans/introduction/roadmap/#v30titan">Vuetify v3</a>：Vue3</p></li><li><p><a href="https://arco.design/vue/docs/start">Arco Design</a>：Vue &gt;= 3.2.0</p></li><li><p><a href="https://element-plus.gitee.io/zh-CN/guide/installation.html">Element Plus</a>：Vue3 &amp; 桌面端</p></li><li><p><a href="https://varlet.gitee.io/varlet-ui/#/zh-CN/home">Varlet</a>：Vue3 &amp; 移动端</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架和类库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架和类库</tag>
      
      <tag>Vue</tag>
      
      <tag>组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript网络请求</title>
    <link href="/2021/10/25/JavaScript%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <url>/2021/10/25/JavaScript%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p>更多：<a href="http://axios-js.com/zh-cn/docs">http://axios-js.com/zh-cn/docs</a> 。</p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>Ajax 即“Asynchronous Javascript And XML”，是指一种创建交互式网页应用的网页开发技术。这是一种用于创建快速动态网页的技术。它可令开发者只向服务器获取数据（而不是图片、HTML 文档等资源），互联网资源的传输变得前所未有的轻量级和纯粹，这激发了广大开发者的创造力，使各式各样功能强大的网络站点和互联网应用如雨后春笋一般冒出，不断带给人惊喜。</p><p>更多：<br><a href="https://juejin.cn/post/6844903618764603399">https://juejin.cn/post/6844903618764603399</a> 。<br><a href="https://juejin.cn/post/6844903469896171533">https://juejin.cn/post/6844903469896171533</a> 。</p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>Web Socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在 JavaScript中创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接。服务器响应后，连接使用 HTTP的 Upgrade 头部从 HTTP 协议切换到 Web Socket 协议。这意味着 Web Socket 不能通过标准 HTTP 服务器实现，而必须使用支持该协议的专有服务器。</p><p>因为 Web Socket 使用了自定义协议，所以 URL方案（scheme）稍有变化：不能再使用 http://或 https://，而要使用 ws://和 wss://。前者是不安全的连接，后者是安全连接。在指定 Web Socket URL 时，必须包含 URL 方案，因为将来有可能再支持其他方案。</p><p>使用自定义协议而非 HTTP 协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对 HTTP 造成任何负担。使用更小的数据包让 Web Socket 非常适合带宽和延迟问题比较明显的移动应用。但使用自定义协议的缺点是，定义协议的时间比定义 JavaScript API 要长。Web Socket 得到了所有主流浏览器支持。</p><p>更多：<br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a> 。<br><a href="https://juejin.cn/post/6844903544978407431">https://juejin.cn/post/6844903544978407431</a> 。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2生命周期</title>
    <link href="/2021/10/24/Vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2021/10/24/Vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://www.nowcoder.com/discuss/693647?channel=-1&amp;source_id=profile_follow_post_nctrack">https://www.nowcoder.com/discuss/693647?channel=-1&amp;source_id=profile_follow_post_nctrack</a></li><li><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">https://cn.vuejs.org/v2/api/#选项-生命周期钩子</a></li><li><a href="https://juejin.cn/post/6844904113914773518">https://juejin.cn/post/6844904113914773518</a></li><li><a href="https://juejin.cn/post/6844903780736040973">https://juejin.cn/post/6844903780736040973</a></li><li><a href="https://juejin.cn/post/6844904114879463437">https://juejin.cn/post/6844904114879463437</a></li></ul><h1 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h1><p><img src="/images/VueLifeCycle.png" alt="VueLifeCycle"></p><p><img src="/images/Vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%88%86%E6%9E%90.png" alt="Vue2生命周期分析"></p><h1 id="文字详解"><a href="#文字详解" class="headerlink" title="文字详解"></a>文字详解</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>（activated、deactivated 是组件使用 keep-alive 时独有的钩子）</p><ul><li>beforeCreate（初始化界面前）</li><li>created（初始化界面后）</li><li>beforeMount（渲染 DOM 前）</li><li>mounted（渲染 DOM 后）</li><li>beforeUpdate（更新数据前）</li><li>updated（更新数据后）</li><li>activated（组件激活时）</li><li>deactivated（组件失活时）</li><li>beforeDestroy（卸载组件前）</li><li>destroyed（卸载组件后）</li><li>errorCaptured（组件出错时）</li></ul><h2 id="简洁版"><a href="#简洁版" class="headerlink" title="简洁版"></a>简洁版</h2><table><thead><tr><th align="center">生命周期</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center">组件实例仅被初始化，组件数据未生效</td></tr><tr><td align="center">created</td><td align="center">组件实例已创建，数据已绑定生效，但真实DOM还没有生成，$el不可用</td></tr><tr><td align="center">beforeMount</td><td align="center">虚拟DOM已创建完成，在数据渲染前最后一次更改数据</td></tr><tr><td align="center">mounted</td><td align="center">el被新创建的vm.$el替换，真实DOM挂载完成，页面、数据渲染完成</td></tr><tr><td align="center">beforeUpdate</td><td align="center">组件数据更新之前，发生在虚拟DOM打补丁之前调用该钩子</td></tr><tr><td align="center">updated</td><td align="center">组件数据更新之后调用该钩子</td></tr><tr><td align="center">activated</td><td align="center">keep-alive专属，组件激活时调用该钩子</td></tr><tr><td align="center">deactivated</td><td align="center">keep-alive专属，组件失活时调用该钩子</td></tr><tr><td align="center">beforeDestroy</td><td align="center">组件销毁前调用该钩子</td></tr><tr><td align="center">destroyed</td><td align="center">组件销毁后调用该钩子</td></tr></tbody></table><h2 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>在实例初始化后，进行数据侦听（data observer）和事件/侦听器（event/watcher）的配置之前同步调用。</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>在实例创建完成后被调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：<br>数据侦听（data observer）、计算属性（computed）、方法（methods）、事件/侦听器（event/watcher）的回调函数。然而，挂载阶段还没开始，且<code>$el</code>property目前尚不可用。</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>在挂载开始之前被调用：相关的<code>render</code>函数首次被调用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>实例被挂载后调用，这时<code>el</code>被新创建的<code>vm.$el</code>替换了。如果根实例挂载到了一个文档内的元素上，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p><p>注意<code>mounted</code>不会保证所有的子组件也都被挂载完成。如果希望等到整个视图都渲染完毕再执行某些操作，可以在<code>mounted</code>内部使用<code>vm.$nextTick</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">mounted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 仅在整个视图都被渲染之后才会运行的代码</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。 <strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。</strong></p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用，组件 DOM 已经更新，所以现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 computed 或 watcher 取而代之。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p><p>注意<code>updated</code>不会保证所有的子组件也都被重新渲染完毕。如果希望等到整个视图都渲染完毕，可以在<code>updated</code>内部使用<code>vm.$nextTick</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">updated: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 仅在整个视图都被渲染之后才会运行的代码</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><p>被 keep-alive 缓存的组件激活时调用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p><h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><p>被 keep-alive 缓存的组件失活时调用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><p>实例销毁之前调用。在这一步，实例仍然完全可用。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。 <strong>该钩子在服务器端渲染期间不被调用。</strong></p><h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h3><p>在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例、一个包含错误来源信息的字符串。此钩子可以返回<code>false</code>以阻止该错误继续向上传播。</p><h1 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h1><p>当父子组件嵌套时，父组件和子组件各拥有各自独立的钩子函数，这些父子组件的这些钩子是如何交融执行，且执行顺序又是怎样的呢？</p><h2 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h2><p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><h2 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h2><p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>]]></content>
    
    
    <categories>
      
      <category>框架和类库</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架和类库</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录认证</title>
    <link href="/2021/10/15/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"/>
    <url>/2021/10/15/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844904034181070861">https://juejin.cn/post/6844904034181070861</a> 。<br><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_Token-tutorial.html">http://www.ruanyifeng.com/blog/2018/07/json_web_Token-tutorial.html</a> 。<br><a href="https://juejin.cn/post/6844903556424826894">https://juejin.cn/post/6844903556424826894</a> 。<br><a href="https://juejin.cn/post/6845166891393089544">https://juejin.cn/post/6845166891393089544</a> 。</p><h1 id="认证（Authentication）"><a href="#认证（Authentication）" class="headerlink" title="认证（Authentication）"></a>认证（Authentication）</h1><p>通俗地讲就是验证当前用户的身份。互联网中的认证：</p><ul><li>用户名密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li></ul><h1 id="授权（Authorization）"><a href="#授权（Authorization）" class="headerlink" title="授权（Authorization）"></a>授权（Authorization）</h1><p>用户授予第三方应用访问该用户某些资源的权限。</p><ul><li>安装手机应用的时候，系统会询问是否允许授予权限（访问相册、地理位置等权限）</li><li>访问微信小程序时，当登录时，微信会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</li></ul><p>实现授权的方式有：Cookie、Session、Token、OAuth 。</p><h1 id="凭证（Credentials）"><a href="#凭证（Credentials）" class="headerlink" title="凭证（Credentials）"></a>凭证（Credentials）</h1><p>实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份。</p><p>在现实生活中，每个人都有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。</p><p>在互联网应用中，一般网站都会有两种模式：游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器就会给该用户使用的浏览器颁发一个令牌（Token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上该令牌，就可以使用游客模式下无法使用的功能。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个 HTTP 请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是否同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问），就必须主动的去维护一个状态，这个状态用于告知服务端前后的两个请求是否来自同一浏览器。而这个状态需要通过 Cookie 和 Session 去实现。</p><p>Cookie 存储在客户端： Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p><p>Cookie 是不可跨域的： 每个 Cookie 都绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session 是另一种记录服务器和客户端会话状态的机制。不管用户有没有登录，都会创建 Session。<br>Session 是基于 Cookie 实现的，Session 存储在服务器端，SessionId 会被存储到客户端的 Cookie 中。</p><p>Session 认证流程：</p><ul><li>用户首次请求服务器时，服务器会根据用户提交的相关信息，创建对应的 Session</li><li>服务器请求返回时将此 Session 的唯一标识信息 SessionId 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionId 信息后，会将此信息存入到 Cookie，同时 Cookie 记录此 SessionId 属于哪个域名</li><li>用户之后请求服务器时，请求会自动判断此域名下是否存在 Cookie 信息：若存在，自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionId，再根据 SessionId 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作</li></ul><p>根据以上流程可知， <strong>SessionId 是连接 Cookie 和 Session 的一道桥梁</strong> ，大部分系统也是根据此原理来验证用户登录状态。</p><h1 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h1><ul><li>安全性<br>Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li>存取值的类型不同<br>Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li>有效期不同<br>Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li>存储大小不同<br>单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><h2 id="Acesss-Token"><a href="#Acesss-Token" class="headerlink" title="Acesss Token"></a>Acesss Token</h2><p>Acesss Token 是访问资源接口（API）时所需要的资源凭证。<br>特点：服务端无状态化、可扩展性好、支持移动端设备、安全、支持跨程序调用。</p><p>Token 的简单组成：</p><ul><li>uid（用户唯一的身份标识）</li><li>time（当前时间的时间戳）</li><li>sign（签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li></ul><p>Token 的身份验证流程：</p><ul><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端</li><li>客户端收到 Token 以后，会把它存储起来（比如放在 Cookie 或者 localStorage）</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求中带着的 Token ，如果验证成功，就向客户端返回请求的数据</li></ul><p>每一次请求都需要携带 Token 并需要把 Token 放到 HTTP 的 Header 里。</p><p>基于 Token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 Token 数据。用解析 Token 的计算时间换取 Session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。</p><p>Token 完全由应用管理，所以它可以避开同源策略。</p><h2 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h2><p>Refresh Token 是专用于刷新 Acesss Token 的 Token。如果没有 Refresh Token，也可以刷新 Acesss Token，但每次刷新都要用户再输入登录用户名与密码，会很麻烦。有了 Refresh Token 可以减少这个麻烦，客户端直接用 Refresh Token 去更新 Acesss Token，无需用户进行额外的操作。</p><p>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Access Token，如果 Refresh Token 也失效了，用户就只能重新登录。</p><p>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</p><h2 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h2><p>参考：<a href="https://juejin.cn/post/6922782392390746125">https://juejin.cn/post/6922782392390746125</a> 。</p><h3 id="将-Token-存储于-localStorage-或-sessionStorage"><a href="#将-Token-存储于-localStorage-或-sessionStorage" class="headerlink" title="将 Token 存储于 localStorage 或 sessionStorage"></a>将 Token 存储于 localStorage 或 sessionStorage</h3><p>Web存储（localStorage &amp; sessionStorage）可以通过同一域商 Javascript 访问。这意味着任何在你的网站上的运行的 JavaScript 都可以访问 Web存储，所以容易受到 XSS 攻击。尤其是项目中用到了很多第三方 JavaScript 类库。</p><p>为了防止 XSS，一般的处理是避开和编码所有不可信的数据。但这并不能百分百防止 XSS。如我们使用托管在 CDN、其它一些公共 JavaScript 库，还有像 npm 这样的包管理器导入别人的代码到我们的应用程序中。</p><p>如果你使用的脚本中有一个被盗用了怎么办？恶意的 JavaScript 可以嵌入到页面上，并且 Web存储被盗用。这些类型的 XSS 攻击可以得到每个人的 Web存储来访问你的网站。</p><p>这也是为什么许多组织建议不要在 Web存储中存储任何有价值或信任任何 Web存储中的信息。 这包括会话标识符和令牌。作为一种存储机制，Web存储在传输过程中不强制执行任何安全标准。</p><h3 id="将-Token-存储于-Cookie"><a href="#将-Token-存储于-Cookie" class="headerlink" title="将 Token 存储于 Cookie"></a>将 Token 存储于 Cookie</h3><p>优点：可以制定 httponly 来防止被 JavaScript 读取；也可以制定 secure 来保证 Token 只在 HTTPS 下传输。<br>缺点：不符合 Restful 最佳实践；容易遭受 CSRF 攻击（可以在服务器端检查 Refer 和 Origin）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于 Token 存在 Cookie 还是 localStorage 有两个观点：</p><ul><li>支持 Cookie 的开发人员会强烈建议不要将敏感信息（如 JWT）存储在 localStorage 中，因为它对于 XSS 毫无抵抗力。</li><li>支持 localStorage 的一派则认为：撇开 localStorage 的各种优点不谈，如果做好适当的 XSS 防护，收益远大于风险。</li></ul><p>放在 Cookie 中看似看全，看似“解决”一个问题（仍然存在 XSS），却引入了另一个问题（CSRF）。放在 localStorage 中具有更灵活，更大空间，天然免疫 CSRF 的特征。Cookie 空间有限，而 JWT 一半都占用较多字节，而且有时你不止需要存储一个 JWT。</p><p>确保你的代码以及第三方库的代码有足够的 XSS 检查，在此之上将 Token 存放在 localStorage 中。</p><p>在 XSS 面前，即便你的 httpOnly Cookie 无法被获取，黑客依然可以诱导或在用户毫不知情的情况下做任何事情。记住！黑客的代码和你的代码一样被用户信任！只要 XSS 存在，那么无论将信息存储在 Cookie 还是 localStorage，都是一样脆弱不堪，唯一的区别只是获取难度。XSS 漏洞很难被发现，是因为一个网站的构建不仅仅是基于你自己的代码，第三方的代码同样已可能存在 XSS。</p><h1 id="Token-和-Session"><a href="#Token-和-Session" class="headerlink" title="Token 和 Session"></a>Token 和 Session</h1><p>Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。<br>Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。</p><p>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，但是 Session 就必须依赖链路层来保障通讯安全。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</p><p>所谓的 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionId 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是认证和授权：认证是针对用户；授权是针对 App ，其目的是让某 App 有权利访问某用户的信息。这里 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionId ，即认为有此 User 的全部权利，是需要严格保密的，此数据应该只保存在站方，不应该共享给其它网站或者第三方 App。</p><p>所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token。如果永远只是自己的网站或 App，用什么都无所谓。</p><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案，是一种认证授权机制。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求是，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>有一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><p>JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为这些数字签名存在，这些传递的信息是可信的。</p><h2 id="JWT-原理"><a href="#JWT-原理" class="headerlink" title="JWT 原理"></a>JWT 原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</p><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="JWT-数据结构"><a href="#JWT-数据结构" class="headerlink" title="JWT 数据结构"></a>JWT 数据结构</h2><p>JWT 是一个很长的字符串，中间用点（.）分隔成三个部分。</p><ul><li>Header（头部）：Header 部分是一个 JSON 对象，描述 JWT 的元数据。</li><li>Payload（负载）：Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。</li><li>Signature（签名）：Signature 部分是对前两部分的签名，防止数据篡改。</li></ul><p>写成一行，就是：<code>Header.Payload.Signature</code>。</p><h2 id="JWT-使用方式"><a href="#JWT-使用方式" class="headerlink" title="JWT 使用方式"></a>JWT 使用方式</h2><ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</li><li>客户端将 Token 保存到本地（通常使用 localstorage，也可以使用 Cookie）</li><li>此后客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT，其内容看起来是这样：<code>Authorization: Bearer &lt;Token&gt;</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /calendar/v1/events<br><span class="hljs-attr">Host</span>: api.example.com<br><span class="hljs-attr">Authorization</span>: Bearer &lt;Token&gt;<br></code></pre></td></tr></table></figure><p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</p><p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要。又因为 JWT 并不使用 Cookie，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）。</p><p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制。</p><p>另一种做法是，跨域的时候，把 JWT 放在 POST 请求的数据体中。</p><p>还可以通过 URL 传输，如：<code>http://www.example.com/user?Token=xxx</code>。</p><h1 id="Token-和-JWT"><a href="#Token-和-JWT" class="headerlink" title="Token 和 JWT"></a>Token 和 JWT</h1><p>相同：</p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p>区别：</p><ul><li>Token：服务端验证客户端发送过来的 Token：解析 Token 数据后，还需要去数据库查询获取用户信息，然后验证 Token 是否有效</li><li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要再查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据</li></ul><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="使用-Cookie-时需要考虑的问题"><a href="#使用-Cookie-时需要考虑的问题" class="headerlink" title="使用 Cookie 时需要考虑的问题"></a>使用 Cookie 时需要考虑的问题</h2><ul><li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li><li>不要存储敏感数据，比如用户密码，账户余额</li><li>使用 httpOnly 在一定程度上提高安全性</li><li>尽量减少 Cookie 的体积，能存储的数据量不能超过 4kb</li><li>设置正确的 domain 和 path，减少数据传输</li><li>Cookie 无法跨域</li><li>一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie</li><li>移动端对 Cookie 的支持不是很好，而 Session 需要基于 Cookie 实现，所以移动端常用的是 Token</li></ul><h2 id="使用-Session-时需要考虑的问题"><a href="#使用-Session-时需要考虑的问题" class="headerlink" title="使用 Session 时需要考虑的问题"></a>使用 Session 时需要考虑的问题</h2><ul><li>将 Session 存储在服务器里面，当用户同时在线量比较多时，这些 Session 会占据较多的内存，需要在服务端定期的去清理过期的 Session</li><li>当网站采用集群部署时，会遇到多台 web 服务器之间如何做 Session 共享的问题。而因为 Session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 Session 的服务器，那么该服务器就无法拿到之前已经放入到 Session 中的登录凭证之类的信息了</li><li>当多个应用要共享 Session 时，除了以上问题，还可能遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 Cookie 跨域的处理</li><li>SessionId 是存储在 Cookie 中的，假如浏览器禁止 Cookie 或不支持 Cookie 怎么办？ 一般会把 SessionId 跟在 url 参数后面即重写 url，所以 Session 不一定非得需要靠 Cookie 实现</li><li>移动端对 Cookie 的支持不是很好，而 Session 需要基于 Cookie 实现，所以移动端常用的是 Token</li></ul><h2 id="使用-Token-时需要考虑的问题"><a href="#使用-Token-时需要考虑的问题" class="headerlink" title="使用 Token 时需要考虑的问题"></a>使用 Token 时需要考虑的问题</h2><ul><li>如果用数据库来存储 Token 会导致查询时间太长，可以选择放在内存当中</li><li>Token 可以避免 CSRF 攻击（因为不需要 Cookie）</li><li>移动端对 Cookie 的支持不是很好，而 Session 需要基于 Cookie 实现，所以移动端常用的是 Token</li></ul><h2 id="使用-JWT-时需要考虑的问题"><a href="#使用-JWT-时需要考虑的问题" class="headerlink" title="使用 JWT 时需要考虑的问题"></a>使用 JWT 时需要考虑的问题</h2><ul><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。因此为了减少盗用，JWT 有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li></ul><h2 id="使用加密算法时需要考虑的问题"><a href="#使用加密算法时需要考虑的问题" class="headerlink" title="使用加密算法时需要考虑的问题"></a>使用加密算法时需要考虑的问题</h2><ul><li>绝不要以明文存储密码</li><li>永远使用哈希算法来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希的这种说法，但是编码就存在解码，加密就存在解密</li><li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法</li><li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 一次性的（这点很重要）密码，然后把这个密码发送给用户</li></ul><h2 id="关闭浏览器，Session-就消失了？"><a href="#关闭浏览器，Session-就消失了？" class="headerlink" title="关闭浏览器，Session 就消失了？"></a>关闭浏览器，Session 就消失了？</h2><p>不是。对于 Session 来说，除非程序通知服务器删除一个 Session，否则服务器会一直保留，程序一般都是在用户退出的时候发个指令去删除 Session。</p><p>然而，浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 Session 机制都使用会话 Cookie 来保存 SessionId，而关闭浏览器后这个 SessionId 消失，再次连接服务器时也就无法找到原来的 Session。如果服务器设置的 Cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 SessionId 发送给服务器，则再次打开浏览器仍然能够打开原来的 Session。</p><p>恰恰是由于关闭浏览器不会导致 Session 被删除，迫使服务器为 Session 设置一个失效时间，当距离客户端上一次使用 Session 的时间超过该失效时间时，服务器就认为客户端已经停止了活动，才会把 Session 删除以节省存储空间。</p><h2 id="分布式架构下-Session-共享方案"><a href="#分布式架构下-Session-共享方案" class="headerlink" title="分布式架构下 Session 共享方案"></a>分布式架构下 Session 共享方案</h2>]]></content>
    
    
    <categories>
      
      <category>运行环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>登录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数柯里化</title>
    <link href="/2021/10/12/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/2021/10/12/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://juejin.cn/post/6844903882208837645">https://juejin.cn/post/6844903882208837645</a> 。</p><h1 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h1><p>在数学和计算机科学中，柯里化是种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><p>举例来说，一个接收 3 个参数的普通函数，在进行柯里化后，柯里化版本的函数接收一个参数并返回接收下一个参数的函数，该函数返回一个接收第三个参数的函数。最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数学和计算科学中的柯里化</span><br><br><span class="hljs-comment">// 一个接收三个参数的普通函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a + b + c);<br>&#125;<br><br><span class="hljs-comment">// 用于将普通函数转化为柯里化版本的工具函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// 内部实现省略，返回一个新函数</span><br>&#125;<br><br><span class="hljs-comment">// 获取一个柯里化后的函数</span><br><span class="hljs-keyword">let</span> _sum = curry(sum);<br><br><span class="hljs-keyword">let</span> A = _sum(<span class="hljs-number">1</span>); <span class="hljs-comment">// 返回一个接收第二个参数的函数</span><br><span class="hljs-keyword">let</span> B = A(<span class="hljs-number">2</span>); <span class="hljs-comment">// 返回一个接收第三个参数的函数</span><br>B(<span class="hljs-number">3</span>); <span class="hljs-comment">// 接收到最后一个参数，将之前所有的参数应用到原函数中，并运行得到 6</span><br></code></pre></td></tr></table></figure><p>对于 Javascript 语言，我们通常说的柯里化函数的概念与数学和计算机科学中的柯里化的概念不完全一样。</p><p>在数学和计算机科学中的柯里化函数一次只能传递一个参数，<br>而 Javascript 实际应用中的柯里化函数，可以传递一个或多个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, b, c, d, e);<br>&#125;<br><span class="hljs-comment">// 正常生成的柯里化函数</span><br><span class="hljs-keyword">let</span> _fn = curry(fn);<br><br>_fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);      <span class="hljs-comment">// 1 2 3 4 5</span><br>_fn(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);    <span class="hljs-comment">// 1 2 3 4 5</span><br>_fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>);    <span class="hljs-comment">// 1 2 3 4 5</span><br>_fn(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure><h1 id="柯里化的用途"><a href="#柯里化的用途" class="headerlink" title="柯里化的用途"></a>柯里化的用途</h1><p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。其中对于函数参数的自由处理，正是柯里化的核心所在。柯里化本质上是降低通用性，提高适用性。</p><p>假定我们有这样一段数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = [ &#123; <span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;lucy&#x27;</span> &#125;, &#123; <span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;jack&#x27;</span> &#125; ];<br></code></pre></td></tr></table></figure><p>我们需要获取数据中的所有 name 属性的值，常规思路下，我们会这样实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> names = list.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.name);<br></code></pre></td></tr></table></figure><p>用柯里化的思维来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> prop = curry(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, obj</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;)<br><span class="hljs-keyword">const</span> names = list.map(prop(<span class="hljs-string">&#x27;name&#x27;</span>));<br></code></pre></td></tr></table></figure><p>仅仅只是为了获取 name 的属性值，为何还要实现一个 prop 函数呢，这样太麻烦了吧。</p><p>我们可以换个思路，prop 函数实现一次后，以后是可以多次使用的，所以我们在考虑代码复杂程度的时候，是可以将 prop 函数的实现去掉的。我们实际的代码可以理解为只有一行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> names = list.map(prop(<span class="hljs-string">&#x27;name&#x27;</span>));<br></code></pre></td></tr></table></figure><p>这么看来，通过柯里化的方式，我们的代码变得更精简并且可读性更高。</p><h1 id="封装柯里化工具函数"><a href="#封装柯里化工具函数" class="headerlink" title="封装柯里化工具函数"></a>封装柯里化工具函数</h1><p>对于柯里化的定义：接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，执行原函数。</p><p>当柯里化函数接收到足够参数后，就会执行原函数，如何去确定何时达到足够的参数呢？有两种思路：</p><ul><li>通过函数的 length 属性，获取函数的形参个数，形参的个数就是所需的参数个数</li><li>在调用柯里化工具函数时，手动指定所需的参数个数</li></ul><p>两点结合以下，实现一个简单 curry 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将函数柯里化</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn    待柯里化的原函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>len   所需的参数个数，默认为原函数的形参个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn, len = fn.length</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> _curry.call(<span class="hljs-built_in">this</span>, fn, len)<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中转函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn    待柯里化的原函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>len   所需的参数个数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>args  已接收的参数列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_curry</span>(<span class="hljs-params">fn, len, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...params</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> _args = [...args,...params];<br>    <span class="hljs-keyword">if</span> (_args.length &gt;= len) <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, _args);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> _curry.call(<span class="hljs-built_in">this</span>, fn, len, ..._args)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> _fn = curry(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, b, c, d, e)<br>&#125;);<br><br>_fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);     <span class="hljs-comment">// 1 2 3 4 5</span><br>_fn(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);   <span class="hljs-comment">// 1 2 3 4 5</span><br>_fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>);   <span class="hljs-comment">// 1 2 3 4 5</span><br>_fn(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>); <span class="hljs-comment">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure><p>而且，可以通过占位符的方式来改变传入参数的顺序。比如说，我们传入一个占位符，本次调用传递的参数略过占位符，占位符所在的位置由下次调用的参数来填充。 </p><p>使用占位符的目的是改变参数传递的顺序，所以在 curry 函数实现中，每次需要记录是否使用占位符，并且记录占位符所代表的参数位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  </span>fn           待柯里化的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  </span>length       需要的参数个数，默认为函数的形参个数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  </span>holder       占位符，默认当前柯里化函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span>   </span>柯里化后的函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn, length = fn.length, holder = curry</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> _curry.call(<span class="hljs-built_in">this</span>, fn, length, holder, [], [])<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中转函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn            柯里化的原函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>length        原函数需要的参数个数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>holder        接收的占位符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>args          已接收的参数列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>holders       已接收的占位符位置列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span>   </span>继续柯里化的函数 或 最终结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_curry</span>(<span class="hljs-params">fn, length, holder, args, holders</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">..._args</span>)</span>&#123;<br>    <span class="hljs-comment">//将参数复制一份，避免多次操作同一函数导致参数混乱</span><br>    <span class="hljs-keyword">let</span> params = args.slice();<br>    <span class="hljs-comment">//将占位符位置列表复制一份，新增加的占位符增加至此</span><br>    <span class="hljs-keyword">let</span> _holders = holders.slice();<br>    <span class="hljs-comment">//循环入参，追加参数 或 替换占位符</span><br>    _args.forEach(<span class="hljs-function">(<span class="hljs-params">arg,i</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//真实参数 之前存在占位符 将占位符替换为真实参数</span><br>      <span class="hljs-keyword">if</span> (arg !== holder &amp;&amp; holders.length) &#123;<br>        <span class="hljs-keyword">let</span> index = holders.shift();<br>        _holders.splice(_holders.indexOf(index),<span class="hljs-number">1</span>);<br>        params[index] = arg;<br>      &#125;<br>      <span class="hljs-comment">//真实参数 之前不存在占位符 将参数追加到参数列表中</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arg !== holder &amp;&amp; !holders.length)&#123;<br>        params.push(arg);<br>      &#125;<br>      <span class="hljs-comment">//传入的是占位符,之前不存在占位符 记录占位符的位置</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arg === holder &amp;&amp; !holders.length)&#123;<br>        params.push(arg);<br>        _holders.push(params.length - <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-comment">//传入的是占位符,之前存在占位符 删除原占位符位置</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arg === holder &amp;&amp; holders.length)&#123;<br>        holders.shift();<br>      &#125;<br>    &#125;);<br>    <span class="hljs-comment">// params 中前 length 条记录中不包含占位符，执行函数</span><br>    <span class="hljs-keyword">if</span>(params.length &gt;= length &amp;&amp; params.slice(<span class="hljs-number">0</span>,length).every(<span class="hljs-function"><span class="hljs-params">i</span>=&gt;</span>i!==holder))&#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, params);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> _curry.call(<span class="hljs-built_in">this</span>, fn, length, holder, params, _holders)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log([a, b, c, d, e]);<br>&#125;<br><br><span class="hljs-keyword">let</span> _ = &#123;&#125;; <span class="hljs-comment">// 定义占位符</span><br><span class="hljs-keyword">let</span> _fn = curry(fn,<span class="hljs-number">5</span>,_);  <span class="hljs-comment">// 将函数柯里化，指定所需的参数个数，指定所需的占位符</span><br><br>_fn(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);          <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br>_fn(_, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)(<span class="hljs-number">1</span>);       <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br>_fn(<span class="hljs-number">1</span>, _, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)(<span class="hljs-number">2</span>);       <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br>_fn(<span class="hljs-number">1</span>, _, <span class="hljs-number">3</span>)(_, <span class="hljs-number">4</span>,_)(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>);  <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br>_fn(<span class="hljs-number">1</span>, _, _, <span class="hljs-number">4</span>)(_, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br>_fn(_, <span class="hljs-number">2</span>)(_, _, <span class="hljs-number">4</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之盒模型</title>
    <link href="/2021/10/03/CSS%E4%B9%8B%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/10/03/CSS%E4%B9%8B%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>盒模型指的是网页元素的结构，每个元素都是由一个盒子构成。</p><p>一个盒子由<strong>内容区域（Content）</strong>、<strong>内边距（Padding）</strong>、<strong>边框（Border）</strong>、<strong>外边距（Margin）</strong>构成。</p><h1 id="盒子类型"><a href="#盒子类型" class="headerlink" title="盒子类型"></a>盒子类型</h1><ul><li><p><code>box-sizing: content-box</code>（标准盒模型）<br>元素的<strong>宽度（width）</strong>等于元素的<strong>内容区域（Content）</strong>宽度，比显示的宽度低（高度同理）。默认值。</p></li><li><p><code>box-sizing: border-box</code>（IE 盒模型）<br>元素的<strong>宽度（width）</strong>等于元素的<strong>内容区域（Content）</strong>、<strong>内边距（Padding）</strong>、<strong>边框（Border）</strong>宽度之和，与显示的宽度相同（高度同理）。</p></li></ul><p>不管是标准盒模型还是 IE 盒模型，元素的<strong>宽度（width）</strong>都不会包括<strong>外边距（Margin）</strong>。</p><h1 id="元素宽度问题"><a href="#元素宽度问题" class="headerlink" title="元素宽度问题"></a>元素宽度问题</h1><p>将两列内容宽度设置为 70% 和 30%，但它们总共占据宽度超过了可用空间的 100%，这是因为盒模型的默认行为。当给一个元素设置宽或高的时候，指定的是内容的宽或高，元素的所有内边距、边框都是额外追加到宽度上的。</p><p>最笨的方法是减少其中一列（比如侧边栏）的宽度。但在编程中不推荐魔术数值，因为往往这难以解释一个魔术数值生效原因。如果不理解这个数值是怎么来的，那就不会知道在不同的情况下会产生什么样的结果。替代魔术数值的一个方法是让浏览器帮忙计算，使用 calc() 函数减去内边距、边框、外边距等值，得到刚好 100% 的总和，但还有更好解决办法：修改盒类型。</p><p>用通用选择器选中页面上所有元素，并用两个伪元素选择器选中网页的所有伪元素。但是如果在网页中使用了带样式的第三方组件，就可能会因此破坏其中一些组件的布局，尤其是当第三方组件在开发 CSS 的过程中没有考虑到使用者会修改盒模型时。因为全局设置 border-box 时，使用的通用选择器会选中第三方组件内的每个元素，修改盒模型可能会有问题，所以最终需要写另外的样式将组件内的元素恢复为 content-box。</p><p>有一种简单点的方式，是利用继承改一下修改盒模型的方式。盒模型通常不会被继承，但使用 inherit 关键字可以强制继承。</p><p>通常在列之间加上一个小小的间隔会更好看。两个白色背景之间的灰色空间。实现这种效果有好几种方式。给其中一列加上外边距，再调整元素的宽度，将多出来的空间减掉。</p><h1 id="元素高度问题"><a href="#元素高度问题" class="headerlink" title="元素高度问题"></a>元素高度问题</h1><p>处理元素高度的方式跟处理宽度不一样。之前对 border-box 的修改适用于高度而且很有用，但通常最好避免给元素指定明确的高度。普通文档流是为限定的宽度和无限的高度设计的。内容会填满视口的宽度，然后在必要的时候折行。因此，容器的高度由内容天然地决定，而不是容器自己决定。</p><p>当明确设置一个元素的高度时，内容可能会溢出盒容器。当内容在限定区域放不下，渲染到父元素外面时，就会发生这种现象。用 overflow 属性可以控制溢出内容的行为。也可以用 overflow-x 属性单独控制水平方向的溢出，用 overflow-y 属性单独控制垂直方向的溢出。但同时给 overflow-x 和 overflow-x 指定不同的值，往往会产生难以预料的结果。</p><p>用百分比指定高度存在问题。百分比参考的是父元素容器块的大小，但是容器的高度通常是由子元素的高度决定的。这样会造成死循环，浏览器处理不了，因此它会忽略这个声明。若想让百分比高度生效，就必须给父元素明确定义一个高度。</p><p>人们使用百分比高度是想让一个容器填满屏幕。不过更好的方式是用视口的相对单位 vh，100vh 等于视口的高度。还有一个更常见的用法是创造等高列，这不用百分比也能实现。</p><p>等高列的问题从 CSS 出现就一直困扰着人们。当时表格是实现等高列的唯一方式。具体来说，是不明确指定高度就能实现等高列的唯一方式，虽然可以简单地将所有列设置高度 500px 或其他任意值，但是如果要让列自己决定高度，每个元素可能算出来都不一样高，具体的高度取决于内容。为了解决这个问题，诞生了很多有创意的解决方案。随着 CSS 的演进，出现了伪元素、负外边距等方案。若你还在用这些复杂的方案，那么是时候改变了。</p><p>现代浏览器支持了 CSS 表格，可以轻松实现等高列。当然你可以给两列随便设一个高度值，但是，应该选择什么值呢？太大了就会在容器底部留下大片空白，太小了内容就会溢出。最好办法是让它们自己决定高度，然后扩展较矮的列，让它的高度等于较高的列。CSS 表格和 Flexbox 布局等方式都能实现这种效果。</p><h1 id="外边距问题"><a href="#外边距问题" class="headerlink" title="外边距问题"></a>外边距问题</h1><h2 id="负外边距"><a href="#负外边距" class="headerlink" title="负外边距"></a>负外边距</h2><p>不同于内边距和边框，外边距可以设置为负值。负外边距有一些特殊用途，如让元素重叠或者拉伸到比容器还宽。</p><p>负外边距的具体行为取决于设置在元素的哪边。若设置左边或者顶部的负外边距，那么元素就会相应地向左或向上移动，导致元素与它前面的元素重叠；若设置右边或者底部的负外边距，那么并不会移动元素，而是会将它后面的元素拉过来。给元素底部加上负外边距并不等同于给它下面的元素顶部加上负外边距。</p><p>如果不给一个块级元素指定宽度，那么它会自然地填充容器宽度。但是如果在右边加上负外边距，则会把它拉出容器，如果又在左边再加上相等的负外边距，元素的两边都会扩展到容器外面。</p><p>若元素被别的元素遮挡，利用负外边距让元素重叠的做法可能导致元素不可点击。负外边距并不常用，但是在某些场景下很实用尤其是当创建列布局的时候。不过应当避免频繁使用，不然网页的样式就会失控。</p><h2 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h2><p>在 CSS 中，两个或者多个普通流中相邻盒子的外边距在垂直方向上发生折叠的这种现象叫外边距折叠。这里相邻盒子可能是相邻也可能是嵌套，外边距折叠折叠分为父子外边距折叠和兄弟外边距折叠。</p><h3 id="外边距折叠分析"><a href="#外边距折叠分析" class="headerlink" title="外边距折叠分析"></a>外边距折叠分析</h3><p>外边距折叠的折叠值等于相邻外边距中的最大值。</p><p>即使两个元素不是相邻的兄弟节点，即使将两个元素都额外用一个额外的 div 标签包裹起来，也还会有外边距折叠。在没有其他 CSS 的影响下，所有相邻的顶部和底部外边距都会发送外边距折叠。</p><p>总之，所有相邻的顶部外边距和底部外边距会折叠到一起。如果只是在页面中添加了一个空的、无样式的 div（没有高度、边框和内边距），它自己的顶部和底部外边距还是会折叠。</p><p>可以给任何元素加上外边距，而不必担心它们前后的元素是什么。</p><h3 id="触发外边距折叠条件"><a href="#触发外边距折叠条件" class="headerlink" title="触发外边距折叠条件"></a>触发外边距折叠条件</h3><p>以下都满足：</p><ul><li>都是普通流中的元素且属于同一个 BFC</li><li>没有被<strong>内边距</strong>、<strong>边框</strong>、<strong>非空内容</strong>隔开</li><li>两个或两个以上垂直方向的“相邻元素”，“相邻元素”可能是父子节点也可能是兄弟节点</li></ul><h3 id="防止外边距折叠"><a href="#防止外边距折叠" class="headerlink" title="防止外边距折叠"></a>防止外边距折叠</h3><p>要避免外边距折叠只需破坏掉触发的条件即可，比如创建一个 BFC。</p><p>根据 BFC 的定义，两个元素只有在同一 BFC 内才有可能发生垂直外边距的重叠，包括相邻元素、嵌套元素。要解决外边距重叠问题，只要让它们不在同一个 BFC 内就行。</p><p>解决：</p><ul><li>对于相邻元素，只要让其中任一的一个元素触发 BFC，就能使它们的外边距不重叠；</li><li>对于嵌套元素，只要让一个元素的父级元素触发 BFC，就能使父元素外边距和子元素外边距不重叠。</li></ul><h1 id="容器内的元素间距"><a href="#容器内的元素间距" class="headerlink" title="容器内的元素间距"></a>容器内的元素间距</h1><p><strong>容器元素的内边距</strong>和<strong>容器子元素的外边距</strong>之间的相互作用处理起来很棘手。</p><p>有好几种方法可以解决该问题。使用相邻的兄弟组合器（+）来选中同一个父元素下紧跟在首个元素后面的元素，这样只在两个元素之间存在外边距。但每一次改变 HTML，都需要考虑这些外边距的问题。你得确保每个元素之间有间距，但是容器的顶部（或底部）没有多余的间距。</p><p>不要给网页当前的内容固定外边距，而是应采取更通用的方式，不管网页结构如何变化都能够生效。这就是猫头鹰选择器：会选中页面上有着相同父级的非第一个子元素。猫头鹰选择器开头是一个通用选择器，它能选中所有元素，后面是一个相邻兄弟组合器，最后是另一个通用选择器。</p><p>也许会担心通用选择器的性能问题。现在不必担心，因为现代浏览器都能很好地处理。此外，猫头鹰选择器可能会减少样式表中的选择器数量，因为它在全局范围内处理了大多数元素的间距问题。</p><p>这样使用猫头鹰选择器是需要权衡的。它省去了许多的需要设置外边距的地方，但是在某些不想加外边距的地方则需要覆盖。通常只在有并列元素，或者有多列布局时这样使用。有时还需要根据设计，给段落和标题设置特定的外边距。</p>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之网格布局</title>
    <link href="/2021/10/03/CSS%E4%B9%8B%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
    <url>/2021/10/03/CSS%E4%B9%8B%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>Demo：<br><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%A4%E6%A0%8F_%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/两栏_网格布局.html</a> 。<br><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80_%E7%85%A7%E7%89%87%E5%A2%99.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/网格布局_照片墙.html</a> 。</p><p>搭配：<br><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a> 。</p><h1 id="介绍使用"><a href="#介绍使用" class="headerlink" title="介绍使用"></a>介绍使用</h1><p>CSS 网格布局可以定义由行和列组成的二维布局，然后将元素放到网格中。有些元素可能只占据网格的一个单元，而另一些元素则可能占据多行或多列。网格的大小既可以精确定义，也可以根据自身内容自动计算。你既可以将元素精确地放置到网格某个位置，也可以让其在网格内自动定位，填充划分好的区域。</p><p>跟弹性布局类似，网格布局也是作用于两级的 DOM 结构。设置<code>display: grid</code>的元素是一个网格容器（gridcontainer），它的子元素则变成网格元素（grid items）。使用<code>display: grid</code>定义一个网格容器时，容器表现得像一个块级元素，100%填充可用宽度。也可以使用<code>display: inline-grid</code>，这样元素就会在行内流动，且宽度只能够包含子元素，不过<code>display: inline-grid</code>的使用频率不高。</p><p>有一点值得注意的是，使用网格布局并不会让弹性布局失去用武之地。使用弹性布局时，需要按照一定方式嵌套元素，用网格实现同样的布局需要修改 HTML 结构。</p><p>默认情况下，每个网格容器都会扩展并填满整个网格区域，但网格容器子元素不会填满整个网格容器，因此网格区域会出现多余的高度。一个简单的解决办法是用弹性布局，其子元素会填充高度。</p><h2 id="与弹性布局配合"><a href="#与弹性布局配合" class="headerlink" title="与弹性布局配合"></a>与弹性布局配合</h2><p>这两种布局方式有以下两个重要区别：弹性布局本质上是一维的，而网格布局是二维的；弹性布局是以内容为切入点由内向外工作的，而网格布局是以布局为切入点从外向内工作的。</p><p>弹性布局是一维的，所以它很适合用在相似的元素组成的行（列）上。它支持用 flex-wrap 换行，但是没法让上一行（列）元素跟下一行（列）元素对齐。相反网格布局是二维的，旨在解决一个轨道的元素跟另一个轨道的元素对齐的问题。</p><p>弹性布局让你在一行或一列中安排一系列元素，但是它们的大小不需要明确指定，每个元素占据的大小根据自身的内容决定。在网格布局中首先要描述布局，然后将元素放在布局结构中去。虽然每个网格元素的内容都能影响其网格轨道的大小，但这同时也会影响整个轨道大小，进而影响这个轨道里其他网格元素的大小。</p><p>当设计要求元素在两个维度上都对齐时使用网格布局；当只关心一维元素排列时使用弹性布局。在实践中，这通常（并非总是）意味着网格更适合用于整体的网页布局，弹性布局更适合对网格区域内特定元素布局。继续使用两者，你就会对不同情况下该用哪种布局得心应手。</p><h1 id="网格剖析"><a href="#网格剖析" class="headerlink" title="网格剖析"></a>网格剖析</h1><ul><li>网格线（grid line）</li></ul><p>网格线构成了网格的框架。一条网格线可以水平或者垂直，也可以位于一行或一列的任意一侧。<br>如果指定了 grid-gap 的话，它就位于网格线上。</p><ul><li>网格轨道（grid track）</li></ul><p>一个网格轨道是两条相邻网格线之间空间。网格有水平轨道（行）和垂直轨道（列）。</p><ul><li>网格单元（grid cell）</li></ul><p>网格上的单个空间，水平和垂直的网格轨道交叉重叠的部分。</p><ul><li>网格区域（grid area）</li></ul><p>网格上的矩形区域，由一个到多个网格单元组成。该区域位于两条垂直网格线和两条水平网格线之间。</p><h2 id="编号网格线"><a href="#编号网格线" class="headerlink" title="编号网格线"></a>编号网格线</h2><p>网格轨道定义好后，要将每个网格子元素放到特定的位置上。浏览器给网格里的每个网格线都赋予了编号。网格线编号从左上角为 1 开始递增，负数则指向从右下角开始的位置。</p><p>可以在 grid-column 和 grid-row 属性中用网格线的编号指定网格子元素位置。如果想要一个网格元素在垂直方向上跨越 1 号到 3 号网格线，就需要给元素设置<code>grid-column: 1 / 3</code>，同理设置<code>grid-row: 3 / 5</code>让元素在水平方向上跨越 3 号到 5 号网格线。这两属性一起就能指定一个元素应该放置的网格区域。</p><p>需要注意，grid-column 是 grid-column-start 和 grid-column-end 的简写；grid-row 是 grid-row-start 和 grid-row-end 的简写。中间的斜线只在简写属性里用于区分这两个值，斜线前后的空格不作要求。</p><p>可以用特别的关键字 span 可以用来指定 grid-row 和 grid-column 的值。这个关键字告诉浏览器子元素需要占据一个网格轨道。如果没有指出具体是哪一行或列，浏览器将会根据网格子元素的布局算法（placement algorithm）自动将其放到合适的位置。布局算法将子元素放在网格上可以容纳该元素的第一处可用空间。</p><h2 id="命名网格线"><a href="#命名网格线" class="headerlink" title="命名网格线"></a>命名网格线</h2><p>有时候记录所有网格线的编号实在太麻烦，尤其是在处理很多网格轨道时。为了简单，可以给网格线命名，并在布局网格子元素时使用网格线名称而不是编号。</p><p>使用 grid-template-columns 和 grid-template-rows 声明网格轨道时，可以在中括号内写上网格线的名称，且可以同时命名两个名称。两个名称之间用空格隔开，之后可以任选一个名称使用。</p><p>还有一个彩蛋：将两个网格线命名为 left-start 和 left-end，就定义了一个叫作 left 的区域，这区域覆盖两个网格线之间的区域。-start 和 -end 后缀作为关键字，定义两者之间区域。子元素设置<code>grid-column: left</code>，它就会跨越从 left-start 到 left-end 的区域。</p><p>命名时重复使用同一个名称合法，可以在名称后跟数字区分是第几个网格线。可以以各种方式命名网格线。它们在网格里的用法也是五花八门，这取决于每个网格特定的结构。</p><h2 id="命名网格区域"><a href="#命名网格区域" class="headerlink" title="命名网格区域"></a>命名网格区域</h2><p>不用计算或者命名网格线，直接用命名的网格区域将网格子元素定位到网格中。想要实现这一方法需要借助网格容器的 grid-template 属性和网格子元素的 grid-area 属性。</p><p>grid-template-areas 属性使用一种 ASCII art 的语法，可以直接在 CSS 中画一个可视化的网格形象。该声明给出了一系列加引号字符串，每一个字符串代表网格的一行，字符串内用空格区分每一列。</p><p>每个命名的网格区域必须组成一个矩形。不能创造更复杂的形状，比如 L 型或者 U 型。也还可以用句点（.）作为名称，这样便能空出一个网格单元。</p><p>注意，区域的命名会影响到网格线。每个区域的起始网格线会被自动命名为：区域名-start；终止网格线会被自动命名为：区域名-end。与命名网格线的彩蛋呼应。</p><h2 id="隐式网格"><a href="#隐式网格" class="headerlink" title="隐式网格"></a>隐式网格</h2><p>在某些场景下，你可能不清楚该把网格子元素放在网格的哪个位置上。处理大量子元素时，挨个指定元素的位置未免太不方便。当元素是从数据库获取时，元素的个数很可能未知。在这些情况下，以一种宽松的方式定义网格可能更合理，剩下的交给布局算法放置网格子元素。</p><p>这时需要用隐式网格（implicit grid）。使用 grid-template-columns，grid-template-rows 属性定义网格轨道创建的是显式网格（explicit grid），但有些网格子元素仍可以放在显式轨道外，此时便会自动创建隐式轨道以扩展网格，从而包含这些元素。</p><p>隐式网格轨道默认大小为 auto，也就是说它们会扩展到能容纳网格子元素内容。设置 grid-auto-columns 和 grid-auto-rows 则是为隐式网格轨道指定每列列宽和每行行高。在指定网格线的时候，隐式网格轨道并不会改变负数的含义。负的网格线编号仍是从显式网格的右下开始的。</p><h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><ul><li>grid-template-columns，grid-template-rows（网格列数行数）</li><li>grid-template-areas，grid-template（网格区域）</li><li>grid-auto-columns，grid-auto-rows（隐式网格列数行数）</li><li>grid-auto-flow，grid（子元素放置顺序）</li><li>grid-column-gap，grid-row-gap，grid-gap（网格列间隔行间隔）</li><li>justify-content，align-content，place-content（内容区域整体水平垂直位置）</li><li>justify-items，align-items，place-items（子元素内部水平垂直位置）</li></ul><h2 id="grid-template-columns，grid-template-rows"><a href="#grid-template-columns，grid-template-rows" class="headerlink" title="grid-template-columns，grid-template-rows"></a>grid-template-columns，grid-template-rows</h2><p>grid-template-columns 属性定义网格的列数和每列列宽，同时可以给网格线命名。<br>grid-template-rows 属性定义网格的行数和每行行高，同时可以给网格线命名。</p><p>新单位 fr 代表每一列（行）的分数单位（fraction unit）。这个单位跟弹性布局中 flex-grow 属性表现一样。不一定非得用分数单位，可以使用其他的单位，比如 px、em 或百分数，也可以混搭这几种单位。</p><p>有时候，重复写同样的值非常麻烦，尤其网格很多时。新方法 repeat() 函数在声明多个网格轨道的时候提供简写方式。使用 repeat() 函数可以定义不同的重复模式，比如<code>grid-template-columns: repeat(3, 2fr 1fr)</code>会重复三遍该模式，从而定义六个网格轨道，重复的最终结果是<code>2fr 1fr 2fr 1fr 2fr 1fr</code>。还可以将 repeat() 作为一个更长的模式的一部分。比如<code>grid-template-columns: 1fr repeat(3, 3fr) 1fr</code>，最终结果是<code>1fr 3fr 3fr 3fr 1fr</code>。可以看出来因为展开写法无法一目了然，所以才产生了 repeat() 这种简写方式。</p><p>有时候我们不想给一个网格轨道设置固定的尺寸，但是又希望限制它的最小值和最大值。这时候需要用到 minmax() 函数。它接收两个值：最小尺寸和最大尺寸。浏览器会确保网格轨道的大小介于这两者之间。</p><p>关键字 auto 表示由浏览器决定长度。轨道大小设置为 auto，轨道会根据自身内容扩展。</p><p>关键字 auto-fill 是特殊值，只要网格放得下，浏览器就会尽可能多地生成轨道，并且不会跟指定大小（minmax() 值）的限制产生冲突。于是两者在一起，会让网格在可用的空间内尽可能多地产生网格列或行，则轨道大小会取 minmax() 函数中的最小值。虽然产生尽可能多轨道，但是网格子元素不一定能填完轨道。</p><p>若网格子元素不够填满所有网格轨道，auto-fill 就会导致一些空的网格轨道。若不希望出现空的网格轨道，可以使用关键字 auto-fit 代替 auto-fill。它会让非空的网格轨道扩展，填满可用空间。具体选择 auto-fill 还是 auto-fit 取决于你是想要确保网格轨道的大小，还是希望整个网格容器都被填满。</p><h2 id="grid-template-areas，grid-template"><a href="#grid-template-areas，grid-template" class="headerlink" title="grid-template-areas，grid-template"></a>grid-template-areas，grid-template</h2><p>grid-template-areas 属性用于定义区域，一个区域由单个或多个单元格组成。grid-template 属性是<br>grid-template-columns、grid-template-rows、grid-template-areas 属性的合并简写形式。</p><p>grid-template-areas 属性使用一种 ASCII art 的语法，可以直接在 CSS 中画一个可视化的网格形象。该声明给出了一系列加引号字符串，每一个字符串代表网格的一行，字符串内用空格区分每一列。</p><p>每个命名的网格区域必须组成一个矩形。不能创造更复杂的形状，比如 L 型或者 U 型。也还可以用句点（.）作为名称，这样便能空出一个网格单元。</p><p>注意，区域的命名会影响到网格线。每个区域的起始网格线会被自动命名为：区域名-start；终止网格线会被自动命名为：区域名-end。与命名网格线的彩蛋呼应。</p><h2 id="grid-auto-columns，grid-auto-rows"><a href="#grid-auto-columns，grid-auto-rows" class="headerlink" title="grid-auto-columns，grid-auto-rows"></a>grid-auto-columns，grid-auto-rows</h2><p>grid-auto-columns 属性用于当设置隐式网格时，浏览器自动创建的网格的每列列宽。<br>grid-auto-rows 属性用于当设置隐式网格时，浏览器自动创建的网格的每行行高。</p><p>它们与 grid-template-columns 和 grid-template-rows 写法完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，自动决定新增网格的每列列宽和每行行高。</p><h2 id="grid-auto-flow，grid"><a href="#grid-auto-flow，grid" class="headerlink" title="grid-auto-flow，grid"></a>grid-auto-flow，grid</h2><p>当不指定网格上元素的位置时，元素会按照其布局算法自动放置。默认情况下，布局算法会按元素在标记中的顺序将其逐列逐行摆放。当一个元素无法在某一行容纳（也就是说该元素占据了太多网格轨道）时，算法会将它移动到下一行寻找足够大的空间容纳它。网格布局模块规范提供了一个属性 grid-auto-flow ，它可以控制布局算法的行为。</p><p>grid-auto-flow 属性控制布局算法放置网格子元素的顺序。grid 属性是<br>grid-template-rows、grid-template-columns、grid-template-areas、<br>grid-auto-rows、grid-auto-columns、grid-auto-flow 属性的合并简写形式。</p><ul><li>row：先行后列。元素优先放在网格行中，只有当一行填满了才会移动到下一列。默认值。</li><li>column：先列后行。元素优先放在网格列中，只有当一列填满了才会移动到下一行。</li><li>row dense：先行后列，并且尽量紧密填满不出现空格。</li><li>column dense：先列后行，并且尽量紧密填满不出现空格。</li></ul><p>关键字 dense 让布局算法紧凑地填满网格里的空白，尽管这会改变某些网格子元素的顺序。加上该关键字，子元素就会“回填”大元素造成的空白区域，但 HTML 源码顺序不变。因此紧凑的 grid-auto-flow 方式可能会导致元素出现的顺序跟 HTML 里不一致。</p><h2 id="grid-column-gap，grid-row-gap，grid-gap"><a href="#grid-column-gap，grid-row-gap，grid-gap" class="headerlink" title="grid-column-gap，grid-row-gap，grid-gap"></a>grid-column-gap，grid-row-gap，grid-gap</h2><p>grid-column-gap 属性设置网格列与列的间隔。<br>grid-row-gap 属性设置网格行与行的间隔。</p><p>grid-gap 属性是 grid-column-gap 和 grid-row-gap 属性的合并简写形式。在使用该值时，省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h2 id="justify-content，align-content，place-content"><a href="#justify-content，align-content，place-content" class="headerlink" title="justify-content，align-content，place-content"></a>justify-content，align-content，place-content</h2><p>justify-content 属性设置整个内容区域整体在容器里面的水平位置（左中右）和间隔。<br>align-content 属性设置整个内容区域整体在容器里面的垂直位置（上中下）和间隔。<br>（特别是当网格子元素的整个内容区域整体无法填满网格容器时）</p><p>place-content 属性是 align-content 和 justify-content 属性的合并简写形式。使用该值时，省略第二个值，浏览器就会假定第二个值等于第一个值。</p><p>当 place-content 属性与 grid-gap 属性冲突时，place-content 属性优先。</p><ul><li>start：对齐容器的起始边框（弹性布局里则是 flex-start）。默认值。</li><li>end：对齐容器的结束边框（弹性布局里则是 flex-end）。</li><li>center：容器内部居中。</li><li>stretch：项目大小没有指定时，拉伸占据整个网格容器。</li><li>space-between：项目间的间隔相等，项目与容器边框之间没有间隔。</li><li>space-around：项目两侧的间隔相等。所以项目之间的间隔是项目与容器边框的间隔一倍。</li><li>space-evenly：项目与项目的间隔相等，项目与容器边框的间隔也相等（弹性布局不支持）。</li></ul><h2 id="justify-items，align-items，place-items"><a href="#justify-items，align-items，place-items" class="headerlink" title="justify-items，align-items，place-items"></a>justify-items，align-items，place-items</h2><p>justify-items 属性设置网格子元素的内容在网格子元素里面的水平位置（左中右）。<br>align-items 属性设置网格子元素的内容在网格子元素里面的垂直位置（上中下）。</p><p>place-items 属性是 align-items 和 justify-items 属性的合并简写形式。使用该值时，省略第二个值，浏览器就会假定第二个值等于第一个值。</p><ul><li>stretch：拉伸，占满单元格的整个宽度。默认值。</li><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li></ul><h1 id="子元素属性"><a href="#子元素属性" class="headerlink" title="子元素属性"></a>子元素属性</h1><ul><li>grid-column-start，grid-column-end，grid-column（子元素左右网格线）</li><li>grid-row-start，grid-row-end，grid-row（子元素上下网格线）</li><li>grid-area（子元素区域）</li><li>justify-self，align-self，place-self（子元素内部水平垂直位置）</li></ul><h2 id="grid-column-start，grid-column-end，grid-column"><a href="#grid-column-start，grid-column-end，grid-column" class="headerlink" title="grid-column-start，grid-column-end，grid-column"></a>grid-column-start，grid-column-end，grid-column</h2><p>grid-column-start 属性设置网格子元素左边框所在的垂直网格线的编号或名字。<br>grid-column-end 属性设置网格子元素右边框所在的垂直网格线的编号或名字。</p><p>grid-column 属性用网格线编号或名字指定子元素垂直方向位置。grid-column 属性是 grid-column-start 和 grid-column-end 属性的合并简写形式，推荐使用简写属性，可使用 span 关键字直接占据网格轨道个数。</p><h2 id="grid-row-start，grid-row-end，grid-row"><a href="#grid-row-start，grid-row-end，grid-row" class="headerlink" title="grid-row-start，grid-row-end，grid-row"></a>grid-row-start，grid-row-end，grid-row</h2><p>grid-row-start 属性设置网格子元素上边框所在的水平网格线的编号或名字。<br>grid-row-end 属性设置网格子元素下边框所在的水平网格线的编号或名字。</p><p>grid-row 属性用网格线编号或名字指定网格子元素水平方向位置。grid-row 属性是 grid-row-start 和<br>grid-row-end 属性的合并简写形式，推荐使用简写属性，可使用 span 关键字直接占据网格轨道个数。</p><h2 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h2><p>grid-area 属性指定网格子元素项目放在哪一个区域（前提为使用 grid-template-areas 给区域命名）。<br>该属性是 grid-row-start、grid-column-start、grid-row-end、grid-column-end 属性的合并简写形式，可以直接指定网格子元素的位置。</p><h2 id="justify-self，align-self，place-self"><a href="#justify-self，align-self，place-self" class="headerlink" title="justify-self，align-self，place-self"></a>justify-self，align-self，place-self</h2><p>justify-self 属性设置网格子元素的内容在网格子元素里面的水平位置（左中右），跟 justify-items 属性用法完全一致，只作用于单个子元素。<br>align-self 属性设置网格子元素的内容在网格子元素里面的垂直位置（上中下），跟 align-items 属性用法<br>完全一致，只作用于单个子元素。</p><p>place-self 属性是 align-self 和 justify-self 属性的合并简写形式。在使用该值时，如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><ul><li>stretch：拉伸，占满单元格的整个宽度。默认值。</li><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之弹性布局</title>
    <link href="/2021/10/03/CSS%E4%B9%8B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/"/>
    <url>/2021/10/03/CSS%E4%B9%8B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>Demo：<br><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%A4%E6%A0%8F_%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%801.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/两栏_弹性布局1.html</a> 。<br><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%A4%E6%A0%8F_%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%802.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/两栏_弹性布局2.html</a> 。</p><p>搭配：<br><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a> 。<br><a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">https://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a> 。</p><h1 id="介绍使用"><a href="#介绍使用" class="headerlink" title="介绍使用"></a>介绍使用</h1><p>Flexbox，全称弹性盒子布局（FlexibleBox Layout），是一种新的布局方式。跟浮动比，Flexbox 的可预测性更好，还能提供更精细的控制，它也能轻松解决困扰我们许久的垂直居中和等高列问题。</p><p>给元素添加<code>display:flex</code>，该元素变成了一个弹性容器（flex container），它的直接子元素变成弹性子元素（flex item）。弹性子元素默认在同一行按照从左到右的顺序并排排列。弹性容器像块级元素一样填满可用宽度，但弹性子元素不一定填满其弹性容器的宽度。弹性子元素高度相等，该高度由它们的内容决定。</p><p>还可以用<code>display: inline-flex</code>，它也能创建了一个弹性容器，行为类似于 inline-block 元素。它会跟其他行内元素一起流式排列，但不会自动增长到 100% 的宽度。此容器内部的弹性子元素跟使用 <code>display: flex</code> 创建的弹性子元素行为一样。在实际开发时，很少用到 <code>display:inline-flex</code>。</p><p>弹性容器能控制内部元素的布局。子元素按照主轴线排列，主轴的方向为主起点（左）直到主终点（右）；垂直于主轴的是副轴，方向从副起点（上）到副终点（下）。轴方向可改变。</p><p>通常情况下，创建一个弹性盒子需要用到这些方法</p><ul><li>选择一个容器及其子元素，给容器设置 <code>display: flex</code> 或 <code>display: inline-flex</code></li><li>如有必要，给容器设置 flex-direction 属性</li><li>给弹性子元素设置外边距和/或 flex 值，用来控制子元素的大小</li><li>将元素大致摆放到合适的位置后，就可以按需添加其他的 Flexbox 属性</li></ul><p>Flexbox 的实现是 CSS 的一大进步。一旦你熟悉了，你可能想要在页面的每个地方都开始使用，不过你应该依靠正常的文档流，只在必要的时候才使用 Flexbox。</p><p>Flexbox 的一个有趣之处是如何基于弹性子元素的数量和其中内容量（及大小）计算容器大小。因为如果网页很大，或者加载很慢时可能会产生奇怪的行为，建议整页布局时用网格布局。只有一行多列的布局才会产生这个问题。如果主页面布局采用的是一列多行 不会出现问题。</p><p>Flexbox 是一维的，是以内容为切入点由内向外工作的。<br>Flexbox 允许使用<code>margin:auto</code>来填充弹性子元素之间的可用空间。</p><h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><ul><li>flex-flow（子元素排列方式）</li><li>flex-direction（主副轴方向）</li><li>flex-wrap（子元素换行）</li><li>justify-content（主轴方向子元素对齐方式）</li><li>align-items（副轴方向子元素对齐方式）</li><li>align-content（多轴线对齐方式）</li></ul><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>flex-flow 属性用于设置或检索弹性盒模型对象的子元素排列方式。<br>flex-flow 是 flex-direction 和 flex-wrap 的属性简写，默认值为 row nowrap。</p><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><p>Flexbox 一个重要功能是能够切换主副轴方向，其用弹性容器的 flex-direction 属性控制。<br>改变弹性方向就改变了主轴方向，副轴因为要与主轴垂直，所以方向也随之改变。</p><h3 id="row"><a href="#row" class="headerlink" title="row"></a>row</h3><p>主轴从左到右的方向排列，副轴从上到下的方向排列。默认值。</p><h3 id="row-reverse"><a href="#row-reverse" class="headerlink" title="row-reverse"></a>row-reverse</h3><p>主轴从右到左的方向排列，副轴从上到下的方向排列，类似 row。</p><h3 id="column"><a href="#column" class="headerlink" title="column"></a>column</h3><p>主轴从上到下的方向排列，副轴从左到右的方向排列。</p><p>对于弹性子元素而言，flex-basis、flex-grow 和 flex-shrink 现在作用于元素的高度而不是宽度。</p><p>水平弹性盒子的大部分概念同样适用于垂直的弹性盒子。但有一点不同：CSS 中处理高度的方式与处理宽度的方式在本质上不一样。弹性容器会占据 100% 的可用宽度，而高度则由自身的内容来决定。即使改变主轴方向，也不会影响这一本质。</p><p>弹性容器的高度由弹性子元素决定，它们会填满容器高度。但在垂直的弹性盒子里，子元素的 flex-grow 和 flex-shrink 不会起作用，除非有“外力”强行改变弹性容器的高度。</p><h3 id="column-reverse"><a href="#column-reverse" class="headerlink" title="column-reverse"></a>column-reverse</h3><p>主轴从下到的上方向排列，副轴从左到右的方向排列，类似 column。</p><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>默认情况下，子元素都排在一条线（又称”轴线”）上。当子元素填满这根轴线呢？</p><p>flex-wrap 属性设置是否允许弹性子元素换行（列）显示。当 flex-wrap 属性设置启用换行后，子元素将不再根据 flex-shrink 属性收缩，任何超过弹性容器的子元素都会换行（列）显示。</p><p>若 flex-direction 值为 column 或 column-reverse，则 flex-wrap 允许弹性子元素换到新的一列显示，不过这只在限制容器高度的情况下才发生，否则容器会扩展高度以包含全部子元素。</p><h3 id="nowrap"><a href="#nowrap" class="headerlink" title="nowrap"></a>nowrap</h3><p>不拆行或不拆列。默认值。</p><h3 id="wrap"><a href="#wrap" class="headerlink" title="wrap"></a>wrap</h3><p>必要的时候拆行或拆列，第一行在上方。<br>启用后，子元素不再根据 flex-shrink 值收缩，超过弹性容器的子元素都会换行显示。</p><h3 id="wrap-reverse"><a href="#wrap-reverse" class="headerlink" title="wrap-reverse"></a>wrap-reverse</h3><p>必要的时候拆行或拆列，但是以相反的顺序，第一行在下方。<br>启用后，子元素不再根据 flex-shrink 值收缩，超过弹性容器的子元素都会换行显示。</p><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>justify-content 属性控制子元素在主轴方向上的对齐方式（前提为子元素未填满容器）。</p><p>对齐时子元素之间会产生间距，间距是在子元素的外边距之后另进行计算的，且 flex-grow 值要考虑进来。如果任意子元素的 flex-grow 值不为 0，或任意子元素在主轴方向的外边距值为 auto，justify-content 失效。</p><h3 id="flex-start"><a href="#flex-start" class="headerlink" title="flex-start"></a>flex-start</h3><p>左对齐（子元素从主轴的开始位置顺序排列）。默认值。</p><h3 id="flex-end"><a href="#flex-end" class="headerlink" title="flex-end"></a>flex-end</h3><p>右对齐（子元素从主轴的结束位置开始排列）。</p><h3 id="center"><a href="#center" class="headerlink" title="center"></a>center</h3><p>子元素居中。</p><h3 id="space-between"><a href="#space-between" class="headerlink" title="space-between"></a>space-between</h3><p>第一个子元素左对齐，最后一个子元素右对齐，剩下的子元素间隔均匀放在两者中间。</p><h3 id="space-around"><a href="#space-around" class="headerlink" title="space-around"></a>space-around</h3><p>每个子元素两侧的间隔相等。所以，子元素之间的间隔是子元素与边框的间隔的两倍。</p><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>align-items 属性控制子元素在副轴方向上的对齐方式。</p><h3 id="stretch"><a href="#stretch" class="headerlink" title="stretch"></a>stretch</h3><p>在主轴为水平排列情况下，子元素未设高度或设为 auto，子元素填充容器高度（弹性布局能实现等高列）；在主轴为垂直排列情况下，子元素未设宽度或设为 auto，子元素填充容器宽度。默认值。</p><h3 id="flex-start-1"><a href="#flex-start-1" class="headerlink" title="flex-start"></a>flex-start</h3><p>子元素与副轴的起点对齐。</p><h3 id="flex-end-1"><a href="#flex-end-1" class="headerlink" title="flex-end"></a>flex-end</h3><p>子元素与副轴的终点对齐。</p><h3 id="center-1"><a href="#center-1" class="headerlink" title="center"></a>center</h3><p>子元素与副轴的中点对齐。</p><h3 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h3><p>子元素根据每个弹性子元素的第一行文字的基线对齐。</p><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>align-content 属性定义多根轴线在容器内对齐方式（前提为允许子元素换行（列）且有多跟轴线）。</p><p>在主轴为水平排列情况下，轴线为水平轴线，有几行则几根轴线；<br>在主轴为垂直排列情况下，轴线为竖直轴线，有几列则几根轴线。</p><p>Flexbox 为一维布局，适合用在元素组成的行或列上。Flexbox 支持用 flex-wrap 属性换行（列），但是没法让上一行（列）的元素跟下一行（列）的元素对齐，所以没有 justify-items 这样的属性。</p><p>当 align-content 属性与 align-items 属性冲突时，align-content 属性优先。</p><h3 id="stretch-1"><a href="#stretch-1" class="headerlink" title="stretch"></a>stretch</h3><p>轴线占满整个副轴。默认值。</p><h3 id="flex-start-2"><a href="#flex-start-2" class="headerlink" title="flex-start"></a>flex-start</h3><p>与副轴的起点对齐。</p><h3 id="flex-end-2"><a href="#flex-end-2" class="headerlink" title="flex-end"></a>flex-end</h3><p>与副轴的终点对齐。</p><h3 id="center-2"><a href="#center-2" class="headerlink" title="center"></a>center</h3><p>与副轴的中点对齐。</p><h3 id="space-between-1"><a href="#space-between-1" class="headerlink" title="space-between"></a>space-between</h3><p>与副轴两端对齐，轴线之间的间隔平均分布。</p><h3 id="space-around-1"><a href="#space-around-1" class="headerlink" title="space-around"></a>space-around</h3><p>每根轴线两侧的间隔相等。所以轴线之间的间隔是轴线与边框的间隔一倍。</p><h1 id="子元素属性"><a href="#子元素属性" class="headerlink" title="子元素属性"></a>子元素属性</h1><ul><li>order（子元素顺序）</li><li>flex（子元素大小）</li><li>flex-basis（子元素基准）</li><li>flex-grow（子元素增长）</li><li>flex-shrink（子元素收缩）</li><li>align-self（副轴方向子元素对齐方式）</li></ul><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>正常情况下，弹性子元素按照在 HTML 源码中出现的顺序排列。它们会沿着主轴方向从主轴起点开始排列。使用 order 属性能改变子元素排列顺序。还可以将其指为任意正负整数。如果多个弹性子元素有一样的值，它们就会按照源码顺序出现。</p><p>在初始状态下，所有弹性子元素的 order 属性值都为 0。指定一个元素的值为 −1 它则会移动到列表最前面，指定为 1 则会移动到最后。可以按需要给每个子元素指定 order 以便重新编排它们。这些值不一定要连续。</p><p>谨慎使用 order。让屏幕上的视觉布局顺序和源码顺序差别太大会影响网站的可访问性。在大多数浏览器里使用 Tab 键浏览元素的顺序与源码保持一致，如果视觉上的差别太大就会令人困惑。视力受损的用户使用的大部分屏幕阅读器也是根据源码的顺序来的。</p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex 属性控制弹性子元素在主轴方向上的大小（指元素的宽度），用来设置或者检索弹性盒模型对象子元素如何分配空间。flex 属性是 flex-grow、flex-shrink 和 flex-basis 的属性简写，前两个属性都基于 flex-basis。</p><p>推荐使用简写属性 flex，而不是分别声明 flex-grow、flex-shrink、flex-basis。与大部分的简写属性不一样，如果在 flex 中忽略声明某个子属性，那么子属性的值并不会被置为默认值。如果某个子属性被省略，那么 flex 简写属性会设置其为：<code> flex-grow:1</code> <code>flex-shrink:1</code> <code>flex-basis:0 </code>，这些默认值正是大多数情况下所需要的值。</p><p>flex 有几个特殊值：</p><ul><li><code>flex: 0 1 auto</code>（默认值）<br>不增长但自动收缩，收缩比例为 1；flex-basis 为 auto，即取自用户定义的宽度或内容本身的宽度。</li><li><code>flex: 1 1 auto</code>（auto）<br>自动增长缩放，比例均为 1；flex-basis 为 auto，即取自用户定义的宽度或内容本身的宽度。</li><li><code>flex: 0 0 auto</code>（none）<br>不增长不缩放；flex-basis 为 auto，即取自用户定义的宽度或内容本身的宽度。</li><li><code>flex: 1 1 0</code>（<code>flex: 1</code>）<br>自动增长缩放，比例均为 1；flex-basis 为 0。当给所有子元素设置 flex: 1 则代表子元素平分宽度。</li><li>两个值<br>第一个为 flex-grow；第二个，如果是数字认为是 flex-shrink，如果是宽度认为是 flex-basis。</li></ul><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>flex-basis 属性定义了子元素大小的长度基准值，即一个初始的“主尺寸”。</p><p>flex-basis 属性可以设置为任意长度单位的值，包括 px、em、百分比。它默认值是 auto，此时浏览器会检查元素是否设置 width 属性。如果有则使用 width 值作为 flex-basis 值；如果没有则用元素内容自身的大小。如果 flex-basis 的值不是 auto，那么 width 属性会被忽略。</p><p>每个子元素初始主尺寸确定后，它们可能需要在主轴方向扩大或者缩小来适应（或填充）弹性容器的大小。这时候就需要 flex-grow 属性和 flex-shrink 属性来决定如何增长和缩放。</p><p>当 flex-basis 为 0% 时，内边距会改变弹性子元素的初始主宽度计算的方式。如果想要精确结果，则要么保证两列有相同的内边距，要么用 flex 属性时使用 flex-basis 设置弹性基准值。</p><h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p>每个弹性子元素 flex-basis 值计算出来后，它们（加上子元素间的外边距）加起来会占据一定的宽度。如果加起来的宽度不一定正好填满弹性容器的宽度，可能会有留白。</p><p>多出来的留白（或剩余宽度）会按照 flex-grow（增长因子）的值分配给每个弹性子元素，flex-grow 的值为非负整数。如果弹性子元素 flex-grow 值为 0，那么子元素的宽度不会超过 flex-basis 的值；如果弹性子元素 flex-grow 值非 0，那么子元素会增长到所有的剩余空间被分配完，这意味着弹性子元素会填满容器的宽度。</p><p>flex-grow 值越大，元素的“权重”越高，就会占据更大剩余宽度。一个<code>flex-grow:2</code>的子元素增长的宽度为<code>flex-grow:1</code>的子元素增长的宽度的两倍。分配时只跟 flex-grow 有关，跟 flex-basis 无关。</p><p>flex-grow 默认值为 0。</p><h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>flex-shrink 属性与 flex-grow 属性遵循相似的原则。计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用 flex-shrink 属性又不用 flex-wrap 属性，就会导致溢出。</p><p>每个子元素的 flex-shrink 值代表它是否应该收缩以防止溢出，flex-grow 的值为非负整数。与 flex-grow 属性类似，如果子元素 flex-shrink 值为 0，则不会收缩；如果子元素 flex-shrink 值非 0，则会收缩至不再溢出。按照 flex-shrink 值的比例，值越大的元素收缩得越多。收缩时只跟 flex-shrink 有关，跟 flex-basis 无关。</p><p>flex-shrink 默认值为 1。</p><h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p>align-self 属性控制单个子元素在副轴方向上的对齐方式。align-self 属性跟弹性容器的 align-items 属性效果相同，但是它能单独给弹性子元素设定不同的对齐方式，两者冲突时 align-self 属性优先。</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>以容器的 align-items 值为准，使用其他值会覆盖容器的设置。默认值。</p><h3 id="stretch-2"><a href="#stretch-2" class="headerlink" title="stretch"></a>stretch</h3><p>在主轴为水平排列情况下，子元素未设高度或设为 auto，子元素填充容器高度（弹性布局能实现等高列）；在主轴为垂直排列情况下，子元素未设宽度或设为 auto，子元素填充容器宽度。</p><h3 id="flex-start-3"><a href="#flex-start-3" class="headerlink" title="flex-start"></a>flex-start</h3><p>子元素与副轴的起点对齐。</p><h3 id="flex-end-3"><a href="#flex-end-3" class="headerlink" title="flex-end"></a>flex-end</h3><p>子元素与副轴的终点对齐。</p><h3 id="center-3"><a href="#center-3" class="headerlink" title="center"></a>center</h3><p>子元素与副轴的中点对齐。</p><h3 id="baseline-1"><a href="#baseline-1" class="headerlink" title="baseline"></a>baseline</h3><p>子元素根据每个弹性子元素的第一行文字的基线对齐。</p>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之层叠和继承</title>
    <link href="/2021/10/03/CSS%E4%B9%8B%E5%B1%82%E5%8F%A0%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/10/03/CSS%E4%B9%8B%E5%B1%82%E5%8F%A0%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h1><p>CSS 本质上是声明规则，即在各种条件下，我们希望产生的特定的效果。如果某元素有某个类，则应用对于样式。如果 X 元素是 Y 元素的子节点，则应用那些样式。浏览器会根据这些规则，来判断每个规则应该用在哪里，并使用它们去渲染页面。</p><p>在 CSS 里实现一个效果通常有好几种方式。当 HTML 结构变化，或将同一份样式表应用到不同网页时不同的实现方式会产生不同的结果。CSS 开发很重要一点就是以可预测的方式书写规则。</p><p>首先，我们需要理解浏览器如何解析样式规则。每条规则单独来看很简单，但是当两条规则提供了相冲突的样式时会发生什么呢？层叠指的就是这一系列规则。层叠决定了如何解决冲突，是 CSS 语言的基础。虽然有经验的开发人员对层叠有大体的了解，但是层叠里有些规则还是容易让人误解。</p><p>当声明冲突时，层叠会依据 <strong>解析样式规则</strong> 解决冲突。</p><p>一个声明在层叠中“胜出”，它就会被称作一个层叠值。元素的每个属性有且只有一个层叠值。<br>层叠值：作为层叠结果，应用到一个元素上的特定属性的值。</p><h2 id="解析样式规则"><a href="#解析样式规则" class="headerlink" title="解析样式规则"></a>解析样式规则</h2><ul><li>样式表的来源：样式是从哪里来的，包括你的样式和浏览器默认样式等。</li><li>选择器优先级：哪些选择器比另一些选择器更重要。</li><li>源码顺序：样式在样式表里的声明顺序。</li></ul><p>层叠的规则是按照这种顺序来考虑的。</p><h3 id="样式表的来源"><a href="#样式表的来源" class="headerlink" title="样式表的来源"></a>样式表的来源</h3><p>你的样式表属于作者样式表，除此外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，你的样式会覆盖它们。</p><p>有些浏览器允许用户定义一个用户样式表。这是第三种来源，它的优先级介于用户代理样式表和作者样式表之间。用户样式表很少见，并且不受网站作者控制。</p><p>样式来源规则有一个例外：标记为重要的声明。在声明的后面、分号的前面加上 <code>!important</code>，该声明就会被标记为重要的声明。标记了<code>!important</code>的声明会被当作更高优先级的来源。</p><p>总体的样式表来源优先级按照由高到低排列：</p><ul><li>作者的<code>!important</code></li><li>作者样式表</li><li>用户代理样式表（浏览器默认样式）</li></ul><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>如果无法用来源解决冲突声明，浏览器会尝试检查它们的优先级。</p><p>浏览器将优先级分级：HTML 文档内的行内样式高于选择器样式。</p><h4 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h4><p>用<code>style</code>属性写的样式，这个声明只会作用于当前元素。</p><p>行内样式属于“带作用域的”声明，它会覆盖任何来自样式表或者<code>style</code>标签的样式。行内样式并没有选择器，因为它们直接作用于所在的元素。</p><p>为了能在样式表里覆盖行内声明，需要为声明添加<code>!important</code>，这样能将它提升到一个更高优先级的来源。但是如果行内样式也被标记为<code>!important</code>，则无法覆盖行内样式。</p><h4 id="选择器样式"><a href="#选择器样式" class="headerlink" title="选择器样式"></a>选择器样式</h4><p>分为内联样式和外联样式（用<code>style</code>标签写的样式和引入的 CSS 文件样式）。</p><p>不同类型的选择器有不同的优先级，一个常用表示优先级的方式是用数值形式标记，具体见 <strong>选择器</strong> 。</p><p>通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。</p><h3 id="源码顺序"><a href="#源码顺序" class="headerlink" title="源码顺序"></a>源码顺序</h3><p>如果两个声明的来源和优先级相同，其中一个声明在样式表中出现较晚，或位于页面较晚引入的样式表中，则该声明胜出。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><ul><li><p>标签选择器<br>优先级标记：0，0，1</p></li><li><p>类选择器<br>优先级标记：0，1，0</p></li><li><p>ID 选择器<br>优先级标记：1，0，0</p></li><li><p>通用选择器<br>优先级标记：0，0，0</p></li></ul><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p>特点：</p><ul><li>将多个基础选择器连接组成的一个复杂选择器</li><li>优先级由基础选择器优先级标记累加</li></ul><p>分类：</p><ul><li><p>子代组合器（&gt;）<br>匹配的目标元素是其他元素的直接后代</p></li><li><p>后代组合器（ ）（空格）<br>匹配的目标元素是其他元素的所有后代</p></li><li><p>相邻兄弟组合器（+）<br>匹配的目标元素是紧跟在其元素后面的首个兄弟元素</p></li><li><p>通用兄弟组合器（~）<br>匹配的目标元素是紧跟在其元素后面的所有兄弟元素</p></li><li><p>交集组合器（）（没有空格）<br>匹配的目标元素是符合元素全部基础选择器的元素</p></li><li><p>并集组合器（,）<br>匹配的目标元素是所有出现的选择器的元素</p></li></ul><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>特点：</p><ul><li>优先级标记：0，1，0</li><li>用于根据 HTML 属性匹配元素，以下选择器中的字母区分大小写。选择器规范 Level4 提出了一种不区分大小写的修饰符，可以作用于任何属性选择器。<br>用法是将 i 添加到结束方括号前面，如：input[value=”search”i]</li></ul><p>分类：</p><ul><li><p>[attr]<br>匹配的元素拥有指定属性 attr，无论属性值是什么，如：input[type]</p></li><li><p>[attr=”value”]<br>匹配的元素拥有指定属性 attr，且属性值是指定的字符串值，如：input[type=”radio”]</p></li><li><p>[attr~=”value”]<br>“空格分隔的列表”属性选择器。匹配的元素拥有指定属性 attr，且属性值是一个由空格分隔的值列表， 列表中的某个值等于指定的字符串值，如：a[rel=”author”]</p></li></ul><p>以上三种为存在和值（Presence and value）属性选择器。</p><ul><li><p>[attr^=”value”]<br>“开头”属性选择器。匹配的元素拥有指定属性 attr，且属性值开头是指定的字符串值，<br>如：a[href^=”https”]。</p></li><li><p>[attr$=”value”]<br>“结尾”属性选择器。匹配的元素拥有指定属性 attr，且属性值结尾是指定的字符串值，<br>如：a[href$=”.pdf”]</p></li><li><p>[attr＊=”value”]<br>“包含”属性选择器。匹配的元素拥有指定属性 attr，且属性值中包含指定的字符串值，<br>如：[class＊=”sprite-“]</p></li><li><p>[attr|=”value”]<br>匹配的元素拥有指定属性 attr，且属性值或是指定字符串值，或以该字符串开头且紧跟着一个连字符。<br>适用于语言属性，因为该属性有时候会指定一种语言的子集，比如：墨西哥西班牙语为 es-MX，普通的西班牙语为 es，如：[lang|=”es”]</p></li></ul><p>以上四种为子串值（Substring value）属性选择器。</p><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>特点：</p><ul><li>优先级标记：0，1，0</li><li>应用于一组 HTML 元素，却没有在 HTML 代码中用类属性标记这组元素</li><li>用于选中处于某个特定状态的元素，此状态可能是由于用户交互，也可能是由于元素相对于其父级或者兄弟元素的位置。伪类选择器始终以一个冒号（:）开始</li></ul><p>分类：</p><ul><li><p>:first-child<br>匹配的元素是其父元素的第一个子元素</p></li><li><p>:last-child<br>匹配的元素是其父元素的最后一个子元素</p></li><li><p>:only-child<br>匹配的元素是其父元素的唯一一个子元素（没有兄弟元素）</p></li><li><p>:nth-child(an+b)<br>匹配的元素在兄弟元素中间有特定的位置，公式 an+b 中 a 和 b 是整数需要赋值，公式指定要选中哪个元素。公式的工作原理是从 0 开始代入 n 的所有整数值。公式的计算结果指定了目标元素的位置</p></li><li><p>:nth-last-child(an+b)<br>匹配的元素在兄弟元素中间有特定的位置，类似于：nth-child()，匹配的元素不是从第一个元素往后数，而是从最后一个元素开始往前数个数。括号内的公式与：nth-child() 里的公式的规则相同</p></li><li><p>:first-of-type<br>类似于：first-child，根据拥有相同标签名的子元素中的数字顺序查找首个元素</p></li><li><p>:last-of-type<br>类似于：last-child，根据拥有相同标签名的子元素中的数字顺序查找最后一个元素</p></li><li><p>:only-of-type<br>类似于：only-child，根据拥有相同标签名的子元素中查找该类型的唯一一个子元素</p></li><li><p>:nth-of-type(an+b)<br>匹配的元素在兄弟元素中间有特定的位置<br>类似于：nth-child，根据拥有相同标签名的子元素中的数字顺序及特定公式查找元素</p></li><li><p>nth-last-of-type(an+b)<br>匹配的元素在兄弟元素中间有特定的位置<br>类似于：nth-last-child，根据拥有相同标签名的子元素中的数字顺序及特定公式查找元素，匹配的元素不是从第一个元素往后数，而是从最后一个元素开始往前数个数</p></li><li><p>:not(<selector>)<br>匹配的元素不匹配括号内的选择器，括号内选择器必须是基础选择器或属性选择器，这个只能指定元素本身，无法用于排除祖先元素，同时不允许包含另一个排除选择器</p></li><li><p>:empty<br>匹配的元素必须没有子元素<br>注意，如果元素包含空格就无法由该选择器匹配，因为空格在 DOM 中属于文本节点</p></li><li><p>:focus<br>匹配通过鼠标点击、触摸屏幕或者按 Tab 键导航而获得焦点的元素</p></li><li><p>:link<br>匹配尚未访问的链接</p></li><li><p>:visited<br>匹配已访问过的链接</p></li><li><p>:hover<br>匹配鼠标指针正悬停在其上方但没有激活的元素</p></li><li><p>:active<br>匹配被用户激活的元素</p></li><li><p>:root<br>匹配文档根元素，对 HTML 来说是<code>&lt;html&gt;</code>元素</p></li><li><p>:disabled<br>匹配已禁用的元素</p></li><li><p>:enabled<br>匹配已启用的元素</p></li><li><p>:checked<br>匹配已经针对选定的复选框、单选按钮或选择框选项</p></li><li><p>:invalid<br>根据输入类型中的定义，匹配有非法输入值的元素（Level4）</p></li><li><p>:valid<br>根据输入类型中的定义，匹配有合法值的元素（Level4）</p></li><li><p>:required<br>匹配设置了 required 属性的元素（Level4）</p></li><li><p>:optional<br>匹配没有设置 required 属性的元素（Level4）</p></li></ul><p>更多伪类选择器：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes</a> 。</p><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>特点：</p><ul><li>优先级标记：0，0，1</li><li>content 属性与伪元素配合使用，来插入生成内容</li><li>应用于一个 HTML 元素，却在 HTML 中并不存在的元素</li><li>类似于伪类，但是它不匹配特定状态的元素，而是匹配在文档中没有直接对应 HTML 元素的特定部分。伪元素选择器可能只匹配元素的一部分，甚至向 HTML 标记未定义的地方插入内容。伪元素选择器始终以一个双冒号（::）开始</li></ul><p>分类：</p><ul><li><p>::before<br>创建一个伪元素，使其成为匹配元素的首个子元素。该元素默认是行内元素，可用于插入文字图片或者其他形状。必须指定 content 属性才能让元素出现，如：.menu::before</p></li><li><p>::after<br>创建一个伪元素，使其成为匹配元素的最后一个子元素。该元素默认是行内元素，可用于插入文字图片或者其他形状。必须指定 content 属性才能让元素出现，如：.menu::after</p></li><li><p>::first-letter<br>用于指定匹配元素的第一个文本字符的样式</p></li><li><p>::first-line<br>用于指定匹配元素的第一行文本的样式</p></li><li><p>::selection<br>用于指定用户使用鼠标高亮选择的任意文本的样式。通常用于改变选中文本的 background-color。只有少数属性可以使用，包括 color、background-color、cursor、text-decoration 等</p></li><li><p>::marker<br>用于选中一个 list item 的 marker box，后者通常含有一个项目符号或者数字。它作用在任何设置了 display: list-item 的元素或伪元素上，例如<code>&lt;li&gt;</code>、<code>&lt;summary&gt;</code></p></li></ul><p>更多伪元素选择器：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements</a> 。</p><h2 id="经验法则"><a href="#经验法则" class="headerlink" title="经验法则"></a>经验法则</h2><p>面对一个样式问题时，分两个步骤来解决它。首先确定哪些声明可以实现效果。其次思考可以用哪些选择器结构，然后选择最符合需求的那个。</p><p>给链接加样式要按照一定的顺序书写选择器，因为源码顺序影响了层叠。优先级相同时，后来出现的样式会覆盖先出现的样式。如果一个元素同时处于两个或者更多状态，最后一个状态就能覆盖其他状态。如果用户将鼠标悬停在一个访问过的链接上，悬停效果会生效。如果用户在鼠标悬停时激活了链接（即点击了它），激活的样式会生效。</p><p>链接加样式顺序的口诀是“LoVe/HAte”：link（链接）、visited（访问）、hover（悬停）、active（激活）。注意，如果将一个选择器的优先级改得跟其他的选择器不一样，这个规则就会遭到破坏，可能就会带来意想不到的结果。</p><p>当创建一个用于分发的 JavaScript 模块（如 NPM 包）时，强烈建议尽量不要在 JavaScript 里使用行内样式。如果这样做，就是在强迫使用该包的开发人员要么全盘接受包里的样式，要么给每个想修改的属性加上重要标记 !important。正确的做法是在包里包含一个样式表。如果组件需要频繁修改样式，通常最好用 JavaScript 给元素添加或者移除类。这样用户就能在使用这份样式表同时，在不引入优先级竞赛前提下，能按照自己的喜好选择编辑其中的样式。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>最后一种给元素添加样式的方式：继承。经常有人把层叠跟继承混淆。虽然两者相关，但应分别理解它们。如果一个元素的某个属性没有层叠值，则可能会继承某个祖先元素的值。</p><p>默认情况下，只有特定的属性能被继承，通常是我们希望被继承的元素。</p><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><p>color（颜色，a 元素除外）<br>direction（方向）<br>font（字体）<br>font-family（字体系列）<br>font-size（字体大小）<br>font-style（用于设置斜体）<br>font-variant（用于设置小型大写字母）<br>font-weight（用于设置粗体）<br>letter-spacing（字母间距）<br>line-height（行高）<br>text-align（用于设置对齐方式）<br>text-indent（用于设置首行缩进）<br>text-transform（用于修改大小写）<br>visibility（可见性）<br>white-space（用于指定如何处理空格）<br>word-spacing（字间距）</p><h2 id="列表相关"><a href="#列表相关" class="headerlink" title="列表相关"></a>列表相关</h2><p>list-style（列表样式）<br>list-style-image（用于为列表指定定制的标记）<br>list-style-position（用于确定列表标记的位置）<br>list-style-type（用于设置列表的标记）</p><h2 id="表格相关"><a href="#表格相关" class="headerlink" title="表格相关"></a>表格相关</h2><p>border-collapse（用于控制表格相邻单元格的边框是否合并为单一边框）<br>border-spacing（用于指定表格边框之间的空隙大小）<br>caption-side（用于设置表格标题的位置）<br>empty-cells（用于设置是否显示表格中的空单元格）</p><h2 id="印刷相关"><a href="#印刷相关" class="headerlink" title="印刷相关"></a>印刷相关</h2><p>orphans（用于设置当元素内部发生分页时在页面底部需要保留的最少行数）<br>page-break-inside（用于设置元素内部的分页方式）<br>widows（用于设置当元素内部发生分页时在页面顶部需要保留的最少行数）</p><h1 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h1><p>有三个特殊值可以赋给任意属性，用于控制层叠：<code>inherit</code>、<code>initial</code>、<code>unset</code>，三个值为全局值。</p><p><code>inherit</code>关键字：使用继承代替一个层叠值。可以用它来覆盖另一个值，这样该元素就会继承其父元素的值。还可以使用 <code>inherit</code>关键字强制继承一个通常不会被继承的属性，比如边框和内边距。</p><p><code>initial</code>关键字：用于撤销某个元素的样式。每个 CSS 属性都有初始的默认值。若将<code>initial</code>值赋给某个属性，那么就会有效地将该属性值重置为该属性的默认值（而非元素的初始值），这种操作相当于硬复位了该值。但注意，<code>auto</code>不是所有属性的默认值，对很多属性来说甚至不是合法的值。</p><p><code>unset</code>关键字：如果父元素设置对应属性值，则继承父元素属性值，如果父元素没有设置对应属性值，则是将该属性重新设置为默认值。</p><p>注意：声明<code>display: initial</code>等价于<code>display: inline</code>。不管哪种类型的元素都不会等于<code>display: block</code>。这是因为<code>initial</code>关键字是重置属性为其默认值，而非元素的初始值。<code>inline</code>才是<code>display</code>属性的初始值。</p><h1 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h1><p>简写属性是用于同时给多个属性赋值的属性。如：</p><ul><li><code>border</code>是<code>border-width</code>、<code>border-style</code>、<code>border-color</code>的简写，这三个也是简写属性，<code>border-width</code>是 <code>border-top-width</code>、<code>border-bottom-width</code>、<code>border-left-width</code>、<code>border-right-width</code>的简写</li><li><code>background</code>是<code>background-color</code>、<code>background-image</code>、<code>background-size</code>、<code>background-repeat</code>、<code>background-position</code>、<code>background-origin</code>、<code>background-chip</code>、<code>background-attachment</code>的简写</li><li><code>font</code>是<code>font-style</code>、<code>font-weight</code>、<code>font-size</code>、<code>font-height</code>、<code>font-family</code>的简写</li></ul><h2 id="覆盖其他样式"><a href="#覆盖其他样式" class="headerlink" title="覆盖其他样式"></a>覆盖其他样式</h2><p>大多数简写属性可以省略一些值，只指定我们关注的值。但是要知道，这样做仍会设置省略的值，即它们会被隐式地设置为初始值。这会默默覆盖在其他地方定义的样式。</p><h2 id="简写值的顺序"><a href="#简写值的顺序" class="headerlink" title="简写值的顺序"></a>简写值的顺序</h2><p>简写属性会尽量包容指定的属性值的顺序。可以设置<code>border: 1px solid black</code>或者<code>border: black 1px solid</code>，两者都会生效。这是因为浏览器知道宽度、颜色、边框样式分别对应什么类型的值。</p><p>但是有很多属性的值很模糊。在这种情况下，值的顺序很关键。理解这些简写属性的顺序很重要。</p><h3 id="上、右、下、左"><a href="#上、右、下、左" class="headerlink" title="上、右、下、左"></a>上、右、下、左</h3><p>当遇到像<code>margin</code>、<code>padding</code>这样的属性，还有为元素的四条边分别指定值的边框属性时，容易弄错这些简写属性的顺序。这些属性的值是按顺时针方向，从上边开始的。记住顺序能少犯错误。它的记忆口诀是<strong>TRouBLe</strong>：top（上）、right（右）、bottom（下）、left（左）：</p><ul><li>使用一个值，用于全部四个边</li><li>使用两个值，前一个值用于上下两边，后一个值用于左右两边</li><li>使用三个值，第一个值用于上边，第二个值用于左右两边，第三个值用于下边</li><li>使用四个值，按照时钟顺序依次应用于上、右、下、左四个边</li></ul><h3 id="水平、垂直"><a href="#水平、垂直" class="headerlink" title="水平、垂直"></a>水平、垂直</h3><p>还有一些属性只支持最多指定两个值，这些属性包括<code>background-position</code>、<code>box-shadow</code>、<code>text-shadow</code>等（虽然严格来讲它们并不是简写属性）。这些属性值顺序跟<code>padding</code>这种四值属性的顺序刚好相反。</p><p>看起来顺序相反的定义违背直觉，原因很简单：这两个值代表了一个笛卡儿网格。笛卡儿网格的测量值一般是按照(x,y)(水平,垂直)的顺序来的。第一个值指定水平方向的偏移量，第二个值指定垂直方向的偏移量。</p>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之定位</title>
    <link href="/2021/10/03/CSS%E4%B9%8B%E5%AE%9A%E4%BD%8D/"/>
    <url>/2021/10/03/CSS%E4%B9%8B%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p>只有绝对定位、固定定位会脱离普通文档流，静态定位、相对定位、粘性定位不会脱离普通文档流。</p><p>脱离普通文档流：从普通文档流中被移除，不影响普通文档流的布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: static;<br><span class="hljs-attribute">position</span>: fixed;<br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">position</span>: relative;<br><span class="hljs-attribute">position</span>: sticky;<br></code></pre></td></tr></table></figure><h1 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h1><p>默认值，静态定位，没有定位，遵循正常的文档流对象。static 改成其他值，我们就说元素就被定位，是定位元素。如果元素使用静态定位，那么就说它未被定位，是非定位元素。</p><p>不会受到 top、bottom、left、right 属性的影响。</p><h1 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h1><p>给元素设置<code>position: fixed</code>就能将元素放在视口的任意位置而随着网页滑动保持不变。这样需要搭配四个属性一起使用：top、right、bottom、left 。这四个属性值决定了固定定位的元素与浏览器视口边缘的距离，还隐式地定义了元素的宽高。</p><p>固定定位让元素相对视口固定定位，此时视口被称作元素的包含块（containing block）。</p><p>定位一个元素时，不要求指定四个方向的值，可以只指定需要的方向值，然后用 width 和/或 height 来决定它的大小，也可以让元素本身来决定大小。</p><p>因为固定元素从文档流中移除，所以它不再影响页面其他元素的位置。其他的元素会跟随正常文档流，就像固定元素不存在一样。就是说它们通常会在固定元素下面排列，视觉上被遮挡。</p><h1 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h1><p>绝对定位行为跟固定定位相似，只是它的包含块不一样。绝对定位不是相对视口，而是相对最近的祖先定位元素。跟固定元素一样，top、right、bottom、left 属性值决定了元素的边缘在包含块里的位置，还隐式地定义了元素的宽高。</p><p>如果父元素未被定位，则浏览器会沿着 DOM 树往上找它的祖父、曾祖父，直到找到一个定位元素用它作为包含块。但如果祖先元素都没有定位，则会基于初始包含块来定位。初始包含块跟视口一样大，固定在网页的顶部，也就是相对视口定位。</p><p>绝对定位是定位类型里的重量级选手。它经常跟 JavaScript 配合，用于弹出菜单、工具提示及消息盒子等。</p><h1 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h1><p>相对定位可能是最不被理解的定位类型。当第一次给元素加上<code>position: relative</code>时候，你通常看不到页面上有任何视觉改变。相对定位元素以及它周围的所有元素，都还保持着原来位置。</p><p>相对定位的位置依赖于文档流。如果设置 top、right、bottom、left 属性，元素就会从它原来所在的文档流位置移动，但是不会改变它周围任何元素的位置。跟固定定位盒绝对定位不一样，不能用这四个属性来改变相对定位元素的大小。这些属性只能让元素在原来的文档流位置下、左、上、右方向移动。可以用 top 或 bottom，但不能一起用（ bottom 会被忽略）；可以用 left 或 right，但也不能一起用（ right 会被忽略）。</p><p>有时可用四个属性调整相对元素的位置，把它挤到某个位置，但这只是相对定位的一个冷门用法。更常见的用法是使用<code>position: relative</code>给它里面的绝对定位元素创建一个包含块。</p><h1 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h1><p>粘性定位是固定定位和相对定位的结合体：正常情况下，元素随着页面滚动，当元素到达屏幕特定位置时，如果用户继续滚动，元素就会“锁定”在这个位置。这个“特定位置”，由 top、right、bottom、left 属性决定。和相对定位相似，可以用 top 或 bottom，但不能一起用（ bottom 会被忽略）；可以用 left 或 right，但也不能一起用（ right 会被忽略），但若一个值也不设置，其定位行为与相对定位相同。</p><p>如果浏览器不支持粘性定位，通常要用固定定位或者绝对定位来回退处理。</p><p>粘性元素永远不会超出父元素的范围。注意，只有当父元素的高度大于粘性元素时侯才会让粘性元素固定，因此建议给父元素加上 min-height，以便让父元素足够高。注意，其父元素不能设置<code>overflow:hidden</code>或者<code>overflow:auto</code>属性。</p><h1 id="定位层叠"><a href="#定位层叠" class="headerlink" title="定位层叠"></a>定位层叠</h1><p>定位非常有用，但也需要弄清楚它会带来什么后果。当把一个元素从文档流中移除时，我们就需要管理之前由文档流处理的所有事情。</p><p>首先要确保元素不会跑到浏览器视口之外，导致用户会看不到元素。其次还要保证元素不会不小心挡住重要内容。最后还有层叠的问题。在同一页面定位多个元素时，可能会遇到两个不同定位的元素重叠的现象。</p><h2 id="渲染过程和层叠顺序"><a href="#渲染过程和层叠顺序" class="headerlink" title="渲染过程和层叠顺序"></a>渲染过程和层叠顺序</h2><p>浏览器将 HTML 文件解析为 DOM 的同时还创建了另一个树形结构，叫作渲染树（render tree）。它代表了每个元素的视觉样式和位置。同时还决定浏览器绘制元素的顺序。顺序很重要，因为如果元素刚好重叠，后绘制的元素就会出现在先绘制的元素前面。</p><p>通常情况下（使用定位之前），元素在 HTML 里出现的顺序决定了绘制的顺序。但在使用定位元素时，这种行为会改变。浏览器会先绘制所有非定位的元素，然后绘制定位元素。默认情况下，所有的定位元素会出现在非定位元素前面。之后对于定位元素，基于源码的层叠关系并没有改变，依然按照后绘制的定位元素出现在先绘制的定位元素前面的规则。</p><p>通常情况下，模态框要放在网页内容的最后，body 标签关闭之前。大多数的构建模态框 JavaScript 库会自动这样做。因为模态框使用固定定位，所以不必关心它标记出现在哪，它会一直定位到屏幕中间。</p><p>改变固定定位元素的标记位置不会产生不好的影响，但是对相对、绝对或粘性定位的元素来说，通常无法用改变标记位置的方法解决层叠问题。相对定位依赖于文档流，绝对定位依赖于元素的定位祖先节点。这时候需要用 z-index 属性来控制它们的层叠行为。</p><h2 id="z-index-属性控制层叠顺序"><a href="#z-index-属性控制层叠顺序" class="headerlink" title="z-index 属性控制层叠顺序"></a>z-index 属性控制层叠顺序</h2><p>z-index 属性值可以是任意整数（正负都行）。z 表示是笛卡儿 x-y-z 坐标系里的深度方向。拥有较高 z-index 的元素出现在拥有较低 z-index 的元素前面。拥有负数 z-index 的元素出现在静态定位元素后面。</p><p>使用 z-index 是解决网页层叠问题的第二个方法，该方法不要求修改 HTML 的结构。</p><p>z-index 行为很好理解，但是使用它时要注意两个小陷阱。第一，z-index 只会在定位元素上生效，不能用它控制静态元素。第二，给一个定位元素加上 z-index 可以创建层叠上下文。</p><h2 id="理解层叠上下文"><a href="#理解层叠上下文" class="headerlink" title="理解层叠上下文"></a>理解层叠上下文</h2><p>一个层叠上下文包含一个元素或者由浏览器一起绘制的一组元素。其中一个元素会被作为层叠上下文的根，比如给一个定位元素添加 z-index 时，该定位元素就变成了一个新的层叠上下文的根，它所有后代元素就是这个层叠上下文的一部分。</p><p>不要将层叠上下文跟 BFC 弄混，它们是两个独立的概念，尽管不一定互斥。层叠上下文是负责决定哪些元素出现在另一些元素前面，而 BFC 负责处理文档流，以及元素是否会重叠。</p><p>实际上将层叠上下文里的所有元素一起绘制会造成严重的后果：层叠上下文之外元素无法叠放在层叠上下文内的两个元素之间。换句话说，若一个元素叠放在一个层叠上下文前，那么此层叠上下文里没有元素可以被拉到该元素前面；若一个元素被放在层叠上下文后，那么层叠上下文里没有元素能出现在该元素后面。</p><p>给一个定位元素加 z-index 属性是创建层叠上下文最主要的方式，但还有别的属性也能创建，比如小于 1 的 opacity 属性，以及 transform、filter 属性。由于这些属性主要会影响元素及其子元素渲染的方式，因此一起绘制父子元素。文档根节点（html 元素）也会给整个页面创建一个顶级的层叠上下文。</p><blockquote><p>所有层叠上下文内的元素会按照以下顺序，从后到前叠放：</p></blockquote><ul><li>层叠上下文的根</li><li>z-index 为负的定位元素（及其子元素）</li><li>block 块状水平盒子</li><li>float 浮动盒子</li><li>inline/inline-block 水平盒子</li><li>z-index 为 auto 看成 z-index:0 的定位元素（及其子元素），不靠 z-index 的重叠上下文</li><li>z-index 为正的定位元素（及其子元素）</li></ul><p>如果发现 z-index 并没有按照预期表现，那就在 DOM 树里往上找到元素祖先节点，直到层叠上下文的根。然后给它设置 z-idnex，将整个层叠上下文向前或向后放。还要注意多个层叠上下文嵌套的情况。</p><p>网页很复杂时，很难判断是哪个层叠上下文导致的问题。因此在创建层叠上下文的时候就一定要多加小心，没有特殊理由的话不要随意创建，尤其是当一个元素包含了网页很大一部分内容的时候。尽可能地将独立的定位元素（如模态框）放到 DOM 的顶层，body 结束标签之前，这样就没有外部的层叠上下文能束缚它们。</p><p>有些开发人员会忍不住给页面的大量元素使用定位。一定要克制这种冲动。定位用得越多，网页就越复杂，也就越难调试。如果你定位了大量元素，就回头评估一下现在的情况，尤其当你发现很难调试出自己想要的布局时，一定要反思。如果可以用别的方法实现某个布局，应该优先用那些方法。</p><p>如果能够依靠文档流，而不是靠明确指定定位的方式实现布局，那么浏览器会帮我们处理好很多边缘情况。记住，定位可能会将元素拉出文档流。一般来说只有在需要将元素叠放到别的元素之前时，才应该用定位。</p>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之文档流</title>
    <link href="/2021/10/03/CSS%E4%B9%8B%E6%96%87%E6%A1%A3%E6%B5%81/"/>
    <url>/2021/10/03/CSS%E4%B9%8B%E6%96%87%E6%A1%A3%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>当浏览器解析HTML文档时，会在内存里将页面的所有元素表示为 DOM（文档对象模型）。它是一个树结构，其中每个元素都由一个节点表示。<code>&lt;html&gt;</code>元素是顶级根节点。它的下面是子节点：<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>。再下面是逐级嵌套的后代节点。</p><p>在文档中，根节点是所有其他元素的祖先节点。根节点有一个伪类选择器（:root）可以用来选中它自己。这等价于类型选择器 html，但是 html 的优先级相当于一个类名，而不是一个标签。</p><p>定位方案是控制元素的布局，有三种常见方案：普通流、浮动、定位。</p><h1 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h1><p>普通文档流指的是网页元素的默认布局行为。</p><p>普通文档流中，元素按照其在 HTML 文档中的先后位置至上而下布局。此过程中，行内元素水平排列，跟随文字的方向从左到右排列，直到当行被占满然后换行。块级元素则会被渲染成为一个完整的新行，它会占据完整的一行，前后都有换行。除非另外指定，否则所有元素默认都是普通流定位，即普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p><p>普通文档流是为限定的宽度和无限的高度设计的。内容会填满视口的宽度，然后在必要的时候折行。因此，容器的高度由内容天然地决定，而不是容器自己决定。</p><p>脱离普通文档流有三种方式：浮动、定位（绝对定位和固定定位）。</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>块格式化上下文（Block Formatting Contexts）是 Web 页面可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域。BFC 是网页的一块区域，元素基于此区域布局，BFC 里内容不会跟外部的元素重叠或相互影响。</p><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面元素不会在布局上影响到外面元素，并且 BFC 具有普通容器所没有的一些特性。可以把 BFC 理解为一个封闭大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。某些情况下，BFC 中的内容可能还会与别的 BFC 的内容重叠。</p><p>BFC 包含创建它的元素内部的所有内容，属于定位方案的普通流。</p><h3 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h3><ul><li>根元素（html）</li><li>元素 overflow 值不为 visible</li><li>元素 float 值不为 none</li><li>元素 position 值为 absolute、fixed</li><li>元素 contain 值为 layout、content、paint </li><li>元素 display 值为 flow-root</li><li>元素 display 值为 inline-block</li><li>元素 display 值为 flex、 inline-flex 及其直接子元素（弹性元素及其直接子元素）</li><li>元素 display 值为 grid、inline-grid 及其直接子元素（网格元素及其直接子元素）</li><li>元素 display 值为 table-cell（表格单元格）</li><li>元素 display 值为 table-caption（表格标题）</li><li>元素 display 值为 table、inline-table、table-row、<br>table-row-group、table-header-group、table-footer-group（匿名表格单元格元素）</li><li>元素 column-count、column-width 值不为 auto，包括 column-count 值为 1（多列容器）</li><li>元素 column-span 值为 all，即使该元素没有包裹在一个多列容器中</li></ul><p>使用说明：</p><p>使用<code>display: flow-root</code>可以创建无副作用的 BFC。在父级块当中使用<code>display: flow-root</code>可以创建新的 BFC，父级块的所有内容都会参与 BFC。</p><p>使用<code>overflow: auto</code>会创建一个包含这个元素的 BFC，通常的做法是设置父级块<code>overflow: auto</code>或者设置其它的非默认的<code>overflow: visible</code>的值。使用 overflow 创建一个新的 BFC，是因为 overflow 属性告诉浏览器你想要怎样处理溢出的内容。当使用这个属性只是为了创建 BFC 的时候，你可能会发现一些不想要的问题，比如滚动条或一些剪切的阴影，需要注意。另外，对于后续的开发，可能不是很清楚当时为什么使用 overflow，所以最好添加一些注释来解释为什么这样做。</p><p>也可以使用其他方式，但是有些问题需要注意，比如，使用浮动或<code>display: inline-block</code>方式创建 BFC 的元素宽度会变成 100%，因此需要限制一下元素的宽度，防止因为过宽而换行，导致内容移动到浮动图片的下面。相反，使用<code>display: table-cell</code>方式显示的元素，它的宽度只会刚好容纳其中的内容，因此需要设置一个较大的宽度，强制使其填满剩余空间。</p><h3 id="BFC-用途"><a href="#BFC-用途" class="headerlink" title="BFC 用途"></a>BFC 用途</h3><ul><li>使用 BFC 浮动定位</li><li>使用 BFC 清除浮动</li><li>使用 BFC 防止外边距折叠</li><li>使用 BFC 防止浮动容器高度塌陷</li><li>使用 BFC 防止媒体对象「文字环绕」</li></ul><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p>内联格式化上下文（Inline Formatting Contexts）是一个网页的渲染结果的一部分。其中，各行内框（inline boxes）一个接一个地排列，其排列顺序则是根据书写模式的设置来决定的：水平书写，各个框从左边开始水平地排列；垂直书写，各个框从顶部开始水平地排列。</p><h3 id="IFC-布局规则"><a href="#IFC-布局规则" class="headerlink" title="IFC 布局规则"></a>IFC 布局规则</h3><p>子元素水平方向横向排列，并且垂直方向起点为元素顶部。</p><p>子元素只会计算横向样式空间，垂直方向样式空间不会被计算。</p><p>在垂直方向上，子元素会以不同形式来对齐（vertical-align）。</p><p>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是由包含块（containing box）和与其中的浮动来决定。</p><p>IFC中的“line box”一般左右边贴紧其包含块，但float元素会优先排列。</p><p>IFC中的“line box”高度由 CSS 行高计算规则来确定，同个IFC下的多个line box高度可能会不同。</p><p>当 inline-level boxes的总宽度少于包含它们的line box时，其水平渲染规则由 text-align 属性值来决定。</p><p>当一个“inline box”超过父元素的宽度时，它会被分割成多个boxes，这些 oxes 分布在多个“line box”中。如果子元素未设置强制换行的情况下，“inline box”将不可被分割，将会溢出父元素。</p><p>框会从包含块的顶部开始，一个接一个地水平摆放。</p><p>摆放这些框时，它们在水平方向的 内外边距+边框 所占用的空间都会被考虑； 在垂直方向上，这些框可能会以不同形式来对齐： 水平的margin、padding、border有效，垂直无效。不能指定宽高。</p><p>行框的宽度是 由包含块和存在的浮动来决定; 行框的高度 由行高来决定。</p><h3 id="创建-IFC"><a href="#创建-IFC" class="headerlink" title="创建 IFC"></a>创建 IFC</h3><p>块级元素中仅包含内联级别元素。形成条件非常简单，需要注意的是当 IFC 中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p><h3 id="IFC-用途"><a href="#IFC-用途" class="headerlink" title="IFC 用途"></a>IFC 用途</h3><p>水平居中：当一个块要在环境中水平居中时，设置其为<code>displau: inline-block</code>则会在外层产生 IFC，通过 text-align 属性则可以使其水平居中。</p><p>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其<code>vertical-align: middle</code>，其他的行内元素则可以在此父元素下垂直居中。</p>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之居中</title>
    <link href="/2021/10/03/CSS%E4%B9%8B%E5%B1%85%E4%B8%AD/"/>
    <url>/2021/10/03/CSS%E4%B9%8B%E5%B1%85%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<p>Demo：<br><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E5%B1%85%E4%B8%AD_%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/居中_元素水平居中.html</a> 。<br><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E5%B1%85%E4%B8%AD_%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/居中_元素垂直居中.html</a> 。<br><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E5%B1%85%E4%B8%AD_%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/居中_元素水平垂直居中.html</a> 。</p><h1 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h1><ul><li>针对 <strong>单行文本水平居中</strong> ，对文本的最近的块级祖先元素设置<code>text-align: center</code></li><li>针对 <strong>单行文本垂直居中</strong> ，对文本的最近的块级祖先元素设置<code>line-height === height</code></li><li>针对 <strong>多行文本水平居中</strong> ，将其包装为块级元素，使用块级元素的水平居中方法</li><li>针对 <strong>多行文本垂直居中</strong> ，将其包装为块级元素，使用块级元素的垂直居中方法</li></ul><h1 id="元素居中"><a href="#元素居中" class="headerlink" title="元素居中"></a>元素居中</h1><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>子元素不能填满父元素宽度，说明父元素是块级元素（前后有换行符）。</p><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><p>针对子元素是行内元素或行内块级元素，行内元素设置宽度无效。</p><p>对父元素设置<code>text-align: center</code></p><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素宽度。</p><p>对子元素设置<code>margin: 0 auto</code></p><h3 id="定位-calc"><a href="#定位-calc" class="headerlink" title="定位 + calc()"></a>定位 + calc()</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素宽度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; left: calc(50% - width/2)</code></p><h3 id="定位-margin"><a href="#定位-margin" class="headerlink" title="定位 + margin"></a>定位 + margin</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素宽度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; left: 0; right: 0; margin: 0 auto</code></p><h3 id="定位-负-margin"><a href="#定位-负-margin" class="headerlink" title="定位 + 负 margin"></a>定位 + 负 margin</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素宽度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; left: 50%; margin-left: - width/2</code></p><h3 id="定位-transform"><a href="#定位-transform" class="headerlink" title="定位 + transform"></a>定位 + transform</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素宽度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; left: 50%; transform: translate(-50%, 0)</code></p><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素宽度。</p><p>对父元素设置<code>display: flex; justify-content: center</code></p><h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素宽度。</p><p>对父元素设置<code>display: grid; justify-content: center</code>；或者<br>对父元素设置<code>display: grid; justify-items: center</code>；或者<br>对父元素设置<code>display: grid;</code>、对子元素设置<code>justify-self: center</code></p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>子元素不能填满父元素高度，说明父元素是块级元素（前后有换行符）。</p><h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><ul><li>针对子元素是行内元素或行内块级元素，行内元素设置高度无效。<br>该属性控制着子元素在行内的垂直对齐，想要使用该属性生效，需要该行内的所有元素都设置该属性。</li></ul><p>利用 ::before 或 ::after 添加伪元素到父元素下，并设置伪元素<code>height: 100%; width: 0; content: &#39; &#39;; display: inline-block; vertical-align: middle</code>，然后父元素的所有子元素设置<code>vertical-align:middle</code>，就可以让子元素都垂直居中。不过需要所有子元素都为行内元素，即 display 为 inline 或 inline-block。</p><ul><li>针对子元素是表格单元格，设置高度无效。<br>该属性控制着表格单元格内的内容在单元格内的垂直对齐。</li></ul><p><code>display: table-cell</code>会使元素表现类似一个表格中的单元格 td，这个特性可以实现文字的垂直居中效果。同时它也会破坏一些 CSS 属性，使用 table-cell 时最好不要与 float 和<code>position: absolute</code>一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对 margin 设置无效，可以响应 padding 设置，表现几乎类似一个 td 元素。</p><h3 id="定位-calc-1"><a href="#定位-calc-1" class="headerlink" title="定位 + calc()"></a>定位 + calc()</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素高度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; top: calc(50% - widht/2)</code></p><h3 id="定位-margin-1"><a href="#定位-margin-1" class="headerlink" title="定位 + margin"></a>定位 + margin</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素高度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; top: 0; bottom: 0; margin: auto 0</code></p><h3 id="定位-负-margin-1"><a href="#定位-负-margin-1" class="headerlink" title="定位 + 负 margin"></a>定位 + 负 margin</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素高度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; top: 50%; margin-top: - width/2</code></p><h3 id="定位-transform-1"><a href="#定位-transform-1" class="headerlink" title="定位 + transform"></a>定位 + transform</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素高度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; top: 50%; transform: translate(0, -50%)</code></p><h3 id="弹性布局-1"><a href="#弹性布局-1" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素高度。</p><p>对父元素设置<code>display: flex; align-items: center</code>；或者<br>对父元素设置<code>display: flex</code>、对子元素设置<code>align-self: center</code></p><h3 id="网格布局-1"><a href="#网格布局-1" class="headerlink" title="网格布局"></a>网格布局</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素高度。</p><p>对父元素设置<code>display: grid; align-content: center</code>；或者<br>对父元素设置<code>display: grid; align-items: center</code>；或者<br>对父元素设置<code>display: grid</code>、对子元素设置<code>align-self: center</code></p><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="定位-calc-2"><a href="#定位-calc-2" class="headerlink" title="定位 + calc()"></a>定位 + calc()</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素高度和宽度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; top: calc(50% - widht/2); left: calc(50% - width/2)</code></p><h3 id="定位-margin-2"><a href="#定位-margin-2" class="headerlink" title="定位 + margin"></a>定位 + margin</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素高度和宽度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; top: 0; left: 0; top: 0; bottom: 0; margin: auto</code></p><h3 id="定位-负-magin"><a href="#定位-负-magin" class="headerlink" title="定位 + 负 magin"></a>定位 + 负 magin</h3><p>针对子元素是块级元素， <strong>需要</strong> 设置子元素高度和宽度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; top: 50%; left: 50%; margin: -height/2 0 0 - width/2</code></p><h3 id="定位-transform-2"><a href="#定位-transform-2" class="headerlink" title="定位 + transform"></a>定位 + transform</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素高度和宽度。</p><p>对父元素设置<code>position: relative</code><br>对子元素设置<code>position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)</code></p><h3 id="弹性布局-2"><a href="#弹性布局-2" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素高度。</p><p>对父元素设置<code>display: flex; justify-content: center; align-items: center</code>；或者<br>对父元素设置<code>display: flex; justify-content: center</code>、对子元素设置<code> align-self: center</code></p><h3 id="网格布局-2"><a href="#网格布局-2" class="headerlink" title="网格布局"></a>网格布局</h3><p>针对子元素是块级元素， <strong>不需要</strong> 设置子元素高度。</p><p>对父元素设置<code>display: grid; justify-content: center; align-content: center</code>；或者<br>对父元素设置<code>display: grid; justify-items: center; align-items: center</code>；或者<br>对父元素设置<code>display: grid</code>、对子元素设置<code>justify-self: center; align-self: center</code>；或者<br>其它六种组合方式</p>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之浮动</title>
    <link href="/2021/10/03/CSS%E4%B9%8B%E6%B5%AE%E5%8A%A8/"/>
    <url>/2021/10/03/CSS%E4%B9%8B%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>Demo：<a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E6%B5%AE%E5%8A%A8.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/浮动.html</a> 。</p><h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><h2 id="理解浮动"><a href="#理解浮动" class="headerlink" title="理解浮动"></a>理解浮动</h2><p>浮动是网页布局最古老的方式，并且在过去很多年都是唯一的方式。不过，它有些让人捉摸不透。要想理解浮动，得从了解它的设计初衷入手。在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，效果与印刷排版中的文本环绕相似。</p><p>浮动能将一个元素（通常是一张图片）拉到其容器的一侧，这样文档流就能包围它。通常最简单方式是先将网页的大块区域布局好，再逐级布局内部的小元素。在开始浮动元素前，要先将网页的外层结构样式写好。</p><p>Flexbox 布局正在迅速取代浮动在页面布局中的地位。对新手开发人员而言，Flexbox 行为很直观，可预测性更好。但是，要实现将图片移动到网页一侧，且让文字围绕图片的效果，浮动仍是唯一的方法。</p><h2 id="浮动的问题"><a href="#浮动的问题" class="headerlink" title="浮动的问题"></a>浮动的问题</h2><p>浮动有一些行为会让人措手不及。这些并不是 bug，而是因为浮动严格遵循了标准。</p><h3 id="容器高度塌陷"><a href="#容器高度塌陷" class="headerlink" title="容器高度塌陷"></a>容器高度塌陷</h3><p>浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。这可能看起来很奇怪，但是恰好体现了浮动的设计初衷。浮动是为了实现文字围绕浮动元素排列的效果。在段落里浮动图片时，段落的高度并不会增长到能够容纳该图片。就是说，如果图片比段落文字高，下一段就会直接从上一段的文字下面开始，两段文字都会围绕浮动的图片排列。</p><h3 id="浮动元素“陷阱”"><a href="#浮动元素“陷阱”" class="headerlink" title="浮动元素“陷阱”"></a>浮动元素“陷阱”</h3><p>如果众多的元素浮动到同一侧，如果每个浮动盒子的高度不一样，最后的布局可能会千变万化。同理，改变浏览器的宽度也会造成相同的结果，因为这样会导致换行，从而改变元素高度。</p><p>想修复这个问题很简单：清除浮动元素上面的浮动。更通用的做法是，清除每行上的首个元素上面的浮动。设置好每行的盒子个数后可以用伪类选择器 nth-child() 选中这些目标元素。</p><p>这种清除每行浮动的技术要求知道每行有几个元素。若宽度不是通过百分比来定义的，那么随着视口宽度的改变，每行的元素个数可能会变化。这种情况下最好用别的布局方案，比如 Flexbox 或者 inline-block 元素。</p><h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>解决包含浮动问题的做法，叫作清除浮动。有两个思路：<strong>使用 clear 属性</strong>和<strong>对父元素创建 BFC</strong>。</p><h2 id="clear-属性"><a href="#clear-属性" class="headerlink" title="clear 属性"></a>clear 属性</h2><p>一个思路是使用跟浮动配套的 clear 属性。clear 属性只对块级元素生效，<code>clear: both</code>声明能让元素移动到浮动元素的下面而不是侧面，clear 也可以设为 left 或 right，但这样只会相应清除向左或向右浮动的元素。</p><p>因为使用 clear 属性的元素本身没有浮动，所以容器就会扩展直到包含使用 clear 属性的元素，因此也会包含该元素上面的浮动兄弟元素，这样便解决了容器高度塌陷的问题。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>要给包含浮动的元素使用 clear 属性，即浮动元素本身或包含浮动元素后面的兄弟元素，而不是给别的元素。使用 clear 属性来清除浮动时有多种情况。</p><h4 id="如果浮动的元素后面有兄弟元素"><a href="#如果浮动的元素后面有兄弟元素" class="headerlink" title="如果浮动的元素后面有兄弟元素"></a>如果浮动的元素后面有兄弟元素</h4><p>设兄弟元素为块级元素并使用 clear 属性。</p><h4 id="如果浮动的元素是最后一个元素，后面没有兄弟元素"><a href="#如果浮动的元素是最后一个元素，后面没有兄弟元素" class="headerlink" title="如果浮动的元素是最后一个元素，后面没有兄弟元素"></a>如果浮动的元素是最后一个元素，后面没有兄弟元素</h4><p>将一个空的块级元素放在浮动元素的父元素容器的末尾，并对空的块级元素使用 clear 属性。这种方法能实现预期行为但是不雅：要在 HTML 里添加不必要的标记，才能实现本应该由 CSS 实现的效果。</p><h4 id="如果浮动的元素是最后一个元素，后面没有兄弟元素，但不想用额外的元素"><a href="#如果浮动的元素是最后一个元素，后面没有兄弟元素，但不想用额外的元素" class="headerlink" title="如果浮动的元素是最后一个元素，后面没有兄弟元素，但不想用额外的元素"></a>如果浮动的元素是最后一个元素，后面没有兄弟元素，但不想用额外的元素</h4><p>使用伪元素：对伪元素使用 clear 属性并设伪元素为块级元素或行内块级元素。使用 ::after 伪元素选择器，可以快速地在 DOM 中在容器末尾添加一个元素，而不用在 HTML 里添加标记，推荐该方法。注意，伪元素选择器生效显示需要添加 content 属性。</p><h3 id="修改版"><a href="#修改版" class="headerlink" title="修改版"></a>修改版</h3><p>普通的清除浮动可能还有一个一致性问题没有解决：浮动元素的外边距并不会折叠到清除浮动容器的外部，非浮动元素的外边距则会正常折叠。因此，建议使用伪元素的一个修改版，它能够包含所有的外边距，这样更符合预期。</p><p>在修改版中，设置块级元素时改用<code>display: table</code>而不用<code>display:block</code>。而且是给 ::before 和 ::after 两个伪元素都加上这一属性（但还是只对 ::after 用<code>clear: both</code>）。这样，容器所有子元素的外边距都会包含在容器的顶部和底部之间。当我们不想要外边距折叠时，此版本非常有用，但用什么版本取决于你。</p><p>在清除浮动时使用<code>display: table</code>能够包含外边距，是利用了 CSS 的一些特性。创建一个 <code>display: table</code>元素，也就在元素内隐式创建了一个表格行和一个单元格。因为外边距无法通过单元格元素折叠，所以也无法通过设置了<code>display: table</code>的伪元素折叠。</p><p>看起来似乎使用<code>display: table-cell</code>也能达到相同的效果，但是 clear 属性只对块级元素生效。表格是块级元素，但单元格并不是。因此，clear 属性无法跟<code>display: table-cell</code>一起使用。所以要用 <code>display: table</code>来清除浮动，同时利用隐式创建单元格来包含外边距。</p><h2 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h2>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS之单位</title>
    <link href="/2021/09/26/CSS%E4%B9%8B%E5%8D%95%E4%BD%8D/"/>
    <url>/2021/09/26/CSS%E4%B9%8B%E5%8D%95%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://juejin.cn/post/6844903630655471624">https://juejin.cn/post/6844903630655471624</a> 。</li><li><a href="https://book.douban.com/subject/35021471/">《深入解析 CSS》</a> 。</li></ul><h1 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h1><p>长度：一种用于测量距离的 CSS 值的正式称谓，它由一个数值和一个单位组成。<br>长度有两种类型：<strong>绝对长度</strong>和<strong>相对长度</strong>。百分比类似于长度，但是严格来讲，它不是长度。</p><ul><li>绝对单位：值放在哪里都一样大。</li><li>相对单位：值会根据外部因素发生变化，浏览器会根据相对单位的值计算出绝对值，称作计算值。</li></ul><h2 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h2><p>一般应在输出尺寸已知时使用绝对长度。<br>换算：1<code>in</code> = 25.4<code>mm</code> = 2.54<code>cm</code> = 6<code>pc</code> = 72<code>pt</code> = 96<code>px</code>。</p><h3 id="px（像素）"><a href="#px（像素）" class="headerlink" title="px（像素）"></a>px（像素）</h3><p>像素是最常用、最基础的长度单位。</p><p>像素是一个具有误导性的名称，CSS 像素并不严格等于显示器的像素，尤其是在高清屏视网膜屏下。尽管 CSS 单位会根据浏览器、操作系统或硬件适当缩放，在某些设备或用户的分辨率设置下也会发生变化，但是 96px 通常等于一个物理英寸的大小。</p><p>某种设备上一个像素的大小<strong>不一定</strong>与另一种设备上一个像素的大小完全相等。</p><h3 id="mm（毫米）"><a href="#mm（毫米）" class="headerlink" title="mm（毫米）"></a>mm（毫米）</h3><h3 id="cm（厘米）"><a href="#cm（厘米）" class="headerlink" title="cm（厘米）"></a>cm（厘米）</h3><h3 id="in（英尺）"><a href="#in（英尺）" class="headerlink" title="in（英尺）"></a>in（英尺）</h3><h3 id="pt（点）"><a href="#pt（点）" class="headerlink" title="pt（点）"></a>pt（点）</h3><p>印刷术语</p><h3 id="pc（派卡）"><a href="#pc（派卡）" class="headerlink" title="pc（派卡）"></a>pc（派卡）</h3><p>印刷术语</p><h2 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h2><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>em 是最常见的相对长度单位，适合基于特定的字号进行排版。<br>在 CSS 中，1em 等于当前元素的字号，其准确值取决于作用的元素的字号属性值（font-size 属性值）。</p><p>设置 padding、height、width、border-radius 等属性时使用 em 会很方便。这是因为当元素继承不同的字号或用户改变了字体设置时，这些属性会跟着元素均匀地缩放。</p><p>em 用在内边距、外边距及元素大小上很好，但用在字号上就会很复杂。</p><h4 id="em-定义字号"><a href="#em-定义字号" class="headerlink" title="em 定义字号"></a>em 定义字号</h4><p>谈到 font-size 属性时，em 表现得不太一样。当前元素的字号决定了 em。使用 em 定义某元素字号时，font-size 将根据继承的字号（父元素的字号）来计算。</p><p>对大多数浏览器来说，默认的字号为 16px。准确地说，medium 关键字的值是 16px。</p><p>em 的复杂之处在于同时用它指定一个元素的字号和其他属性。这时，浏览器必须先算字号，然后使用这个计算值去算出其余的属性值。这两类属性可以拥有一样的声明值，但是计算值不一样。</p><p>当用 em 来指定多重嵌套的元素的字号时就会产生意外的结果。为了算出每个元素准确值，就需要知道继承的字号，如果这个值是在父元素上用 em 定义的，就需要知道父元素的继承值，以此类推，就会沿着 DOM 树一直往上查找。如当列表多级嵌套并且给每一级使用 em 定义字号时，就会发生文字缩小的现象。</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem 是 root em 缩写。rem 不是相对当前元素，而是相对于根元素的单位。不管在文档什么位置使用 rem，1.2rem 都会有相同的计算值：1.2 乘以根元素的字号。由于默认的字号对某些用户而言很重要，尤其是对视力受损的人，故应该始终用相对单位或者百分比设置字号。</p><p>对大多数浏览器来说，根元素字号默认为 16px。准确地说，medium 关键字的值是 16px。</p><p>与 em 相比 rem 降低了复杂性。实际上 rem 结合了 px 和 em 的优点，既保留了相对单位优势又简单易用。那是不是应该全用 rem 抛弃其他选择呢？答案是否定的。在 CSS 里，答案通常是“看情况”。rem 只是工具包中的一种工具。掌握 CSS 很重要一点是学会在适当的场景使用适当的工具。</p><p><strong>拿不准时，一般用 rem 设置字号，px 设置边框，em 设置其他大部分属性，尤其是内边距、外边距和圆角。</strong>这样字号可预测，同时还能在其他因素改变元素字号时，借助 em 缩放内外边距。用 px 定义边框也很好用，尤其是想要一个好看又精致线时。这些都是在设置各种属性时常用单位，但是它们仅是工具，在某些情况下用其他工具更好。</p><ul><li>px2rem：Webpack 中使用<code>px2rem-loader</code>或<code>postcss-loader</code>。</li></ul><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口相对单位：相对浏览器视口定义长度的单位。<br>视口：浏览器窗口里网页可见部分边框区域，不包括浏览器的地址栏、工具栏、状态栏等。</p><ul><li>vh：视口高度的 1/100。</li><li>vw：视口宽度的 1/100。</li><li>vmin：视口宽、高中较小的一方的 1/100。</li><li>vmax：视口宽、高中较大的一方的 1/100。</li></ul><h4 id="不起眼的用途：设置字号"><a href="#不起眼的用途：设置字号" class="headerlink" title="不起眼的用途：设置字号"></a>不起眼的用途：设置字号</h4><p>相对视口单位还有一个不起眼的用途就是设置字号，可以发现它比用 vh 和 vw 设置元素宽和高还要实用。</p><p><code>calc()</code> 函数内可以对两个及其以上的值进行基本运算。当要结合不同单位的值时，<code>calc()</code> 特别实用。它支持的运算包括：加（+）、减（−）、乘（×）、除（÷）。加号和减号两边必须有空白，因此建议养成在每个操作符的前后都加上一个空格的习惯。</p><p>可以用 <code>calc()</code> 函数结合 em 和 vw 两种单位定义 font-size，打开网页，慢慢缩放浏览器，字体平滑地缩放。em 保证最小字号，vw 确保字体会随着视口缩放。我们不用媒体查询就能实现大部分响应式策略。不仅省掉三四个硬编码的断点，而且网页上的内容也能由视口流畅地缩放。</p><h1 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h1><p>百分比类似于长度，但是严格来讲，它不是长度。<br>需要知道的是，在 CSS 中，子元素中的百分比到底是谁的百分比。需要分情况讨论。</p><h2 id="height、width"><a href="#height、width" class="headerlink" title="height、width"></a>height、width</h2><p>在子元素的 height 当中使用百分比，是相对于直接父元素的 height。</p><p>在子元素的 width 当中使用百分比，是相对于直接父元素的 width。</p><h2 id="top、bottom-、left、right"><a href="#top、bottom-、left、right" class="headerlink" title="top、bottom 、left、right"></a>top、bottom 、left、right</h2><p>在子元素的 top 和 bottom 当中使用百分比，是相对于直接非static定位（非默认定位）的父元素的 height。</p><p>在子元素的 left 和 right 当中使用百分比，是相对于直接非static定位（非默认定位）的父元素的 width。</p><h2 id="padding、margin"><a href="#padding、margin" class="headerlink" title="padding、margin"></a>padding、margin</h2><p>在子元素的 padding 当中使用百分比，不论是垂直方向或者是水平方向，都是相对于直接父元素的 width，而与父元素的 height 无关。</p><p>在子元素的 margin 当中使用百分比，不论是垂直方向或者是水平方向，都是相对于直接父元素的 width， 而与父元素的 height 无关。</p><h2 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h2><p>在子元素的 border-radius 当中使用百分比，是相对于子元素自身的 width。</p><p>除了 border-radius 外，还有比如 translate、background-size 等都是相对于子元素自身的 width。</p><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><ul><li>HSL</li><li>RGB</li><li>RGBA</li><li>HSLA</li><li>十六进制（通常称 hex）</li></ul><h1 id="无单位"><a href="#无单位" class="headerlink" title="无单位"></a>无单位</h1><p>有些属性允许无单位的值（即一个不指定单位的数）。支持这种值的属性包括 font-weight 、line-height、 z-index（700 等于 bold，400 等于 normal 等）。任何的长度单位（px、rem 等）都可以用无单位的值 0，因为这些情况下单位不影响计算值，即 0px、0%、0em 均相等。</p><p>一个无单位的 0 只能用于长度和百分比，比如内边距、边框和宽度，而不能用于角度值，比如度，或者时间相关的值，比如秒。</p><p>line-height 属性比较特殊，它的值既可以有单位也可以无单位。<br>通常我们应使用无单位数值，因为它们继承的方式不一样。</p><p>继承的一个怪异特性：当一个元素的值定义为长度（px、em、rem 等等）时，子元素就会继承它的计算值。当使用 em 等单位定义行高时它们的值是计算值，传递到了任何继承子元素上。如果子元素有不同的字号，且继承 line-height 属性，就会造成意想不到的结果，如文字重叠。</p><p>使用无单位的数值时，继承的是声明值，即在每个继承子元素上会重新算它的计算值。这样得到的结果几乎总是我们想要的。我们可以用一个无单位的数值来给 body 设置行高，之后则不用修改，除非有些地方想要不一样的行高。</p><h1 id="自定义属性（CSS变量）"><a href="#自定义属性（CSS变量）" class="headerlink" title="自定义属性（CSS变量）"></a>自定义属性（CSS变量）</h1><p><strong>层叠变量的自定义属性</strong>给CSS引进了变量的概念，开启了一种全新的基于上下文的动态样式。你可以声明一个变量，为它赋一个值，然后在样式表的其他地方引用这个值。这样不仅能减少样式表中的重复，而且还有其他好处。</p><p>如果刚好用了内置变量功能的CSS预处理器，比如 Sass 或者 Less，你可能就不太想用 CSS 变量了。千万别这样。CSS 变量和它们有本质上的区别，它比任何一款预处理器的变量功能都多。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>要定义一个自定义属性，只需要像其他 CSS 属性那样声明即可。</p><p>变量名前面必须有两个连字符（–），用来跟 CSS 属性区分，剩下的部分可以随意命名，且变量必须在一个声明块内声明。如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">main</span>-<span class="hljs-attribute">font</span>: Helvetica, Arial, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>调用 <code>var()</code> 函数就能使用自定义属性（CSS变量）。其还接受第二个参数，用于指定备用值。如果第一个参数指定的变量未定义，那么就会使用第二个值。如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">main</span>-<span class="hljs-attribute">font</span>: Helvetica, Arial, sans-serif;<br>  --brand-<span class="hljs-attribute">color</span>: <span class="hljs-number">#369</span>;<br>&#125;<br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-built_in">var</span>(--main-font);<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--second-color, blue);<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，如果 <code>var()</code> 函数算出来的是一个非法值，对应的属性就会设置为其初始值。</p><h2 id="动态改变"><a href="#动态改变" class="headerlink" title="动态改变"></a>动态改变</h2><p>自定义属性不只是为减少重复代码提供了一种便捷方式，它真正的意义在于，自定义属性的声明能够层叠和继承：可以在多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。</p><p>例如，可以定义一个变量为黑色，然后在某个容器中重新将其定义为白色。那么基于该变量的任何样式，在容器外部会动态解析为黑色，在容器内部会动态解析为白色。</p><p>自定义属性就像作用域变量一样，因为它的值会被后代元素继承。</p><h2 id="使用-JS-改变"><a href="#使用-JS-改变" class="headerlink" title="使用 JS 改变"></a>使用 JS 改变</h2><p>还可以使用 JavaScript 在浏览器中实时访问和修改自定义属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.documentElement;<br><span class="hljs-keyword">const</span> styles = getComputedStyle(rootElement);<br><span class="hljs-keyword">const</span> mainColor = styles.getPropertyValue(<span class="hljs-string">&#x27;--main-font&#x27;</span>);<br><span class="hljs-built_in">console</span>.lot(<span class="hljs-built_in">String</span>(mainColor).trim());<br></code></pre></td></tr></table></figure><h2 id="探索自定义属性"><a href="#探索自定义属性" class="headerlink" title="探索自定义属性"></a>探索自定义属性</h2><p>自定义属性是CSS中一个全新的领域，开发人员刚刚开始探索。因为浏览器支持有限，所以还没有出现“典型”的用法。</p><p>值得注意的是，在不支持自定义属性的浏览器上，任何使用 <code>var()</code> 的声明都会被忽略。需要为这些浏览器提供回退方案。</p>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域</title>
    <link href="/2021/09/25/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2021/09/25/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://juejin.cn/post/6844903767226351623">https://juejin.cn/post/6844903767226351623</a> 。</li><li><a href="https://juejin.cn/post/6844904126246027278">https://juejin.cn/post/6844904126246027278</a> 。</li></ul><h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。一个域名地址由 <strong>协议、子域名、主域名、端口号、请求资源地址</strong> 组成。所谓同源是指 <strong>“协议+域名+端口”</strong> 三者相同，即便两个不同的域名指向同一个 IP 地址，也非同源。</p><p>同源策略限制内容有：</p><ul><li>Cookie、WebStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 通信请求</li></ul><p>有三个标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><h2 id="跨域场景"><a href="#跨域场景" class="headerlink" title="跨域场景"></a>跨域场景</h2><p>当<strong>协议</strong>、<strong>子域名</strong>、<strong>主域名</strong>、<strong>端口号</strong>中任意一个不相同时，都算不同域。不同域之间相互请求资源为“跨域”。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E5%9C%BA%E6%99%AF.jpg" alt="常见跨域场景（来自掘金@浪里行舟）"></p><p>特别说明两点：</p><ul><li><p>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的。</p></li><li><p>第二，在跨域问题上，仅仅是通过“URL的首部”来识别，而不会根据域名对应的IP地址是否相同来判断。（“URL的首部”可以理解为“协议、域名、端口三者必须匹配”）</p></li></ul><p>请求跨域了，那么请求到底发出去没有？</p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</strong>你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会？因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求是发出了。</p><h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用<code>&lt;script&gt;</code>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。</p><p>JSONP 和 AJAX 都是客户端向服务器端发送请求，从服务器端获取数据的方式。<br>但是，AJAX 属于同源策略，JSONP 属于非同源策略（跨域请求）。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是其仅支持 GET 方法具有局限性，而且不安全，可能会遭受 XSS 攻击。想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。</p><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><p>1.前端定义解析函数（例如 jsonpCallback = function(){….}）。<br>2.通过 params 形式包装请求参数，并且声明执行函数（例如 cb = jsonpCallback）。<br>3.后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。</p><ul><li>声明一个回调函数，其函数名（如 show）当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据（服务器返回的 data）。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src，还要在这个地址中向服务器传递该函数名（可以通过问号传参：?callback=show）。</li><li>服务器接收到请求后，进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串，例如：传递进去的函数名是 show，它准备好的数据是 show（’我不爱你’）。</li><li>最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前的回调函数（show），对返回的数据进行操作。</li></ul><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，可以自己封装一个 JSONP 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 前端</span><br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;  <br>  <span class="hljs-built_in">window</span>.jsonpCallback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(res);  <br>  &#125;;<br>&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/api/jsonp?msg=hello&amp;cb=jsonpCallback&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="hljs-comment">// 后端</span><br><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa&quot;</span>), fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>), app = <span class="hljs-keyword">new</span> Koa();<br>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (ctx.path === <span class="hljs-string">&quot;/api/jsonp&quot;</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; cb, msg &#125; = ctx.query;    <br>    ctx.body = <span class="hljs-string">`<span class="hljs-subst">$&#123;cb&#125;</span>(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(&#123; msg &#125;)&#125;</span>)`</span>;    <br>    <span class="hljs-keyword">return</span>;  <br>  &#125;<br>&#125;);<br>app.listen(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 前端</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    <span class="hljs-built_in">window</span>[callback] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<br>      resolve(data)<br>      <span class="hljs-built_in">document</span>.body.removeChild(script)<br>    &#125;<br>    params = &#123; ...params, callback &#125; <span class="hljs-comment">// wd=b&amp;callback=show</span><br>    <span class="hljs-keyword">let</span> arrs = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      arrs.push(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>`</span>)<br>    &#125;<br>    script.src = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;arrs.join(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span>;<br>    <span class="hljs-built_in">document</span>.body.appendChild(script);<br>  &#125;)<br>&#125;<br>jsonp(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/say&#x27;</span>,<br>  <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">wd</span>: <span class="hljs-string">&#x27;Iloveyou&#x27;</span> &#125;,<br>  <span class="hljs-attr">callback</span>: <span class="hljs-string">&#x27;show&#x27;</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;)<br><span class="hljs-comment">// 后端</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">let</span> app = express();<br>app.get(<span class="hljs-string">&#x27;/say&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> &#123; wd, callback &#125; = req.query;<br>  <span class="hljs-built_in">console</span>.log(wd); <span class="hljs-comment">// Iloveyou</span><br>  <span class="hljs-built_in">console</span>.log(callback); <span class="hljs-comment">// show</span><br>  res.end(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;我不爱你&#x27;)`</span>);<br>&#125;)<br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后端返回 show(‘我不爱你’)，最后会运行 show() 这个函数，打印出’我不爱你’。</p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>跨域资源共享（CORS）是一种机制，它使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器 「不同的域、协议或端口」请求一个资源时，资源会发起一个「跨域 HTTP 请求」。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就能够实现跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS，该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>不会触发“CORS预检请求”，这样的请求为“简单请求”。同时满足以下五个条件，就属于简单请求。</p><p>条件1，使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>条件2，人为设置以下集合外的请求头：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type （需要注意额外的限制）</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul><p>条件3，Content-Type 的值仅限于下列三者之一：</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>条件4：<br>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><p>条件5：<br>请求中没有使用 ReadableStream 对象。</p><h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3><p>不符合简单请求的就是复杂请求。复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求，该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><h3 id="前端示例"><a href="#前端示例" class="headerlink" title="前端示例"></a>前端示例</h3><p>仅显示前端部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;&lt;/script&gt;<br><br><span class="hljs-comment">// 简单请求</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  </span></span><br><span class="javascript"><span class="xml">  axios.get(<span class="hljs-string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// 复杂请求</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  </span></span><br><span class="javascript"><span class="xml">  axios.get(<span class="hljs-string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>, &#123; <span class="hljs-attr">headers</span>: &#123; <span class="hljs-attr">cc</span>: <span class="hljs-string">&quot;xxx&quot;</span> &#125; &#125;);</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 （两个页面的模数 Document.domain设置为相同的值）时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p><p>window.postMessage() 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的 iframe 消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>window.postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以用来实现跨文本档、多窗口、跨域消息传递。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p><ul><li>otherWindow：其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames。</li><li>message: 将要发送到其他 window 的数据。</li><li>targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件。</li><li>transfer（可选） : 是一串和 message 同时传递的 Transferable 对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.html</span><br>&lt;iframe src=<span class="hljs-string">&quot;http://localhost:4000/b.html&quot;</span> frameborder=<span class="hljs-string">&quot;0&quot;</span> id=<span class="hljs-string">&quot;frame&quot;</span> onload=<span class="hljs-string">&quot;load()&quot;</span>&gt;&lt;<span class="hljs-regexp">/iframe&gt; /</span><span class="hljs-regexp">/ 等它加载完触发一个事件</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/ 内嵌在http:/</span><span class="hljs-regexp">/localhost:3000/</span>a.html<br>&lt;script&gt;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;frame&#x27;</span>)<br>  frame.contentWindow.postMessage(<span class="hljs-string">&#x27;我爱你&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000&#x27;</span>) <span class="hljs-comment">// 发送数据</span><br>  <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-comment">// 接受返回数据</span><br>    <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// 我不爱你</span><br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// b.html</span><br>&lt;script&gt;<br><span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// 我爱你</span><br>  e.source.postMessage(<span class="hljs-string">&#x27;我不爱你&#x27;</span>, e.origin)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”，后者传回”我不爱你”。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>WebSocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关。</p><p>原生 WebSocket API 使用起来不太方便，可以使用<code>Socket.io</code>，它很好地封装了 WebSocket 接口，提供了更简单、灵活的接口，也对不支持 WebSocket 的浏览器提供了向下兼容。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>本地文件<code>socket.html</code>向<code>localhost:3000</code>发生数据和接受数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// socket.html</span><br>&lt;script&gt;<br><span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&#x27;ws://localhost:3000&#x27;</span>);<br>socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  socket.send(<span class="hljs-string">&#x27;我爱你&#x27;</span>); <span class="hljs-comment">// 向服务器发送数据</span><br>&#125;<br>socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(e.data); <span class="hljs-comment">// 接收服务器返回的数据</span><br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">let</span> app = express();<br><span class="hljs-keyword">let</span> WebSocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ws&#x27;</span>); <span class="hljs-comment">// 记得安装ws</span><br><span class="hljs-keyword">let</span> wss = <span class="hljs-keyword">new</span> WebSocket.Server(&#123;<span class="hljs-attr">port</span>:<span class="hljs-number">3000</span>&#125;);<br>wss.on(<span class="hljs-string">&#x27;connection&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ws</span>) </span>&#123;<br>  ws.on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>    ws.send(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)<br>  &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用原生 WebSocket API。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 前端部分</span><br>&lt;script&gt;  <br><span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);  <br>socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <br>  socket.send(<span class="hljs-string">&quot;秋风的笔记&quot;</span>);  <br>&#125;;  <br>socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <br>  <span class="hljs-built_in">console</span>.log(e.data);  <br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 后端部分</span><br>&lt;script&gt;<br><span class="hljs-keyword">const</span> WebSocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> WebSocket.Server(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> &#125;);<br>server.on(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>) </span>&#123;  <br>  socket.on(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;    <br>    socket.send(data);  <br>  &#125;);<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>（略）见：<a href="https://juejin.cn/post/6844903767226351623#heading-16%E3%80%82">https://juejin.cn/post/6844903767226351623#heading-16。</a></p>]]></content>
    
    
    <categories>
      
      <category>运行环境</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack面试题</title>
    <link href="/2021/09/25/Webpack%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/09/25/Webpack%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844904094281236487">https://juejin.cn/post/6844904094281236487</a> 。<br><a href="https://juejin.cn/post/6943468761575849992">https://juejin.cn/post/6943468761575849992</a> 。</p><h2 id="Webpack的作用是什么？"><a href="#Webpack的作用是什么？" class="headerlink" title="Webpack的作用是什么？"></a>Webpack的作用是什么？</h2><ul><li>模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用好打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。</li><li>编译兼容。在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过 Webpack 的 Loader 机制，不仅仅可以帮助我们对代码做 polyfill，还可以编译转换诸如 .less、.vue、.jsx 这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。</li><li>能力扩展。通过 Webpack 的 Plugin 机制，在实现模块化打包和编译兼容的基础上，可以进一步实现如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。</li></ul><h2 id="Webpack构建流程"><a href="#Webpack构建流程" class="headerlink" title="Webpack构建流程"></a>Webpack构建流程</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ul><li>初始化参数<br>从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li>开始编译<br>用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li>确定入口<br>根据配置中的 Entry 找出所有的入口文件</li><li>编译模块<br>从入口文件出发，调用所有配置的 Loader 对模块进行翻译，找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译<br>经过上一步使用 Loader 翻译完所有模块后，得到每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li>输出资源<br>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，然后把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>输出完成<br>在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><p>简洁版：</p><ul><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。</li><li>编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理。</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中。</li></ul><h2 id="Loader和Plugin的区别？"><a href="#Loader和Plugin的区别？" class="headerlink" title="Loader和Plugin的区别？"></a>Loader和Plugin的区别？</h2><p>Loader 是函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p><p>Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test（类型文件）、loader、options （参数）等属性。</p><p>Plugin 是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p>Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p><h2 id="有哪些常见的Loader？"><a href="#有哪些常见的Loader？" class="headerlink" title="有哪些常见的Loader？"></a>有哪些常见的Loader？</h2><p>Loader 官网：<a href="https://webpack.docschina.org/loaders">https://Webpack.docschina.org/loaders</a> 。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>val-loader：将代码作为模块执行，并将其导出为 JS 代码</li><li>ref-loader：用于手动建立文件之间的依赖关系</li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul><li>cson-loader：加载并转换 CSON 文件</li></ul><h3 id="语法转换"><a href="#语法转换" class="headerlink" title="语法转换"></a>语法转换</h3><ul><li>babel-loader：把 ES6 转换成 ES5</li><li>buble-loader：使用 Bublé 加载 ES2015+ 代码并将其转换为 ES5</li><li>traceur-loader：使用 Traceur 加载 ES2015+ 代码并将其转换为 ES5</li><li>ts-loader：像加载 JavaScript 一样加载 TypeScript 2.0+</li><li>coffee-loader：像加载 JavaScript 一样加载 CoffeeScript</li><li>fengari-loader：使用 fengari 加载 Lua 代码</li><li>elm-webpack-loader：像加载 JavaScript 一样加载 Elm</li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>html-loader：将 HTML 导出为字符串，需要传入静态资源的引用路径</li><li>pug-loader：加载 Pug 和 Jade 模板并返回一个函数</li><li>markdown-loader：将 Markdown 编译为 HTML</li><li>react-markdown-loader：使用 markdown-parse 解析器将 Markdown 编译为 React 组件</li><li>posthtml-loader：使用 PostHTML 加载并转换 HTML 文件</li><li>handlebars-loader：将 Handlebars 文件编译为 HTML</li><li>markup-inline-loader：将 SVG/MathML 文件内嵌到 HTML 中。在将图标字体或 CSS 动画应用于 SVG 时，此功能非常实用。</li><li>twig-loader：编译 Twig 模板并返回一个函数</li><li>remark-loader：通过 remark 加载 markdown，且支持解析内容中的图片</li></ul><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li>style-loader：将模块导出的内容作为样式并添加到 DOM 中，通过 DOM 操作去加载 CSS</li><li>css-loader：加载 CSS 文件并解析 import 的 CSS 文件，最终返回 CSS 代码，支持模块化、压缩、文件导入等特性</li><li>less-loader：加载并编译 LESS 文件</li><li>sass-loader：加载并编译 SASS/SCSS 文件</li><li>postcss-loader：使用 PostCSS 加载并转换 CSS/SSS 文件，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li><li>stylus-loader：加载并编译 Stylus 文件</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li>vue-loader：加载并编译 Vue 组件</li><li>angular2-template-loader：加载并编译 Angular 组件</li></ul><h3 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h3><ul><li>awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li><li>tslint-loader：通过 TSLint检查 TypeScript 代码</li><li>mocha-loader：加载 Mocha 测试用例的代码</li><li>coverjs-loader：计算测试的覆盖率</li><li>i18n-loader: 国际化</li><li>cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li><li>file-loader</li><li>url-loader</li></ul><h2 id="有哪些常见的Plugin？"><a href="#有哪些常见的Plugin？" class="headerlink" title="有哪些常见的Plugin？"></a>有哪些常见的Plugin？</h2><p>Plugin 官网：<a href="https://webpack.docschina.org/plugins">https://Webpack.docschina.org/plugins</a> 。</p><ul><li>define-plugin：定义环境变量 （Webpack4 之后指定 mode 会自动配置）</li><li>ignore-plugin：忽略部分文件</li><li>html-Webpack-plugin：简化 HTML 文件创建 （依赖于 html-loader）</li><li>web-Webpack-plugin：可方便地为单页应用输出 HTML，比 html-Webpack-plugin 好用</li><li>uglifyjs-Webpack-plugin：不支持 ES6 压缩 （Webpack4 以前）</li><li>terser-Webpack-plugin: 支持压缩 ES6 （Webpack4）</li><li>Webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度</li><li>mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载<br>（替代extract-text-Webpack-plugin）</li><li>serviceworker-Webpack-plugin：为网页应用增加离线缓存功能</li><li>clean-Webpack-plugin: 目录清理</li><li>ModuleConcatenationPlugin: 开启 Scope Hoisting</li><li>speed-measure-Webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时<br>（整个打包耗时、每个 Plugin 和 Loader 耗时）</li><li>Webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 （业务组件、依赖第三方模块）</li></ul><h2 id="文件监听原理"><a href="#文件监听原理" class="headerlink" title="文件监听原理"></a>文件监听原理</h2><p>在发现源码发生变化时，自动重新构建出新的输出文件。</p><p>Webpack开启监听模式，有两种方式：</p><ul><li>启动 Webpack 命令时，带上 –watch 参数</li><li>在配置 Webpack.config.js 中设置 watch:true</li></ul><p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等<code>aggregateTimeout</code>后再执行。</p><p>缺点：每次需要手动刷新浏览器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.export = &#123;    <br>  <span class="hljs-comment">// 默认false,也就是不开启    </span><br>  <span class="hljs-attr">watch</span>: <span class="hljs-literal">true</span>,    <br>  <span class="hljs-comment">// 只有开启监听模式时，watchOptions才有意义    </span><br>  <span class="hljs-attr">watchOptions</span>: &#123;        <br>    <span class="hljs-comment">// 默认为空，不监听的文件或者文件夹，支持正则匹配        </span><br>    <span class="hljs-attr">ignored</span>: <span class="hljs-regexp">/node_modules/</span>,        <br>    <span class="hljs-comment">// 监听到变化发生后会等300ms再去执行，默认300ms        </span><br>    aggregateTimeout:<span class="hljs-number">300</span>,        <br>    <span class="hljs-comment">// 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次</span><br>    <span class="hljs-attr">poll</span>:<span class="hljs-number">1000</span>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h2><p>Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。这个机制可以做到不用人刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>HMR 的核心就是客户端从服务端拉去更新后的文件，准确的来说是 chunk diff（chunk 需要更新的部分），实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容（文件列表、hash），这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新。</p><p>后续的部分（拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？）是由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像 react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。</p>]]></content>
    
    
    <categories>
      
      <category>框架和类库</category>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>框架和类库</tag>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数组去重</title>
    <link href="/2021/09/23/JavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <url>/2021/09/23/JavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://juejin.cn/post/6844903602197102605">https://juejin.cn/post/6844903602197102605</a> 。 </p><h1 id="Set与扩展操作符去重"><a href="#Set与扩展操作符去重" class="headerlink" title="Set与扩展操作符去重"></a>Set与扩展操作符去重</h1><p>ES6 新增数据类型 Set，Set 一个最大的特点就是数据不重复。Set() 构造函数可以接受一个数组（或类数组）作为参数来初始化，利用该特性和扩展操作符能够做到给数组去重。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123; <br>  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arr)];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Set与Array-from-方法去重"><a href="#Set与Array-from-方法去重" class="headerlink" title="Set与Array.from()方法去重"></a>Set与Array.from()方法去重</h1><p>原理同上，不过使用的是<code>Array.from()</code>方法，该方法可以将可迭代对象转换为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="indexOf-方法去重1"><a href="#indexOf-方法去重1" class="headerlink" title="indexOf()方法去重1"></a>indexOf()方法去重1</h1><p><code>indexOf()</code>方法可返回某个指定的元素在数组中首次出现的位置。先定义一个空数组 res，然后调用<code>indexOf()</code>方法对原来的数组进行遍历判断，如果元素不在 res 中，则将其放进 res 中，最后将 res 返回即可获得去重后的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  arr.forEach(<span class="hljs-function"><span class="hljs-params">ele</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (res.indexOf(ele) === -<span class="hljs-number">1</span>) res.push(ele);<br>  &#125;)<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="indexOf-方法去重2"><a href="#indexOf-方法去重2" class="headerlink" title="indexOf()方法去重2"></a>indexOf()方法去重2</h1><p>利用<code>indexOf()</code>方法检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素。<code>filter</code>方法返回就是数组，不用定义空数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">ele, index</span>) =&gt;</span> arr.indexOf(ele) === index);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相邻元素去重"><a href="#相邻元素去重" class="headerlink" title="相邻元素去重"></a>相邻元素去重</h1><p>首先用数组的排序方法<code>sort()</code>，然后根据排序后的结果进行遍历及相邻元素比对，如果相等则跳过改元素，直到遍历结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  arr = arr.sort();<br>  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">ele, index</span>) =&gt;</span> ele !== arr[index + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="利用对象去重"><a href="#利用对象去重" class="headerlink" title="利用对象去重"></a>利用对象去重</h1><p>创建一个空对象和一个空数组，之后遍历原数组，将原数组中的值设为对象的属性，并给该属性赋初始值1，每出现一次，对应的属性值增加1，这样，对应的属性值就是该元素出现的次数。（可以去掉 else 部分）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [], obj = &#123;&#125;;<br>  arr.forEach(<span class="hljs-function"><span class="hljs-params">ele</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj[ele]) &#123;<br>      res.push(ele);<br>      obj[ele] = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 可以去掉 else 部分</span><br>      obj[ele]++; <br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 Map：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [], map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  arr.forEach(<span class="hljs-function"><span class="hljs-params">ele</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!map.has(ele)) &#123;<br>      res.push(ele);<br>      map.set(ele, <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 可以去掉 else 部分</span><br>      map.set(ele, map.get(ele) + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 Set：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [], set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  arr.forEach(<span class="hljs-function"><span class="hljs-params">ele</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!set.has(ele)) &#123;<br>      set.add(ele);<br>      res.push(ele);<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双循环去重"><a href="#双循环去重" class="headerlink" title="双循环去重"></a>双循环去重</h1><p>双重 for 循环是比较笨拙的方法，原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组。因为它的时间复杂度是O(n^2)，如果数组长度很大，那么将会非常耗费内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = [arr[<span class="hljs-number">0</span>]];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; res.length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] === res[j]) &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) res.push(arr[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试题</title>
    <link href="/2021/09/23/HTML%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/09/23/HTML%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844904021308735502">https://juejin.cn/post/6844904021308735502</a> 。<br><a href="https://juejin.cn/post/6844903951377104903">https://juejin.cn/post/6844903951377104903</a> 。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="介绍-DOM-树"><a href="#介绍-DOM-树" class="headerlink" title="介绍 DOM 树"></a>介绍 DOM 树</h2><h2 id="标签语义化"><a href="#标签语义化" class="headerlink" title="标签语义化"></a>标签语义化</h2><ul><li>有利于构架良好的 HTML 结构，有利于搜索引擎的建立索引、抓取。</li><li>有利于不同设备的解析（屏幕阅读器，盲人阅读器等）。</li><li>有利于构建清晰的机构，有利于团队的开发、维护。</li></ul><h2 id="src属性和href属性"><a href="#src属性和href属性" class="headerlink" title="src属性和href属性"></a>src属性和href属性</h2><p>参考：<a href="https://juejin.cn/post/6875953466267664398">https://juejin.cn/post/6875953466267664398</a> 。</p><h3 id="src属性"><a href="#src属性" class="headerlink" title="src属性"></a>src属性</h3><p>src 是 source 的缩写，翻译为“来源、源头”。<br>src 指向外部资源的位置，src 指向的内容会嵌入到文档中当前标签所在的位置。<br>src 用在 script 标签、iframe 标签、img 标签、video 标签、audio 标签等等。</p><h3 id="href属性"><a href="#href属性" class="headerlink" title="href属性"></a>href属性</h3><p>href 是 hypertext reference 的缩写，翻译为“超文本引用”。<br>href 用来建立当前元素和文档之间的链接。<br>href 用在 link 标签、a 标签等等。</p><h2 id="link标签和-import"><a href="#link标签和-import" class="headerlink" title="link标签和@import"></a>link标签和@import</h2><ul><li>从属关系不同<br>link 标签除了加载 CSS 以外，还可以定义 RSS 等其他事物，@import 属于 CSS 范畴，只能加载 CSS。</li><li>加载顺序不同<br>link 标签引用 CSS 时在页面载入的同时进行加载，@import 需要等待网页全部加载完以后才进行加载。</li><li>兼容性不同<br>link 标签是标签，没有兼容性的问题，@import 是在 CSS2.1 之后提出的，低版本的浏览器并不支持。</li><li>DOM可控性不同<br>link 标签支持 Javascript 控制 DOM 改变样式，@import 不支持。</li></ul><h2 id="head标签里都有哪些标签"><a href="#head标签里都有哪些标签" class="headerlink" title="head标签里都有哪些标签"></a>head标签里都有哪些标签</h2><p>参考：<a href="https://juejin.cn/post/6987919006468407309">https://juejin.cn/post/6987919006468407309</a> 。</p><p><code>head</code>标签与<code>html</code>标签、<code>body</code>标签一样是一个文档必须的标签。<code>head</code>标签用于说明文档头部信息，它是所有头部标签的容器。<code>head</code>中的标签可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p><p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p><p>这些标签可用在 <code>head</code> 标签：<code>base</code>，<code>link</code>，<code>meta</code>，<code>script</code>，<code>style</code>，<code>title</code>等等。</p><h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><p>参考：<br><a href="https://juejin.cn/post/6844904099184377870">https://juejin.cn/post/6844904099184377870</a> 。<br><a href="https://juejin.cn/post/6987919006468407309">https://juejin.cn/post/6987919006468407309</a> 。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta</a> 。</p><p>meta标签是用来描述网页属性的一种语言，标准的meta标签可以便于搜索引擎排序，提高搜索引擎网站权重排名。</p><h2 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h2><p>CSS3 规范要达到 W3C 的推荐标准（即定稿）状态要经过数年。浏览器则通常在 W3C 开发标准的过程中就会提前实现这些特性。这样，标准在最终敲定之前就能知道哪些地方还能进一步改进。</p><p>在包含某个特性的初始阶段，浏览器通常会使用厂商前缀实现这类特性。如今，在多数情况下，我们一般只需要 -webkit 前缀，并非所有的 CSS3 属性都需要使用为浏览器准备的前缀。</p><ul><li>-moz-：代表firefox浏览器私有属性</li><li>-ms-：代表ie浏览器私有属性</li><li>-webkit-：代表safari、chrome私有属性</li><li>-o-：代表Opera私有属性</li></ul><h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><ul><li>为什么link标签放在头部，script标签放在尾部</li></ul><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="常见浏览器内核"><a href="#常见浏览器内核" class="headerlink" title="常见浏览器内核"></a>常见浏览器内核</h2><table><thead><tr><th>浏览器</th><th>内核（渲染引擎）</th><th>JavaScript 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink</td><td>V8</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>Edge</td><td>EdgeHTML</td><td>Chakra(for JavaScript)</td></tr><tr><td>IE</td><td>Trident</td><td>Chakra(for JScript)</td></tr><tr><td>PhantomJS</td><td>Webkit</td><td>JavaScriptCore</td></tr></tbody></table><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><p>参考：<br><a href="https://juejin.cn/post/6844903685122703367">https://juejin.cn/post/6844903685122703367</a> 。<br><a href="https://juejin.cn/post/6844903638532358151">https://juejin.cn/post/6844903638532358151</a> 。</p><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><p>参考：<br><a href="https://juejin.cn/post/6892994632968306702">https://juejin.cn/post/6892994632968306702</a> 。<br><a href="https://juejin.cn/post/6911472693405548557">https://juejin.cn/post/6911472693405548557</a> 。</p><h2 id="其它问题-1"><a href="#其它问题-1" class="headerlink" title="其它问题"></a>其它问题</h2><ul><li>跨域</li><li>同源策略</li><li>解析渲染页面</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复杂度</title>
    <link href="/2021/09/20/JavaScript%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2021/09/20/JavaScript%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844903750985842695">https://juejin.cn/post/6844903750985842695</a> 。<br><a href="https://github.com/biaochenxuying/blog/issues/29">https://github.com/biaochenxuying/blog/issues/29</a> 。</p><h1 id="什么是复杂度分析"><a href="#什么是复杂度分析" class="headerlink" title="什么是复杂度分析"></a>什么是复杂度分析</h1><p>复杂度分析是整个算法学习的精髓，使用数据结构与算法是为了能更快时间、更省空间地解决问题。因此，需要从  <strong>执行时间</strong> 和 <strong>占用空间</strong> 两个维度来评估数据结构与算法的性能。虽然我们能用代码准确的计算出执行时间，但是这也会有很多局限性。</p><ul><li>数据规模的不同会直接影响到测试结果。比如同一个排序算法，排序顺序不一样，那么最后的计算效率的结果也会不一样，而如果恰好已经是排序好的了数组，那么执行时间就会更短。又比如如果数据规模比较小的话，测试结果可能也无法反应算法的性能。</li><li>测试的环境不同也会影响到测试结果。比如同一套代码分别在 i3 和 i7 处理器上进行测试，那么 i7 上的测试时间肯定会比 i3 上的短。</li></ul><p>所以需要一个不用准确的测试结果来衡量，就可以粗略地估计代码执行时间的方法。这就是复杂度分析。</p><p>和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。</p><h1 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h1><p>估算下面代码的执行时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    sum += i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设每行代码执行的时间都一样记做 t，那么上面的函数中第 2 行需要 1 个 t 的时间，第 3 行 和 第 4 行分别需要 n 个 t 的时间，那么这段代码总的执行时间为 (2n+1)*t。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      sum = sum + i + j;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，第 2 行需要一个 t 的时间，第 3 行需要 n 个 t 的时间，第 4 行和第 5 行分别需要 n<sup>2</sup> 个的时间，那么这段代码总的执行时间为 (2n<sup>2</sup>+n+1)*t 的时间。</p><p>从数学角度来看，我们可以得出个规律：代码的总执行时间 T(n) 与每行代码的执行次数成正比。</p><blockquote><p>T(n) = O(f(n))</p></blockquote><p>在这个公式中，T(n) 表示每行代码总的执行时间，n 表示数据规模的大小，f(n) 表示每行代码执行次数总和，O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p>所以上面两个函数的执行时间可以标记为 T(n) = O(2n+1) 以及 T(n) = O(2n<sup>2</sup>+n+1)。这就是大 O 时间复杂度表示法，它不代表代码真正的执行时间，而是表示代码随数据规模增长的变化趋势，简称时间复杂度。</p><p>由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以 <strong>常量阶</strong> 、<strong>低阶</strong> 、<strong>系数</strong> 实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时 <strong>忽略</strong> 这些项。</p><p>而且当 n 很大时，我们可以忽略常数项，只保留一个最大量级。所以上面的代码执行时间可以简单标记为 T(n) = O(n) 和 T(n) = O(n<sup>2</sup>)。</p><h1 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h1><p>时间复杂度的全称是渐进时间复杂度，表示代码执行时间随数据规模增长的变化趋势。</p><p>算法的执行时间与每行代码的执行次数成正比，用 T(n) = O(f(n)) 表示，其中，T(n) 表示算法执行总时间，f(n) 表示每行代码执行总次数，而 n 往往表示数据的规模。</p><ul><li>最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度。</li><li>最坏情况时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度。</li><li>平均情况时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。<br>（也叫加权平均时间复杂度或期望时间复杂度。）</li></ul><h2 id="只关注循环执行次数最多的一段代码"><a href="#只关注循环执行次数最多的一段代码" class="headerlink" title="只关注循环执行次数最多的一段代码"></a>只关注循环执行次数最多的一段代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    sum += i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有第 3 行和第 4 行执行次数最多，分别执行了 n 次，那么忽略常数项，此段代码的时间复杂度就是 O(n)。</p><h2 id="加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>加法法则：总复杂度等于量级最大的那段代码的复杂度</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total</span>(<span class="hljs-params">n</span>) </span>&#123; <br>  <span class="hljs-comment">// 第一个 for 循环</span><br>  <span class="hljs-keyword">let</span> sum1 = <span class="hljs-number">0</span>; <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      sum1 = sum1 + i + j; <br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 第二个 for 循环</span><br>  <span class="hljs-keyword">let</span> sum2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    sum2 = sum2 + i;<br>  &#125;<br>  <span class="hljs-comment">// 第三个 for 循环</span><br>  <span class="hljs-keyword">let</span> sum3 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    sum3 = sum3 + i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一段 for 循环的时间复杂度为 O(n<sup>2</sup>)。<br>第二段 for 循环执行了 1000 次，是个常数量级，尽管对代码的执行时间会有影响，但是当 n 无限大的时候，就可以忽略。因为它本身对增长趋势没有影响，所以这段代码的时间复杂度可以忽略。<br>第三段 for 循环的时间复杂度为 O(n)。<br>总上，取最大量级，所以整段代码的时间复杂度为 O(n<sup>2</sup>)。</p><h2 id="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">i</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>    sum += j;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    res = res + f(i); <span class="hljs-comment">// 调用 f 函数</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单独看 total 函数的时间复杂度就是为 T1(n)=O(n)，但是考虑到 f 函数的时间复杂度 T2(n)=O(n)。 所以整段代码的时间复杂度为 T(n) = T1(n) * T2(n) = O(n*n)=O(n<sup>2</sup>)。</p><h2 id="多规模加法：多个参数控制多个循环相加的次数，取二者复杂度相加"><a href="#多规模加法：多个参数控制多个循环相加的次数，取二者复杂度相加" class="headerlink" title="多规模加法：多个参数控制多个循环相加的次数，取二者复杂度相加"></a>多规模加法：多个参数控制多个循环相加的次数，取二者复杂度相加</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total</span>(<span class="hljs-params">m, n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum_1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    sum_1 = sum_1 + i;<br>  &#125;<br>  <span class="hljs-keyword">let</span> sum_2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    sum_2 = sum_2 + j;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum_1 + sum_2;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们无法评估 m 和 n 谁的量级比较大，所以就不能忽略掉其中一个，这个函数的复杂度是有两个数据的量级来决定的，所以此函数的时间复杂度为 O(m+n)。</p><h2 id="多规模乘法：多个参数控制多个循环嵌套的次数，取二者复杂度相乘"><a href="#多规模乘法：多个参数控制多个循环嵌套的次数，取二者复杂度相乘" class="headerlink" title="多规模乘法：多个参数控制多个循环嵌套的次数，取二者复杂度相乘"></a>多规模乘法：多个参数控制多个循环嵌套的次数，取二者复杂度相乘</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total</span>(<span class="hljs-params">m, n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      sum = sum +  i * j;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，此函数的时间复杂度为 O(m*n)。</p><h1 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h1><p><img src="/images/%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="常见时间复杂度分析（来自掘金@snowLu）"></p><p>上图可以粗略的分为两类：<strong>多项式量级</strong> 和 <strong>非多项式量级</strong> 。</p><p>多项式量级会随着数据规模的增长，执行时间和空间占用按照多项式的比例增长。包括 O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n2) （平方阶）、O(n3)（立方阶）。</p><p>非多项式量级有 O(2<sup>n</sup>)（指数阶）和 O(n!)（阶乘阶）。随着数据规模的增长，非多项式量级的执行时间就会急剧增加，所以，非多项式量级的代码算法是非常低效的算法。</p><p>常用的时间复杂度所耗费的时间从小到大（效率从高到低）：<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p><h2 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    sum += i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然有这么多行，即使 for 循环执行了 100 次，但是代码的执行时间不随 n 的增大而增长，所以这样的代码复杂度就为 O(1)。</p><h2 id="O-logn"><a href="#O-logn" class="headerlink" title="O(logn)"></a>O(logn)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total1</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (i &lt;= n) &#123;<br>    sum += i;<br>    i = i * <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">total2</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i = i * <span class="hljs-number">2</span>) &#123;<br>    sum += i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面两个函数都有一个相同点，变量 i 从 1 开始取值，每循环一次乘以 2，当大于 n 时，循环结束。实际上，i 的取值就是一个等比数列。所以只要知道 x 的值，就可以知道这两个函数的执行次数了。那由 2<sup>x</sup> = n 可以得出 x = log<sub>2</sub>n，所以这两个函数的时间复杂度为 O(log<sub>2</sub>n)。</p><p>实际上不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。因为对数之间是可以互相转换的，log<sub>3</sub>n = log<sub>3</sub>2 * log<sub>2</sub>n，所以 O(log<sub>3</sub>n) = O(C * log<sub>2</sub>n)，其中 C = log<sub>3</sub>2 是一个常量，可以忽略。</p><p>那 O(nlogn) 的含义就很明确了，时间复杂度为 O(logn) 的代码执行了 n 次。</p><h1 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h1><p>空间复杂度的全称是渐进空间复杂度，表示代码存储空间随数据规模增长的变化趋势。</p><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initArr</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> arr = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    arr[i] = i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>空间复杂度和时间复杂度类似，忽略掉常数量级，每次数组赋值都会申请一个空间存储变量，所以此函数的空间复杂度为 O(n)。</p><p>常见的空间复杂度有 O(1)、O(n)、O(n<sup>2</sup>)， 其他的话很少会用到。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVVM原理</title>
    <link href="/2021/09/20/MVVM%E5%8E%9F%E7%90%86/"/>
    <url>/2021/09/20/MVVM%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://juejin.cn/post/6844903586103558158">https://juejin.cn/post/6844903586103558158</a> 。</p><p>现在无论是 React 还是 Vue 还是最新的 Angular，MVVM 双向数据绑定通过 <strong>数据劫持+发布订阅模式</strong> 完成。真正实现其实靠的是 ES5 中提供的 Object.defineProperty() 方法。</p><h1 id="Object-defineProperty-用法"><a href="#Object-defineProperty-用法" class="headerlink" title="Object.defineProperty()用法"></a>Object.defineProperty()用法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-keyword">let</span> song = <span class="hljs-string">&#x27;发如雪&#x27;</span>;<br>obj.singer = <span class="hljs-string">&#x27;周杰伦&#x27;</span>;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;music&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;七里香&#x27;</span>, <span class="hljs-comment">// 1.属性值</span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 2.属性是否可被删除</span><br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 3.属性值是否可修改</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 4.属性是否可被枚举</span><br>  <span class="hljs-comment">// get 和 set 设置时不能设置 writable 和 value，它们代替了二者且是互斥的</span><br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">val</span>)</span> &#123;<br>    song = val<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> song<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 下面打印的部分分别是对应代码写入顺序执行</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// &#123;singer: &#x27;周杰伦&#x27;, music: &#x27;七里香&#x27;&#125;  </span><br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">delete</span> obj.music; <br><span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// &#123;singer: &#x27;周杰伦&#x27;&#125;</span><br><span class="hljs-comment">// 3</span><br>obj.music = <span class="hljs-string">&#x27;听妈妈的话&#x27;</span>; <br><span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// &#123;singer: &#x27;周杰伦&#x27;, music: &quot;听妈妈的话&quot;&#125;</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123; <br>  <span class="hljs-built_in">console</span>.log(key); <span class="hljs-comment">// singer, music</span><br>&#125;<br><span class="hljs-comment">// 5</span><br><span class="hljs-built_in">console</span>.log(obj.music); <span class="hljs-comment">// &#x27;发如雪&#x27; </span><br><span class="hljs-comment">// 6</span><br>obj.music = <span class="hljs-string">&#x27;夜曲&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(obj.music); <span class="hljs-comment">// &#x27;夜曲&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="打造MVVM"><a href="#打造MVVM" class="headerlink" title="打造MVVM"></a>打造MVVM</h1><p>以 Vue 为参照去实现 MVVM。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个 Mvvm 构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mvvm</span>(<span class="hljs-params">options = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 将所有属性挂载到 $options</span><br>  <span class="hljs-built_in">this</span>.$options = options;<br>  <span class="hljs-comment">// this._data 也和 Vue 一样</span><br>  <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">this</span>._data = <span class="hljs-built_in">this</span>.$options.data;<br>  <span class="hljs-comment">// 数据劫持 </span><br>  Observe(data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>为什么要做数据劫持？</p><ul><li>观察对象，给对象增加 Object.defineProperty()</li><li>vue 特点是不能新增不存在的属性 不存在的属性没有 get 和 set</li><li>深度响应 因为每次赋予一个新对象时会给这个新对象增加 Object.defineProperty()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个 Observe 构造函数写数据劫持的主要逻辑</span><br><span class="hljs-comment">// 数据劫持就是给对象增加 get 和 set</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Observe</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-comment">// 先遍历一遍数据对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-keyword">let</span> val = data[key];<br>    <span class="hljs-comment">// 递归继续向下找，实现深度的数据劫持</span><br>    observe(val);<br>    <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> val<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newVal</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (val === newVal) <span class="hljs-keyword">return</span> <br>        val = newVal;<br>        <span class="hljs-comment">// 当设置为新值后，也需要把新值再去定义成属性</span><br>        observe(newVal);<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 方便递归调用</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-comment">// 如果不是对象的话就直接返回，防止递归溢出</span><br>  <span class="hljs-keyword">if</span> (!data || <span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observe(data)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mvvm</span>(<span class="hljs-params">options = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 数据劫持</span><br>  Observe(data);<br>  <span class="hljs-comment">// this 代理了this._data</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>, key, &#123;<br>      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._data[key];<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newVal</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>._data[key] = newVal;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据编译"><a href="#数据编译" class="headerlink" title="数据编译"></a>数据编译</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mvvm</span>(<span class="hljs-params">options = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 数据劫持</span><br>  observe(data);   <br>  <span class="hljs-comment">// 编译    </span><br>  <span class="hljs-keyword">new</span> Compile(options.el, <span class="hljs-built_in">this</span>);    <br>&#125;<br><br><span class="hljs-comment">// 创建Compile构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Compile</span>(<span class="hljs-params">el, vm</span>) </span>&#123;<br>  <span class="hljs-comment">// 将el挂载到实例上方便调用</span><br>  vm.$el = <span class="hljs-built_in">document</span>.querySelector(el);<br>  <span class="hljs-comment">// 在el范围里将内容都拿到，当然不能一个一个的拿</span><br>  <span class="hljs-comment">// 可以选择移到内存中去然后放入文档碎片中，节省开销</span><br>  <span class="hljs-keyword">let</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();<br>  <span class="hljs-keyword">while</span> (child = vm.$el.firstChild) &#123;<br>    fragment.appendChild(child);    <span class="hljs-comment">// 此时将el中的内容放入内存中</span><br>  &#125;<br>  <span class="hljs-comment">// 对el里面的内容进行替换</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replace</span>(<span class="hljs-params">frag</span>) </span>&#123;<br>    <span class="hljs-built_in">Array</span>.from(frag.childNodes).forEach(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> txt = node.textContent;<br>      <span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>;   <span class="hljs-comment">// 正则匹配&#123;&#123;&#125;&#125;</span><br>      <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span> &amp;&amp; reg.test(txt)) &#123; <span class="hljs-comment">// 即是文本节点又有大括号的情况&#123;&#123;&#125;&#125;</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$1); <span class="hljs-comment">// 匹配到的第一个分组 如： a.b, c</span><br>        <span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">RegExp</span>.$1.split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">let</span> val = vm;<br>        arr.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>          val = val[key];     <span class="hljs-comment">// 如this.a.b</span><br>        &#125;);<br>        <span class="hljs-comment">// 用trim方法去除一下首尾空格</span><br>        node.textContent = txt.replace(reg, val).trim();<br>      &#125;<br>      <span class="hljs-comment">// 如果还有子节点，继续递归replace</span><br>      <span class="hljs-keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;<br>        replace(node);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  replace(fragment);  <span class="hljs-comment">// 替换内容</span><br>  vm.$el.appendChild(fragment);   <span class="hljs-comment">// 再将文档碎片放入el中</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h2 id="数据更新视图"><a href="#数据更新视图" class="headerlink" title="数据更新视图"></a>数据更新视图</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>框架和类库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架和类库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找</title>
    <link href="/2021/09/19/%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/09/19/%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844903955252805645">https://juejin.cn/post/6844903955252805645</a> 。<br><a href="https://juejin.cn/post/6844903866610221064">https://juejin.cn/post/6844903866610221064</a> 。</p><p>查找和排序都是在程序设计中经常用到的算法。查找相对而言较为简单，排序比查找要复杂一些。</p><p>查找有顺序查找、二分查找、哈希表查找、二叉排序树查找等。</p><h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>直接 for 循环顺序查找效率最高。</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> searchRange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> mid;<br>  <span class="hljs-keyword">let</span> right = nums.length;<br>  <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>    mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>      right = mid;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>      left = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>      right = mid;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">let</span> leftIndex = -<span class="hljs-number">1</span>, rightIndex = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">else</span> leftIndex = nums[left] == target ? left : -<span class="hljs-number">1</span>;<br><br>  left = <span class="hljs-number">0</span>; right = nums.length;<br>  <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>    mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>      right = mid;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>      left = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>      left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">else</span> rightIndex = nums[left - <span class="hljs-number">1</span>] == target ? left - <span class="hljs-number">1</span>: -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> [leftIndex, rightIndex];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2021/09/18/%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/09/18/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://github.com/biaochenxuying/blog/issues/42">https://github.com/biaochenxuying/blog/issues/42</a> 。<br><a href="https://juejin.cn/post/6956624975600025613">https://juejin.cn/post/6956624975600025613</a> 。</p><p>排序有冒泡排序、插入排序、选择排序、归并排序等十种经典方法。</p><p>分析一个排序算法，要从执行效率、内存消耗、稳定性三方面入手。</p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="排序算法，图源网络"></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>每次冒泡操作是对相邻的两个元素进行比较，看是否满足特定关系要求，若（不）满足就让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n - 1 次，就能完成 n 个数据的排序工作。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>优点：排序算法的基础，简单实用易于理解。</li><li>缺点：比较次数多，效率较低。</li><li>使用多个循环。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>普通：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len - i -<span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">const</span> temp = arr[j];<br>        arr[j] = arr[j + <span class="hljs-number">1</span>];<br>        arr[j + <span class="hljs-number">1</span>] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort2</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> hasChange = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len -i - <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">const</span> temp = arr[j];<br>        arr[j] = arr[j + <span class="hljs-number">1</span>];<br>        arr[j + <span class="hljs-number">1</span>] = temp;<br>        hasChange = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!hasChange) <span class="hljs-keyword">break</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>构建有序序列和未排序序列。认为第一个元素已经被排序，其余均为未排序序列的元素。</li><li>选择排序每次会从未排序序列中找到最小（大）的元素，将其放到已排序区间的开头（末尾）。</li></ul><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li>使用多个循环。</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> minIndex = i,<br>        temp = arr[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) minIndex = j<br>    arr[i] = arr[minIndex];<br>    arr[minIndex] = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序又为分为 <strong>直接插入排序</strong> 和优化后的 <strong>拆半插入排序</strong> 与 <strong>希尔排序</strong> 。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>构建有序序列和未排序序列。认为第一个元素已经被排序，其余均为未排序序列的元素。</li><li>插入排序每次从未排序序列中取出一个元素，在有序序列中从后向前扫描，如果有序序列中的元素大于取出的元素，将该元素移到该元素的下一位置，直到找到相应位置并插入。</li></ul><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li>使用多个循环。</li></ul><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>普通：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">let</span> preIndex = i - <span class="hljs-number">1</span>,<br>        current = arr[i];<br>    <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>      arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>      preIndex--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (preIndex !== i - <span class="hljs-number">1</span>) arr[preIndex + <span class="hljs-number">1</span>] = current;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><p>改进：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryInsertionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>,<br>        high = i - <span class="hljs-number">1</span>,<br>        current = arr[i];<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-keyword">let</span> m = (low + high) &gt;&gt; <span class="hljs-number">1</span>; <br>      <span class="hljs-keyword">if</span> (arr[i] &gt;= arr[m]) low = m + <span class="hljs-number">1</span>; <br>      <span class="hljs-keyword">else</span> high = m - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &gt; low; j--) arr[j] = arr[j - <span class="hljs-number">1</span>];<br>    arr[low] = current; <br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>归并排序采用的是分治思想。就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ul><li>使用递归。</li></ul><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length;<br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>  <span class="hljs-keyword">let</span> middle = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>),<br>      left = arr.slice(<span class="hljs-number">0</span>, middle),<br>      right = arr.slice(middle);<br>  <span class="hljs-keyword">return</span> merge(<span class="hljs-built_in">arguments</span>.callee(left), <span class="hljs-built_in">arguments</span>.callee(right));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> result = [];<br>  <span class="hljs-keyword">while</span> (left.length &amp;&amp; right.length) &#123;<br>    <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) result.push(left.shift());<br>    <span class="hljs-keyword">else</span> result.push(right.shift());<br>  &#125;<br>  <span class="hljs-keyword">while</span> (left.length) result.push(left.shift());<br>  <span class="hljs-keyword">while</span> (right.length) result.push(right.shift());<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h2><p>先找到一个基准点（一般指数组的中部），然后数组被该基准点分割为两部分，依次与该基准点数据比较。如果比它小，放左边；反之放右边。左右分别用一个空数组去存储比较后的数据。最后递归执行上述操作，直到数组长度小于等于 1。</p><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ul><li>优点：快速，常用。这是处理大数据最快的排序算法之一。</li><li>缺点：需要另外声明两个数组，浪费了内存空间资源。</li><li>使用递归。</li></ul><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length;<br>  <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br>  <span class="hljs-keyword">const</span> midIndex = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>),<br>        valArr = arr.splice(midIndex, <span class="hljs-number">1</span>),<br>        midIndexVal = valArr[<span class="hljs-number">0</span>],<br>        left = [],<br>        right = [];<br>        <span class="hljs-comment">// 此时 len != arr.length</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br><span class="hljs-keyword">if</span> (arr[i] &lt; midIndexVal) left.push(arr[i]);<br><span class="hljs-keyword">else</span> right.push(arr[i]);<br>&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.callee(left).concat(midIndexVal, <span class="hljs-built_in">arguments</span>.callee(right));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h2><p>先将整个待排序的记录序列分割成为若干子序列，分别进行直接插入排序。待整个序列中记录基本有序时，再对全体记录进行依次直接插入排序。</p><h2 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h2><ul><li>使用多个循环。</li></ul><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length;<br>  <span class="hljs-keyword">let</span> gap = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (gap &lt; len / <span class="hljs-number">3</span>) gap = gap * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = gap; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">const</span> temp = arr[i];<br>      <span class="hljs-keyword">let</span> j = i - gap;<br>      <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) arr[j + gap] = arr[j];<br>      arr[j + gap] = temp;<br>    &#125;<br>    gap = <span class="hljs-built_in">Math</span>.floor(gap / <span class="hljs-number">3</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript事件机制</title>
    <link href="/2021/09/13/JavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/09/13/JavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844903445418213383">https://juejin.cn/post/6844903445418213383</a> 。<br><a href="https://juejin.cn/post/6844904097372438542">https://juejin.cn/post/6844904097372438542</a> 。</p><p>在 JavaScript 的学习中，经常会遇到 JavaScript 的事件机制，例如，事件绑定、事件监听、事件委托等。</p><h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><p>要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。</p><p>在 JavaScript 中，有三种常用的绑定事件的方法：</p><ul><li>在 DOM 元素中直接绑定事件</li><li>在 JavaScript 代码中绑定事件</li><li>使用事件监听绑定事件</li></ul><h2 id="在-DOM-元素中直接绑定事件"><a href="#在-DOM-元素中直接绑定事件" class="headerlink" title="在 DOM 元素中直接绑定事件"></a>在 DOM 元素中直接绑定事件</h2><p>在 DOM 元素上绑定 onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup 等事件。</p><h2 id="在-JavaScript-代码中绑定事件"><a href="#在-JavaScript-代码中绑定事件" class="headerlink" title="在 JavaScript 代码中绑定事件"></a>在 JavaScript 代码中绑定事件</h2><p>在 JavaScript 代码中（即 script 标签内）绑定事件可以使 JavaScript 代码与 HTML 标签分离，文档结构清晰，便于管理和开发。</p><h2 id="使用事件监听绑定事件"><a href="#使用事件监听绑定事件" class="headerlink" title="使用事件监听绑定事件"></a>使用事件监听绑定事件</h2><p>另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。</p><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>对于事件监听，W3C 规范中定义了 3 个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。</p><ul><li>事件冒泡：事件开始由最具体的元素接收，然后逐级向上传播到较为不具体的节点或文档。</li><li>事件捕获：事件开始由不太具体的节点接收，然后逐级向下传播到最具体的节点。与事件冒泡相反。</li></ul><p>W3C 语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.addEventListener(event, <span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">useCapture</span>)</span><br></code></pre></td></tr></table></figure><ul><li>event（必需）：事件名，支持所有 DOM 事件</li><li>function（必需）：指定事件触发时要执行的函数</li><li>useCapture（可选）：指定事件是在捕获还是冒泡阶段执行。false 冒泡阶段（默认），true 捕获阶段</li></ul><h2 id="事件监听优点"><a href="#事件监听优点" class="headerlink" title="事件监听优点"></a>事件监听优点</h2><ul><li>可以绑定多个事件</li><li>可以解除相应的绑定</li></ul><h2 id="封装事件监听"><a href="#封装事件监听" class="headerlink" title="封装事件监听"></a>封装事件监听</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 绑定监听事件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventHandler</span>(<span class="hljs-params">target, type, fn</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (target.addEventListener) &#123;<br>    target.addEventListener(type, fn);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    target.attachEvent(<span class="hljs-string">&quot;on&quot;</span>+type, fn);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 移除监听事件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEventHandler</span>(<span class="hljs-params">target, type, fn</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (target.removeEventListener) &#123;<br>    target.removeEventListener(type, fn);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    target.detachEvent(<span class="hljs-string">&quot;on&quot;</span>+type, fn);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">const</span> btn5 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn5&quot;</span>);<br>addEventHandler(btn5, <span class="hljs-string">&quot;click&quot;</span>, hello1); <span class="hljs-comment">// 添加事件hello1</span><br>addEventHandler(btn5, <span class="hljs-string">&quot;click&quot;</span>, hello2); <span class="hljs-comment">// 添加事件hello2</span><br>removeEventHandler(btn5, <span class="hljs-string">&quot;click&quot;</span>, hello1); <span class="hljs-comment">// 移除事件hello1</span><br></code></pre></td></tr></table></figure><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件委托就是利用冒泡的原理，将元素的事件委托给它的父元素或祖先元素上，触发执行效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myLink&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>aaa<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>bbb<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>ccc<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="不使用事件委托"><a href="#不使用事件委托" class="headerlink" title="不使用事件委托"></a>不使用事件委托</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myLink = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myLink&#x27;</span>);<br><span class="hljs-keyword">const</span> li = myLink.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; li.length; i++) &#123;<br>  li[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> e = event || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-keyword">let</span> target = e.target || e.srcElement;<br>    alert(e.target.id + <span class="hljs-string">&#x27;:&#x27;</span> + e.target.innerText);  <br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>给每一个列表都绑定事件，消耗内存</li><li>当有动态添加的元素时，需要重新给元素绑定事件</li></ul><h2 id="使用事件委托"><a href="#使用事件委托" class="headerlink" title="使用事件委托"></a>使用事件委托</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delegate</span>(<span class="hljs-params">element, eventType, selector, fn</span>) </span>&#123;<br>  element.addEventListener(eventType, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> el = e.target;<br>    <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>      <span class="hljs-keyword">if</span> (element === el) &#123;<br>        el = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">break</span><br>      &#125;<br>      el = el.parentNode<br>    &#125;<br>    el &amp;&amp; fn.call(el, e, el)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> element<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>提高 JavaScript 性能。事件委托可以显著的提高事件的处理速度，减少内存的占用</li><li>动态添加 DOM 元素。不需要因元素的改动而修改事件绑定</li></ul><p>注意：</p><ul><li>事件委托的实现依靠的冒泡，因此不支持事件冒泡的事件不适合使用事件委托</li><li>不是所有的事件绑定都适合用事件委托，不恰当使用反而可能导致不需要绑定事件的元素也被绑定事件</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器解析渲染页面</title>
    <link href="/2021/09/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/"/>
    <url>/2021/09/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844904040346681358">https://juejin.cn/post/6844904040346681358</a> 。<br><a href="https://juejin.cn/post/6844903815758479374">https://juejin.cn/post/6844903815758479374</a> 。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程（process）和线程（thread）是操作系统的基本概念。</p><ul><li>进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。</li><li>线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。</li></ul><p>对操作系统来说，一个任务就是一个进程。在一个进程内部，要同时做多件事就需要同时运行多个子任务，我们把进程内的这些子任务称为线程。</p><p>由于每个进程至少要做一件事，所以一个进程至少有一个线程。系统会给每个进程分配独立的内存，因此，进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段，数据集，堆等）。</p><h1 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" class="headerlink" title="浏览器的多进程架构"></a>浏览器的多进程架构</h1><p>以 Chrome 浏览器为例，它由多个进程组成，每个进程都有自己核心的职责，它们相互配合来完成浏览器的整体功能。每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。</p><p>Chrome 浏览器采用多进程架构，其顶层存在一个 Browser 进程用以协调浏览器的其它进程。</p><p><img src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%9B%E7%A8%8B.png" alt="Chrome 浏览器的主要进程"></p><p>上图只是一个概括，意思是浏览器有这几类的进程和线程，并不是每种只有一个，比如渲染进程就有多个，每个页面都有自己的渲染进程。有时候使用浏览器会遇到某个页面崩溃或者没有响应的情况，这个页面对应的渲染进程可能崩溃了，但是其它页面并没有用这个渲染进程，它们各自有各自的渲染进程，所以其它页面并不会受影响。</p><p>最新 Chrome 浏览器包括：1个Browser进程、1个GPU进程、1个网络进程、多个渲染进程、多个插件进程。打开浏览器的一个页面至少需要 4 个进程：1个Browser进程、1个GPU进程、1个网络进程、1个渲染进程。</p><h2 id="Browser进程"><a href="#Browser进程" class="headerlink" title="Browser进程"></a>Browser进程</h2><p>负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，及负责与其他进程的协调工作，同时提供存储功能。</p><h2 id="GPU进程"><a href="#GPU进程" class="headerlink" title="GPU进程"></a>GPU进程</h2><p>负责整个浏览器界面的渲染。Chrome 刚开始发布的时候是没有GPU进程的，而使用GPU是为了实现3D CSS效果，只是后面网页、Chrome 的 UI 界面都用GPU来绘制，这使GPU成为浏览器普遍的需求，最后 Chrome 在多进程架构上也引入了GPU进程。</p><h2 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h2><p>负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程。</p><h2 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h2><p>负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响。每种类型的插件对应一个进程，仅当使用插件时才创建插件进程。</p><h2 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h2><p>负责控制显示标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎 Blink 和 JS V8 引擎都是运行在该进程中，默认情况下 Chrome 会为每个标签页创建一个渲染进程。渲染进程被称为浏览器渲染进程或浏览器内核，内部是多线程的。</p><h1 id="浏览器的渲染进程"><a href="#浏览器的渲染进程" class="headerlink" title="浏览器的渲染进程"></a>浏览器的渲染进程</h1><p>我们平时看到的浏览器呈现出页面过程中，大部分工作都是在渲染进程中完成，对于前端工程师来说，主要关心的还是渲染进程。</p><h2 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h2><p>GUI渲染线程负责渲染浏览器界面，解析 HTML 和 CSS，构建 DOM Tree、CSSOM Tree、Render Tree，布局和绘制页面。</p><p>当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程也会执行。</p><p>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎线程执行时GUI渲染线程会被挂起，GUI渲染线程会被保存在一个队列中，等到JS引擎线程空闲时再立即被执行。</p><h2 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h2><p>JS引擎线程是负责执行 JavaScript 的主线程，“JavaScript 是单线程的”就是指的这个线程。Chrome V8 引擎就是在这个线程运行的。JS引擎线程负责解析 Javascript 脚本，运行代码。一个页面只有一个JS引擎线程负责解析和执行 JavaScrip。</p><p>需要注意的是，这个线程跟GUI渲染线程是互斥的。互斥的原因是 JavaScript 也可以操作 DOM 和 CSSOM，如果JS引擎线程和GUI渲染线程同时操作，结果就混乱了，不知道到底渲染哪个结果。互斥带来的后果就是如果 JavaScript 长时间运行，GUI渲染线程就不能执行，造成页面的渲染不连贯，导致页面渲染加载阻塞，整个页面就感觉卡死了。</p><h2 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h2><p>setTimeout 和 setInterval 就运行在这里，它跟JS引擎线程不在同一个地方，因为JS引擎线程是单线程的，所以如果其处于阻塞状态，那么计时器就会不准确，所以需要单独的线程来负责计时器工作，因而“单线程的 JavaScrip”能够实现异步。</p><p>定时触发器线程其实只是一个计时的作用，它并不会真正执行时间到了的回调函数，真正执行这个回调函数的还是 JS引擎线程。所以当时间到了，定时触发器线程会将回调函数给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS引擎线程从事件队列取出这个回调函数执行。</p><h2 id="异步HTTP请求线程"><a href="#异步HTTP请求线程" class="headerlink" title="异步HTTP请求线程"></a>异步HTTP请求线程</h2><p>异步HTTP请求线程负责处理异步的 Ajax 请求，当请求完成后，它也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给JS引擎线程执行。</p><h2 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h2><p>事件触发线程主要用来控制事件循环，比如 JavaScript 执行遇到定时器，AJAX 异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到事件队列，等待JS引擎线程来处理。事件触发线程不仅会将定时器事件放入事件队列，其它满足条件的事件也是它负责放进事件队列。</p><p>JavaScript 异步的实现靠的就是浏览器的多线程，当主线程遇到异步任务时，就将这个任务交给对应的线程，当这个异步任务满足回调函数条件时，对应的线程又通过事件触发线程将这个任务放入事件队列，然后主线程从事件队列取出事件继续执行。事件队列（Event Queue）是事件循环（Event Loop）的一部分。</p><h1 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h1><ul><li>解析 HTML 文件，构建 DOM Tree</li><li>解析 CSS 文件，构建 CSSOM Tree</li><li>利用 DOM Tree 和 CSSOM Tree 构建 Render Tree</li><li>布局 Render Tree 计算每个节点的位置大小等信息（回流）</li><li>绘制 Render Tree 每个节点像素信息渲染到屏幕（重绘）</li></ul><h2 id="构建-DOM-Tree"><a href="#构建-DOM-Tree" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h2><p>浏览器会遵守一套步骤将 HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：<br>字节 → 字符 → 令牌 → 节点 → DOM Tree</p><h2 id="构建-CSSOM-Tree"><a href="#构建-CSSOM-Tree" class="headerlink" title="构建 CSSOM Tree"></a>构建 CSSOM Tree</h2><p>浏览器会遵守一套步骤将 HTML 文件转换为 CSSOM 树。宏观上，可以分为几个步骤：<br>字节 → 字符 → 令牌 → 节点 → CSSOM Tree</p><h2 id="构建-Render-Tree"><a href="#构建-Render-Tree" class="headerlink" title="构建 Render Tree"></a>构建 Render Tree</h2><p>在这一过程中，不是简单的将 DOM Tree 和 CSSOM Tree 合并。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none，那么它就不会在渲染树中。</p><h2 id="布局-Render-Tree（回流）"><a href="#布局-Render-Tree（回流）" class="headerlink" title="布局 Render Tree（回流）"></a>布局 Render Tree（回流）</h2><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局。当渲染树中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流（也称为重排）。</p><h3 id="导致回流的操作"><a href="#导致回流的操作" class="headerlink" title="导致回流的操作"></a>导致回流的操作</h3><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等）</li><li>元素字体大小变化</li><li>添加或者删除可见的 DOM 元素</li><li>激活 CSS 伪类</li><li>查询某些属性或调用某些方法</li></ul><h3 id="常用且会导致回流的属性和方法"><a href="#常用且会导致回流的属性和方法" class="headerlink" title="常用且会导致回流的属性和方法"></a>常用且会导致回流的属性和方法</h3><ul><li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li><li><code>offsetWidth、offsetHeight、offsetTop、offsetLeft</code></li><li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li><li><code>scrollIntoView()、scrollIntoViewIfNeeded()</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo()</code></li></ul><h2 id="绘制-Render-Tree（重绘）"><a href="#绘制-Render-Tree（重绘）" class="headerlink" title="绘制 Render Tree（重绘）"></a>绘制 Render Tree（重绘）</h2><p>当浏览器根据渲染树进行布局后开始绘制屏幕。当页面中元素样式的改变并不影响它在文档流中的位置时（例如 background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制的过程称为重绘。</p><h3 id="防止重绘的CSS优化"><a href="#防止重绘的CSS优化" class="headerlink" title="防止重绘的CSS优化"></a>防止重绘的CSS优化</h3><ul><li>避免使用 table 布局</li><li>尽可能在 DOM 树的最末端改变 class</li><li>避免设置多层内联样式</li><li>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上</li><li>避免使用 CSS 表达式</li></ul><h3 id="防止重绘的JavaScript优化"><a href="#防止重绘的JavaScript优化" class="headerlink" title="防止重绘的JavaScript优化"></a>防止重绘的JavaScript优化</h3><ul><li>避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性</li><li>避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="为什么JavaScript是单线程的"><a href="#为什么JavaScript是单线程的" class="headerlink" title="为什么JavaScript是单线程的"></a>为什么JavaScript是单线程的</h3><p>这是由 Javascript 这门脚本语言诞生的使命所致。JavaScript 为处理页面中用户的交互，以及操作 DOM 树、CSS 样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。</p><p>如果 JavaScript 是多线程的方式来操作这些树，则可能出现操作的冲突。假设存在两个线程同时操作一个 DOM 树（CSS 样式树），一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript 在最初就选择了单线程执行。</p><h3 id="为什么JS文件阻塞页面渲染"><a href="#为什么JS文件阻塞页面渲染" class="headerlink" title="为什么JS文件阻塞页面渲染"></a>为什么JS文件阻塞页面渲染</h3><p>渲染过程中遇到 JavaScript 文件就停止渲染，就会转而执行 JavaScript 代码。JavaScript 的加载、解析与执行会阻塞 DOM 的构建，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停构建 DOM，将控制权移交给 JS引擎线程，等 JS引擎线程运行完毕，浏览器再从中断的地方恢复构建 DOM。</p><p>就是说，如果想首屏渲染的越快，就越不应该在首屏加载 JS 文件，这也是建议将 script 标签放在 body 标签底部的原因。当然并不是说 script 标签必须放在底部，因为可以给 script 标签添加 defer 或者 async 属性。</p><p>JS 文件不只是阻塞 DOM 的构建，它还会导致 CSSOM 也阻塞 DOM 的构建。原本 DOM 和 CSSOM 的构建是互不影响，但是一旦引入 JS 文件，CSSOM 也开始阻塞 DOM 的构建，只有 CSSOM 构建完毕后，才再恢复 DOM 构建。</p><p>这是因为 JavaScript 不只是可以改 DOM，它还可以更改样式，也就是可以更改 CSSOM。因为不完整的 CSSOM 是无法使用的，如果 JavaScript 想访问 CSSOM 并更改它，那么在执行 JavaScript 时，必须要能拿到完整 CSSOM。所以这就导致了一个现象，若浏览器尚未完成 CSSOM 的构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的构建。就是说，在这种情况下，浏览器会先构建 CSSOM，然后再执行 JavaScript，最后再继续构建 DOM。</p><h3 id="CSS加载会阻塞页面渲染吗"><a href="#CSS加载会阻塞页面渲染吗" class="headerlink" title="CSS加载会阻塞页面渲染吗"></a>CSS加载会阻塞页面渲染吗</h3><p>DOM 和 CSSOM 通常是并行构建的，所以 CSS 加载不会阻塞 DOM 的构建。</p><p>然而，由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的，所以 Render Tree 必须等待到 CSSOM Tree 构建完成，也就是 CSS 资源加载结束后，才能开始渲染。因此，CSS 加载会阻塞 Dom 的渲染。</p><p>因为浏览器 <strong>GUI渲染线程</strong> 与 <strong>JS引擎线程</strong> 的关系为互斥。因此，CSS 会在后面的 JS 执行前先加载执行完毕，所以， CSS 会阻塞 JS 的执行。</p><h3 id="script标签中defer和async的区别"><a href="#script标签中defer和async的区别" class="headerlink" title="script标签中defer和async的区别"></a>script标签中defer和async的区别</h3><p>当浏览器碰到 script 标签的时候，有三种情况：</p><table><thead><tr><th align="center">script 标签</th><th align="center">JS 代码执行顺序</th><th align="center">是否阻塞解析 HTML</th></tr></thead><tbody><tr><td align="center"><code>&lt;script src=&quot;script.js&quot;&gt;</code></td><td align="center">在 HTML 中的顺序</td><td align="center">阻塞</td></tr><tr><td align="center"><code>&lt;script async src=&quot;script.js&quot;&gt;</code></td><td align="center">请求返回顺序</td><td align="center">可能阻塞，也可能不阻塞</td></tr><tr><td align="center"><code>&lt;script defer src=&quot;script.js&quot;&gt;</code></td><td align="center">在 HTML 中的顺序</td><td align="center">不阻塞</td></tr></tbody></table><h4 id="lt-script-src-quot-script-js-quot-gt"><a href="#lt-script-src-quot-script-js-quot-gt" class="headerlink" title="&lt;script src=&quot;script.js&quot;&gt;"></a><code>&lt;script src=&quot;script.js&quot;&gt;</code></h4><p>浏览器在解析 HTML 时，如果遇到一个没有任何属性的 script 标签，就会立即暂停解析 HTML，改为先请求获取 JS 代码内容，然后让 JS引擎线程执行 JS 代码，等 JS 代码执行完毕后恢复解析 HTML。</p><p>script 标签阻塞了浏览器对 HTML 的解析，如果获取 JS 代码的网络请求迟迟得不到响应，或者 JS 代码执行时间过长，都会导致白屏，用户看不到页面内容。</p><h4 id="lt-script-async-src-quot-script-js-quot-gt"><a href="#lt-script-async-src-quot-script-js-quot-gt" class="headerlink" title="&lt;script async src=&quot;script.js&quot;&gt;"></a><code>&lt;script async src=&quot;script.js&quot;&gt;</code></h4><p>async 表示异步，当浏览器遇到带有 async 属性的 script 标签时，获取 JS 代码的请求是异步的，即不会立即暂停解析 HTML，而是解析 HTML 的同时，请求获取 JS 代码内容。当请求获取到 JS 代码内容后，如果此时 HTML 还没被解析完，会立即暂停解析 HTML，然后让 JS引擎线程执行 JS 代码，等 JS 代码执行完毕后恢复解析 HTML。</p><p>所以带有 async 属性的 script 标签是不可控的，因为执行时间不确定，如果在异步 JS 代码中获取某个 DOM 元素，有可能获取到也有可能获取不到。且存在多个带有 async 属性的 script 标签时，它们之间的执行顺序也不确定，完全依赖于网络传输结果，谁先到执行谁。</p><h4 id="lt-script-defer-src-quot-script-js-quot-gt"><a href="#lt-script-defer-src-quot-script-js-quot-gt" class="headerlink" title="&lt;script defer src=&quot;script.js&quot;&gt;"></a><code>&lt;script defer src=&quot;script.js&quot;&gt;</code></h4><p>defer 表示延迟，当浏览器遇到带有 defer 属性的 script 标签时，获取 JS 代码的请求是异步的，即不会立即暂停解析 HTML，而是解析 HTML 的同时，请求获取 JS 代码内容。除此外，当请求获取到 JS 代码内容后，如果此时 HTML 还没被解析完，不会立即暂停解析 HTML，而是等待 HTML 都被解析完毕后再执行 JS 代码。JS 代码的执行要在 HTML 解析完成之后、DOMContentLoaded 事件触发之前完成。</p><p>如果存在多个带有 defer 属性的 script 标签，浏览器（IE9及以下的除外）会保证按照它们在 HTML 中出现的顺序执行，不会破坏 JS 代码之间的依赖关系。</p>]]></content>
    
    
    <categories>
      
      <category>运行环境</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之Map方法属性</title>
    <link href="/2021/09/09/JavaScript%E4%B9%8BMap%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/09/09/JavaScript%E4%B9%8BMap%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a> 。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Weakmap">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Weakmap</a> 。</p><h1 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>()<br></code></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map()"></a>Map()</h2><p>Map() 构造函数用于创建并返回一个 Map 对象，需要与 new 关键字配合使用。</p><p>Object 只用字符串当键，结构是“字符串—值”；Map 各种类型的值都可以当作键，结构是“值—值”。若需要“键值对”的数据结构，Map 比 Object 更合适。此外，两者中都是键不能重复，值可以重复，且键无序。</p><p>接收一个参数：</p><ul><li>iterable（可选）：可以是一个数组或者其他可迭代对象，其元素为键值对（如，两个元素的数组等）。每个键值对都会添加到新的 Map。null 会被当做 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;one&#x27;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;two&#x27;</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;three&#x27;</span>]])<br><span class="hljs-built_in">console</span>.log(myMap); <span class="hljs-comment">// &#123;1 =&gt; &#x27;one&#x27;, 2 =&gt; &#x27;two&#x27;, 3 =&gt; &#x27;three&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h1 id="字典实例属性"><a href="#字典实例属性" class="headerlink" title="字典实例属性"></a>字典实例属性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>.prototype.size<br></code></pre></td></tr></table></figure><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>size 属性用于返回 Map 对象的成员数量，不可以设置该属性来改变 Map 对象的成员数量。</p><h1 id="字典实例方法"><a href="#字典实例方法" class="headerlink" title="字典实例方法"></a>字典实例方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>.prototype.set()<br><span class="hljs-built_in">Map</span>.prototype.get()<br><span class="hljs-built_in">Map</span>.prototype.has()<br><span class="hljs-built_in">Map</span>.prototype.delete()<br><span class="hljs-built_in">Map</span>.prototype.clear()<br><span class="hljs-built_in">Map</span>.prototype.keys()<br><span class="hljs-built_in">Map</span>.prototype.values()<br><span class="hljs-built_in">Map</span>.prototype.entries()<br><span class="hljs-built_in">Map</span>.prototype.forEach()<br></code></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>set() 方法用于为 Map 对象添加或更新一个键值对，返回 Map 对象本身。</p><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>get() 方法用于获取 Map 对象中指定键的值，返回指定键的值，如果找不到这个键则返回 undefined。</p><h2 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h2><p>has() 方法用于判断 Map 对象中是否存在指定键，返回布尔值。</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h2><p>delete() 方法用于移除 Map 对象中指定的键和其值，返回布尔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map1.set(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>map1.delete(<span class="hljs-string">&#x27;bar&#x27;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><p>clear() 方法用于移除 Map 对象中的所有键值对，返回 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map1.set(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>);<br>map1.set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>map1.clear(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h2><p>keys() 方法返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的 key 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>myMap.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;zero&quot;</span>);<br>myMap.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> myMap.keys()) <span class="hljs-built_in">console</span>.log(key)<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h2><p>values() 方法返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的 value 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>myMap.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;zero&quot;</span>);<br>myMap.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> myMap.values()) <span class="hljs-built_in">console</span>.log(value)<br><span class="hljs-comment">// zero</span><br><span class="hljs-comment">// one</span><br></code></pre></td></tr></table></figure><h2 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h2><p>entries() 方法返回一个新的包含 [key, value] 对的 Iterator 对象，返回的迭代器中的迭代顺序与 Map 对象的插入顺序相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>myMap.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;zero&quot;</span>);<br>myMap.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> myMap) <span class="hljs-built_in">console</span>.log(i)<br><span class="hljs-comment">// [0, &#x27;zero&#x27;]</span><br><span class="hljs-comment">// [1, &#x27;one&#x27;]</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) <span class="hljs-built_in">console</span>.log(key, value)<br><span class="hljs-comment">// 0 &#x27;zero&#x27;</span><br><span class="hljs-comment">// 1 &#x27;one&#x27;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap.entries()) <span class="hljs-built_in">console</span>.log(key, value)<br><span class="hljs-comment">// 0 &#x27;zero&#x27;</span><br><span class="hljs-comment">// 1 &#x27;one&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><p>forEach() 方法按照插入顺序依次对 Map 中每个键值对执行一次给定的回调函数，返回值为 undefined。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>value（可选），每个迭代的值</li><li>key（可选），每个迭代的键</li><li>map（可选），被迭代的 Map 对象</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>myMap.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;zero&quot;</span>);<br>myMap.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br><br>myMap.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(key, value));<br><span class="hljs-comment">// 0 &#x27;zero&#x27;</span><br><span class="hljs-comment">// 1 &#x27;one&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="弱字典方法"><a href="#弱字典方法" class="headerlink" title="弱字典方法"></a>弱字典方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">WeakMap</span>()<br></code></pre></td></tr></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap()"></a>WeakMap()</h2><p>WeakMap() 构造函数用于创建并返回一个 WeakMap 对象，需要与 new 关键字配合使用。</p><p>注意，WeakMap 对象的键只能是 Object 类型。原始数据类型是不能作为键的，值的类型没有限制。</p><p>接收一个参数：</p><ul><li>iterable（可选）：是一个数组（二元数组）或其他可迭代的且其元素是键值对的对象。 每个键值对都会添加到新的 WeakMap。null 会被当做 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>([[&#123;&#125;, <span class="hljs-string">&#x27;one&#x27;</span>], [&#123;&#125;, <span class="hljs-string">&#x27;two&#x27;</span>], [&#123;&#125;, <span class="hljs-string">&#x27;three&#x27;</span>]])<br><span class="hljs-built_in">console</span>.log(myMap); <span class="hljs-comment">// &#123;&#123;…&#125; =&gt; &#x27;three&#x27;, &#123;…&#125; =&gt; &#x27;one&#x27;, &#123;…&#125; =&gt; &#x27;two&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h1 id="弱字典实例方法"><a href="#弱字典实例方法" class="headerlink" title="弱字典实例方法"></a>弱字典实例方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">WeakMap</span>.prototype.set()<br><span class="hljs-built_in">WeakMap</span>.prototype.get()<br><span class="hljs-built_in">WeakMap</span>.prototype.has()<br><span class="hljs-built_in">WeakMap</span>.prototype.delete()<br></code></pre></td></tr></table></figure><h2 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h2><p>set() 方法用于为 WeakMap 对象添加或更新一个键值对，返回 WeakMap 对象本身。</p><h2 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h2><p>get() 方法用于获取 WeakMap 对象中指定键的值，返回指定键的值，如果找不到这个键则返回 undefined。</p><h2 id="has-1"><a href="#has-1" class="headerlink" title="has()"></a>has()</h2><p>has() 方法用于判断 WeakMap 对象中是否存在指定键，返回布尔值。</p><h2 id="delete-1"><a href="#delete-1" class="headerlink" title="delete()"></a>delete()</h2><p>delete() 方法用于移除 WeakMap 对象中指定的键和其值，返回布尔值。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>方法属性</tag>
      
      <tag>Map</tag>
      
      <tag>WeakMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之Set方法属性</title>
    <link href="/2021/09/09/JavaScript%E4%B9%8BSet%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/09/09/JavaScript%E4%B9%8BSet%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set</a> 。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet</a> 。</p><h1 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Set</span>()<br></code></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set()"></a>Set()</h2><p>Set() 构造函数用于创建并返回一个 Set 对象，需要与 new 关键字配合使用。</p><p>Array 的元素可以重复且有序，Set 的元素不可以重复且无序，两者元素的值都可以是任意类型。</p><p>接收一个参数：</p><ul><li>iterable（可选）：可迭代对象，它所有元素将不重复地被添加到新 Set 中。</li></ul><h1 id="集合实例属性"><a href="#集合实例属性" class="headerlink" title="集合实例属性"></a>集合实例属性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Set</span>.prototype.size<br></code></pre></td></tr></table></figure><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>size 是可访问属性，用于返回 Set 对象中元素的个数。</p><h1 id="集合实例方法"><a href="#集合实例方法" class="headerlink" title="集合实例方法"></a>集合实例方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Set</span>.prototype.add()<br><span class="hljs-built_in">Set</span>.prototype.has()<br><span class="hljs-built_in">Set</span>.prototype.delete()<br><span class="hljs-built_in">Set</span>.prototype.clear()<br><span class="hljs-built_in">Set</span>.prototype.values()<br><span class="hljs-built_in">Set</span>.prototype.entries()<br><span class="hljs-built_in">Set</span>.prototype.forEach()<br></code></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><p>add() 方法用于为 Set 对象的末尾添加一个指定的值，返回 Set 对象本身。</p><h2 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h2><p>has() 方法用于判断 Set 对象中是否存在指定值，返回布尔值。</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h2><p>delete() 方法用于移除 Set 对象中指定的值，返回布尔值。</p><h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><p>clear() 方法用于移除 Set 对象中的所有值，返回 undefined。</p><h2 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h2><p>values() 方法按照元素插入顺序返回一个具有 Set 对象每个元素值的全新 Iterator 对象。</p><p>keys() 方法是这个方法的别名（与 Map 对象相似）；他们的行为一致，都是返回 Set 对象中的元素值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>set1.add(<span class="hljs-number">42</span>);<br>set1.add(<span class="hljs-string">&#x27;forty-two&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> set1) <span class="hljs-built_in">console</span>.log(i)<br><span class="hljs-comment">// 42</span><br><span class="hljs-comment">// forty-two</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> set1.values()) <span class="hljs-built_in">console</span>.log(value)<br><span class="hljs-comment">// 42</span><br><span class="hljs-comment">// forty-two</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> set1.keys()) <span class="hljs-built_in">console</span>.log(value)<br><span class="hljs-comment">// 42</span><br><span class="hljs-comment">// forty-two</span><br></code></pre></td></tr></table></figure><h2 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h2><p>entries() 方法返回一个新的迭代器对象 ，这个对象的元素是类似 [value, value] 形式的数组。</p><p>value 是集合对象中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序。由于集合对象不像 Map 对象那样拥有 key，然而，为了与 Map 对象的 API 形式保持一致，故使得每一个 entry 的 key 和 value 都拥有相同的值，因而最终返回一个 [value, value] 形式的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>set1.add(<span class="hljs-number">42</span>);<br>set1.add(<span class="hljs-string">&#x27;forty-two&#x27;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> set1.entries()) <span class="hljs-built_in">console</span>.log(i)<br><span class="hljs-comment">// [42, 42]</span><br><span class="hljs-comment">// [&#x27;forty-two&#x27;, &#x27;forty-two&#x27;]</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> set1.entries()) <span class="hljs-built_in">console</span>.log(key, value)<br><span class="hljs-comment">// 42 42</span><br><span class="hljs-comment">// forty-two forty-two</span><br></code></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><p>forEach 方法会根据集合中元素的插入顺序，依次执行提供的回调函数，返回值为 undefined。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），集合当前元素的值</li><li>currentKey（可选），集合当前元素的索引值，由于集合没有索引，也表示集合当前元素的值</li><li>set（可选），集合当前本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>set1.add(<span class="hljs-number">42</span>);<br>set1.add(<span class="hljs-string">&#x27;forty-two&#x27;</span>);<br><br>set1.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;)<br><span class="hljs-comment">// 42</span><br><span class="hljs-comment">// forty-two</span><br><br>set1.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(key, value);<br>&#125;)<br><span class="hljs-comment">// 42 42</span><br><span class="hljs-comment">// forty-two forty-two</span><br><br>set1.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value, set</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(key, value,set);<br>&#125;)<br><span class="hljs-comment">// 42 42 &#123;42, &#x27;forty-two&#x27;&#125;</span><br><span class="hljs-comment">// forty-two forty-two &#123;42, &#x27;forty-two&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h1 id="弱集合方法"><a href="#弱集合方法" class="headerlink" title="弱集合方法"></a>弱集合方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">WeakSet</span>()<br></code></pre></td></tr></table></figure><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet()"></a>WeakSet()</h2><p>WeakSet() 构造函数用于创建并返回一个 WeakSet 对象，需要与 new 关键字配合使用。</p><p>注意，WeakMap 对象的值只能是 Object 类型。原始数据类型是不能作为值的。</p><p>接收一个参数：</p><ul><li>iterable（可选）：可迭代对象，它所有迭代值被添加到新 WeakSet 中。</li></ul><h1 id="弱集合实例方法"><a href="#弱集合实例方法" class="headerlink" title="弱集合实例方法"></a>弱集合实例方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">WeakSet</span>.prototype.add()<br><span class="hljs-built_in">WeakSet</span>.prototype.has()<br><span class="hljs-built_in">WeakSet</span>.prototype.delete()<br></code></pre></td></tr></table></figure><h2 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h2><p>add() 方法用于为 WeakSet 对象的末尾添加一个指定的值，返回 WeakSet 对象本身。</p><h2 id="has-1"><a href="#has-1" class="headerlink" title="has()"></a>has()</h2><p>has() 方法用于判断 WeakSet 对象中是否存在指定值，返回布尔值。</p><h2 id="delete-1"><a href="#delete-1" class="headerlink" title="delete()"></a>delete()</h2><p>delete() 方法用于移除 WeakSet 对象中指定的值，返回布尔值。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>方法属性</tag>
      
      <tag>Set</tag>
      
      <tag>WeakSet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>客户端存储</title>
    <link href="/2021/09/09/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    <url>/2021/09/09/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844903516826255373">https://juejin.cn/post/6844903516826255373</a> 。<br><a href="https://juejin.cn/post/6844903989096497159">https://juejin.cn/post/6844903989096497159</a> 。<br><a href="https://juejin.cn/post/6844904021308735502#heading-13">https://juejin.cn/post/6844904021308735502#heading-13</a> 。</p><p>在前端开发的时候，如果网页刷新，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储方式有三种，分别是 Cookie、WebStorage、IndexedDB。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie 最开始被设计出来并不是来做本地存储的，而是为了弥补 HTTP 在状态管理上的不足。HTTP 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种背景下，就产生了 Cookie。</p><p>Cookie 是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。</p><p>Cookie 的作用很好理解，就是用来做状态存储的。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul><li>容量缺陷。Cookie 的体积上限只有 4KB，只能用来存储少量的信息。</li><li>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。</li><li>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>可通过 document.cookie 获取全部 Cookie。Cookie 是一段字符串，是键值对的形式。操作起来有些麻烦，可引入封装好的库进行使用，比如 js-Cookie。</p><ul><li>原生<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存 Cookie 值</span><br><span class="hljs-keyword">let</span> dataCookie=<span class="hljs-string">&#x27;110&#x27;</span>;<br><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&#x27;token&#x27;</span> + <span class="hljs-string">&quot;=&quot;</span> + dataCookie;<br><span class="hljs-comment">//获取指定名称的Cookie值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCookie</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">document</span>.cookie.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;(^| )&quot;</span> + name + <span class="hljs-string">&quot;=([^;]*)(;|$)&quot;</span>));<br>  <span class="hljs-keyword">if</span>(arr != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(arr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">unescape</span>(arr[<span class="hljs-number">2</span>]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">var</span> CookieData=getCookie(<span class="hljs-string">&#x27;token&#x27;</span>); <span class="hljs-comment">//Cookie赋值给变量。</span><br></code></pre></td></tr></table></figure></li><li>js-Cookie<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Cookies.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, &#123; <span class="hljs-attr">expires</span>: <span class="hljs-number">7</span> &#125;); <span class="hljs-comment">// 设置一个 Cookie，7天后失效</span><br>Cookies.get(<span class="hljs-string">&quot;name&quot;</span>);<br>Cookies.remove(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>Cookie 和 Session 都是普遍用来跟踪浏览用户身份的会话方式。</p><ul><li>Cookie 数据存放在客户端，Session 数据放在服务器端，而且后者是依赖于 Cookie 实现的；</li><li>Cookie 本身并不安全，考虑到安全应当使用 Session；</li><li>Session 会在一定时间内保存在服务器上。如果访问量比较大，会比较消耗服务器的性能。考虑到减轻服务器性能方面的开销，应当使用 Cookie；</li><li>单个 Cookie 保存的数据不能超过 4K，很多浏览器都限制一个域名最多保存 50 个 Cookie。将登陆等等重要信息存放为 Session，其他信息如果需要保留，可以放在 Cookie 中。</li></ul><h1 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h1><p>在 Web 本地存储场景上 Cookie 的使用受到种种限制，最关键的就是存储容量太小和数据无法持久化存储。在 HTML5 的标准下，出现了 WebStorage（其又分为 localStorage 和 sessionStorage）。</p><p>不同浏览器无法共享 localStorage 和 sessionStorage 中的信息。同一浏览器的相同域名和端口的不同页面间可以共享相同的 localStorage，但是不同页面间无法共享 sessionStorage 信息。这里需要注意的是，页面仅指顶级窗口，如果一个页面包含多个 iframe 且他们属于同源页面，那么他们之间可以共享 sessionStorage。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>它相对 Cookie 有相当多的区别：</p><ul><li>容量。WebStorage 的容量上限为 5M，相比于 Cookie 的 4K 大大增加。当然 5M 是针对一个域名的。</li><li>只存在客户端。默认不参与与服务端的通信，这样就很好地避免了 Cookie 带来的性能问题和安全问题。</li><li>接口封装。通过 localStorage 和 sessionStorage 暴露在全局，并通过它的方法进行操作，非常方便。</li></ul><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>localStorage 和 sessionStorage 都是 WebStorage 类型实例，它们的使用方法是一样的。</p><p>注意事项：</p><ul><li>WebStorage 写入的时候，如果超出容量会报错，之前保存的数据不会丢失。</li><li>WebStorage 存储容量快要满的时候，getItem() 方法性能会急剧下降。</li><li>WebStorage 存储的都是字符串。（若要存储对象，需调用 JSON.stringify() 方法转为 JSON 数据类型；若要获取数据，需调用 JSON.parse() 方法再解析 JSON 数据类型成对象）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;SessionData&#x27;</span>, num = <span class="hljs-number">120</span>;<br>sessionStorage.setItem(name, num); <span class="hljs-comment">// 存储数据</span><br>sessionStorage.value = <span class="hljs-number">110</span>; <span class="hljs-comment">// 存储数据</span><br>sessionStorage.valueOf(); <span class="hljs-comment">// 获取全部数据</span><br><span class="hljs-comment">//  &#123;value: &#x27;110&#x27;, SessionData: &#x27;120&#x27;, length: 2&#125;</span><br><span class="hljs-keyword">let</span> dataSession1 = sessionStorage.getItem(name); <span class="hljs-comment">// 获取指定键名数据</span><br><span class="hljs-keyword">let</span> dataSession2 = sessionStorage.SessionData; <span class="hljs-comment">// 获取指定键名数据</span><br><span class="hljs-built_in">console</span>.log(dataSession1, dataSession2);<br><span class="hljs-comment">// 120 120</span><br>sessionStorage.removeItem(name); <span class="hljs-comment">// 删除指定键名数据</span><br>sessionStorage.clear(); <span class="hljs-comment">// 清空缓存数据</span><br></code></pre></td></tr></table></figure><h1 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h1><p>IndexedDB 是运行在浏览器中的非关系型数据库，本质上是数据库，不是和 WebStorage的 5M 一个量级，理论上这个容量是没有上限的。关于它的使用， MDN 上的教程文档已经非常详尽。</p><p>分析一下 IndexedDB 的一些重要特性，除了拥有数据库本身的特性，比如支持事务，存储二进制数据等等，还有这样一些特性需要格外注意：</p><ul><li>键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。</li><li>异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。</li><li>受同源策略限制。即无法访问跨域的数据库。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在浏览器开发者面板的 Application 栏可以看到对应的具体信息。</p><h2 id="对比异同"><a href="#对比异同" class="headerlink" title="对比异同"></a>对比异同</h2><table><thead><tr><th align="center">分类</th><th align="center">存储数据容量</th><th align="center">生命周期</th><th align="center">存储位置</th><th align="center">易用性</th></tr></thead><tbody><tr><td align="center">Cookie</td><td align="center">4KB</td><td align="center">可以设置失效时间，默认是关闭浏览器后失效</td><td align="center">保存在客户端，每次网络请求时都带上</td><td align="center">需要封装，源生接口不友好</td></tr><tr><td align="center">localStorage</td><td align="center">5MB</td><td align="center">除非被手动清除，否则永久保存</td><td align="center">保存在客户端，不与服务端通信。节省网络流量</td><td align="center">源生接口可以接受，可封装</td></tr><tr><td align="center">sessionStorage</td><td align="center">5MB</td><td align="center">仅在当前网页会话下有效，关闭页面后失效</td><td align="center">保存在客户端，不与服务端通信。节省网络流量</td><td align="center">源生接口可以接受，可封装</td></tr></tbody></table><p>相同：</p><ul><li>存储数据类型都是字符串。</li><li>都受到跨域限制。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>从性能来说，因为每次 HTTP 请求都会携带 Cookie 信息，这样无形中浪费了带宽，所以应该尽可能少的使用 Cookie。另外，Cookie 还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，Cookie 还是更好用的。其他情况下，可以使用 WebStorage 就用 WebStorage。</p><p>WebStorage 在存储数据的大小上秒杀 Cookie，因此基本很少使用 Cookie。localStorage 和 sessionStorage 唯一的差别就是一个永久保存在浏览器中，一个关闭网页就清除信息。localStorage 适合持久化缓存数据，可以用来跨页面传递参数、存储一些内容稳定的资源等等；sessionStorage 适合一次性临时数据保存，防止用户刷新页面之后丢失了一些参数，可以用来对表单信息进行维护，存储本次浏览记录等。</p>]]></content>
    
    
    <categories>
      
      <category>运行环境</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>数据存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之String方法属性</title>
    <link href="/2021/09/08/JavaScript%E4%B9%8BString%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/09/08/JavaScript%E4%B9%8BString%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://juejin.cn/post/6844903927754784781">https://juejin.cn/post/6844903927754784781</a> 。</li><li><a href="https://juejin.cn/post/6921593483757092878">https://juejin.cn/post/6921593483757092878</a> 。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</a> 。</li></ol><h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.raw()<br><span class="hljs-built_in">String</span>.fromCharcode()<br><span class="hljs-built_in">String</span>.fromCodePoint()<br></code></pre></td></tr></table></figure><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>String.raw() 方法用来获取一个模板字符串的原始字符串。</p><p>接收参数：</p><ul><li>callSite。一个模板字符串的“调用点对象”。类似 <code>&#123; raw: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;] &#125;</code>。</li><li>substitutions。任意个可选的参数，表示任意个内插表达式对应的值。</li><li>templateString。模板字符串，可包含占位符<code>$&#123;...&#125;</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.raw<span class="hljs-string">`Hi\n<span class="hljs-subst">$&#123;<span class="hljs-number">2</span>+<span class="hljs-number">3</span>&#125;</span>!`</span>; <span class="hljs-comment">// &#x27;Hi\\n5!&#x27; // Hi 后面的字符不是换行符，\ 和 n 是两个不同的字符</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-built_in">String</span>.raw <span class="hljs-string">`Hi\n<span class="hljs-subst">$&#123;name&#125;</span>!`</span>; <span class="hljs-comment">// &#x27;Hi\\nBob!&#x27;</span><br><span class="hljs-built_in">String</span>.raw(&#123; <span class="hljs-attr">raw</span>: <span class="hljs-string">&#x27;test&#x27;</span> &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// &#x27;t0e1s2t&#x27;</span><br><span class="hljs-built_in">String</span>.raw(&#123; <span class="hljs-attr">raw</span>: [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>] &#125;, <span class="hljs-number">2</span> + <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Java&#x27;</span> + <span class="hljs-string">&#x27;Script&#x27;</span>); <span class="hljs-comment">// &#x27;foo5barJavaScriptbaz&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="String-fromCharcode"><a href="#String-fromCharcode" class="headerlink" title="String.fromCharcode()"></a>String.fromCharcode()</h2><p>String.fromCharCode() 方法返回由指定的 UTF-16 代码单元序列创建的字符串。</p><p>接收参数：</p><ul><li>num1, …, numN。一系列 UTF-16 代码单元的数字。范围介于 0 到 65535（0xFFFF）之间。大于 0xFFFF 的数字将被截断。不进行有效性检查。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">189</span>, <span class="hljs-number">43</span>, <span class="hljs-number">190</span>, <span class="hljs-number">61</span>); <span class="hljs-comment">// &#x27;½+¾=&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>String.fromCodePoint() 方法返回使用指定的代码点序列创建的字符串。</p><p>接收参数：</p><ul><li>num1, …, numN。一串 Unicode 编码位置，即“代码点”。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.fromCodePoint(<span class="hljs-number">9731</span>, <span class="hljs-number">9733</span>, <span class="hljs-number">9842</span>, <span class="hljs-number">0x2F804</span>); <span class="hljs-comment">// &#x27;☃★♲你&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="字符串实例属性"><a href="#字符串实例属性" class="headerlink" title="字符串实例属性"></a>字符串实例属性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.prototype.length<br></code></pre></td></tr></table></figure><h2 id="length-字符串长度"><a href="#length-字符串长度" class="headerlink" title="length 字符串长度"></a>length 字符串长度</h2><p>length 属性表示字符串的长度，不可以设置该属性来改变字符串的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&quot;Mozilla&quot;</span>;<br><span class="hljs-keyword">const</span> empty = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Mozilla is &quot;</span> + x.length + <span class="hljs-string">&quot; code units long&quot;</span>);<br><span class="hljs-comment">// &quot;Mozilla is 7 code units long&quot;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The empty string is has a length of &quot;</span> + empty.length);<br><span class="hljs-comment">// &quot;The empty string is has a length of 0&quot;</span><br></code></pre></td></tr></table></figure><h1 id="字符串实例方法"><a href="#字符串实例方法" class="headerlink" title="字符串实例方法"></a>字符串实例方法</h1><p>字符串实例方法都不会改变原字符串。</p><h2 id="增删改替"><a href="#增删改替" class="headerlink" title="增删改替"></a>增删改替</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.prototype.repeat()<br><span class="hljs-built_in">String</span>.prototype.split()<br><span class="hljs-built_in">String</span>.prototype.slice()<br><span class="hljs-built_in">String</span>.prototype.substring()<br><span class="hljs-built_in">String</span>.prototype.concat()<br><span class="hljs-built_in">String</span>.prototype.replace()<br><span class="hljs-built_in">String</span>.prototype.replaceAll()<br><span class="hljs-built_in">String</span>.prototype.padEnd()<br><span class="hljs-built_in">String</span>.prototype.padStart()<br><span class="hljs-built_in">String</span>.prototype.trim()<br><span class="hljs-built_in">String</span>.prototype.trimEnd()<br><span class="hljs-built_in">String</span>.prototype.trimRight()<br><span class="hljs-built_in">String</span>.prototype.trimStart()<br><span class="hljs-built_in">String</span>.prototype.trimLeft()<br></code></pre></td></tr></table></figure><h3 id="repeat-重复"><a href="#repeat-重复" class="headerlink" title="repeat() 重复"></a>repeat() 重复</h3><p>repeat() 方法构造并返回一个新字符串，新字符串包含被连接在一起的指定数量的字符串的副本。</p><p>接收一个参数：</p><ul><li>count（可选）：表示在新构造的字符串中重复多少遍原字符串，默认为 0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdef&#x27;</span>;<br>str.repeat(); <span class="hljs-comment">// &#x27;&#x27;</span><br>str.repeat(<span class="hljs-number">3</span>); <span class="hljs-comment">// &#x27;abcdefabcdefabcdef&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="split-分割"><a href="#split-分割" class="headerlink" title="split() 分割"></a>split() 分割</h3><p>split() 方法使用指定的分隔符字符串，将调用该方法的字符串分割成子字符串数组并返回。</p><p>接收两个参数：</p><ul><li>separator（可选）：指定表示每个拆分应发生的点的字符串。可以是一个字符串或正则表达式。若省略或者不出现分隔符，则返回的数组包含一个由整个字符串组成的元素；若为空字符串，则将原字符串中每个字符的数组形式返回。</li><li>limit（可选）：限定返回的分割片段数量。默认不限定。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;a,b,c,de,f&#x27;</span>;<br>str.split(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;,&#x27;, &#x27;b&#x27;, &#x27;,&#x27;, &#x27;c&#x27;, &#x27;,&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;,&#x27;, &#x27;f&#x27;]</span><br>str.split(<span class="hljs-string">&#x27;,&#x27;</span>); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;de&#x27;, &#x27;f&#x27;]</span><br>str.split(); <span class="hljs-comment">// [&#x27;a,b,c,de,f&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="slice-提取"><a href="#slice-提取" class="headerlink" title="slice() 提取"></a>slice() 提取</h3><p>slice() 方法提取调用该方法的字符串的一部分并返回。</p><p>接收两个参数：</p><ul><li>beginIndex（必需）：从该索引处开始提取原字符串中的字符。接受负值。</li><li>endIndex（可选）：在该索引处前结束提取字符串。默认提取完字符串。接受负值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;aaabbbccc&#x27;</span>;<br>str.slice(<span class="hljs-number">0</span>); <span class="hljs-comment">// &#x27;aaabbbccc&#x27;</span><br>str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// &#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="substring-截取"><a href="#substring-截取" class="headerlink" title="substring() 截取"></a>substring() 截取</h3><p>substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集。</p><p>接收两个参数：</p><ul><li>indexStart（必需）：从该索引处开始截取原字符串中的字符。接受负值。</li><li>indexEnd（可选）：在该索引处前结束截取字符串。默认截取完字符串。接受负值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> anyString = <span class="hljs-string">&quot;Mozilla&quot;</span>;<br><br><span class="hljs-comment">// 输出 &quot;Moz&quot;</span><br>anyString.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>));<br>anyString.substring(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>));<br>anyString.substring(<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>));<br>anyString.substring(<span class="hljs-number">3</span>, <span class="hljs-literal">NaN</span>));<br>anyString.substring(-<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>anyString.substring(<span class="hljs-literal">NaN</span>, <span class="hljs-number">3</span>));<br><br><span class="hljs-comment">// 输出 &quot;lla&quot;</span><br>anyString.substring(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>));<br>anyString.substring(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>));<br><br><span class="hljs-comment">// 输出 &quot;&quot;</span><br>anyString.substring(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>));<br><br><span class="hljs-comment">// 输出 &quot;Mozill&quot;</span><br>anyString.substring(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>));<br><br><span class="hljs-comment">// 输出 &quot;Mozilla&quot;</span><br>anyString.substring(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>));<br>anyString.substring(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><h3 id="concat-合并"><a href="#concat-合并" class="headerlink" title="concat() 合并"></a>concat() 合并</h3><p>concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p><p>接收参数：</p><ul><li>要合并的字符串。可以是任意多个。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>str.concat(<span class="hljs-string">&#x27;bbb&#x27;</span>); <span class="hljs-comment">// &#x27;aaabbb&#x27;</span><br>str.concat(<span class="hljs-string">&#x27;bbb&#x27;</span>, <span class="hljs-string">&#x27;ccc&#x27;</span>); <span class="hljs-comment">// &#x27;aaabbbccc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="replace-替换首个"><a href="#replace-替换首个" class="headerlink" title="replace() 替换首个"></a>replace() 替换首个</h3><p>replace() 方法返回一个由替换值替换第一个模式匹配项后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。</p><p>接收参数：</p><ul><li>regexp | substr：regexp指一个 RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。substr指一个将被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。</li><li>newSubStr | function：newSubStr指用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。function指一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br><span class="hljs-keyword">const</span> string = <span class="hljs-string">&#x27;Twas the night before Xmas...&#x27;</span>;<br>str.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;bbb&#x27;</span>); <span class="hljs-comment">// &#x27;bbbaa&#x27;</span><br>string.replace(<span class="hljs-regexp">/xmas/i</span>, <span class="hljs-string">&#x27;Christmas&#x27;</span>); <span class="hljs-comment">// &#x27;Twas the night before Christmas...&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="replaceAll-替换所有"><a href="#replaceAll-替换所有" class="headerlink" title="replaceAll() 替换所有"></a>replaceAll() 替换所有</h3><p>replaceAll() 方法返回一个由替换值替换所有模式匹配项后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。</p><p>接收参数：</p><ul><li>regexp | substr：regexp指一个 RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。substr指一个将被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。</li><li>newSubStr | function：newSubStr指用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。function指一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br><span class="hljs-keyword">const</span> p = <span class="hljs-string">&#x27;The fox jumps over the dog. If the dog reacted, was it really lazy?&#x27;</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/Dog/ig</span>;<br>str.replaceAll(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;bbb&#x27;</span>); <span class="hljs-comment">// &#x27;bbbbbbbbb&#x27;</span><br>p.replaceAll(regex, <span class="hljs-string">&#x27;ferret&#x27;</span>); <span class="hljs-comment">// &#x27;The fox jumps over the ferret. If the ferret reacted, was it really lazy?&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="padEnd-结尾填充"><a href="#padEnd-结尾填充" class="headerlink" title="padEnd() 结尾填充"></a>padEnd() 结尾填充</h3><p>padEnd() 方法用一个字符串从当前字符串的末尾（右侧）开始填充当前字符串，返回填充后字符串。</p><p>接收两个参数：</p><ul><li>targetLength（必需）：需填充到的目标长度。若其小于当前字符串的长度，则返回当前字符串本身。</li><li>padString （可选）：用于填充的字符串。默认为空格。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>str.padEnd(<span class="hljs-number">5</span>); <span class="hljs-comment">// &#x27;aaa  &#x27;</span><br>str.padEnd(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;s&#x27;</span>); <span class="hljs-comment">// &#x27;aaass&#x27;</span><br>str.padEnd(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;sssss&#x27;</span>); <span class="hljs-comment">// &#x27;aaass&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="padStart-开头填充"><a href="#padStart-开头填充" class="headerlink" title="padStart() 开头填充"></a>padStart() 开头填充</h3><p>padStart() 方法用一个字符串从当前字符串的开头（左侧）开始填充当前字符串，返回填充后字符串。</p><p>接收两个参数：</p><ul><li>targetLength（必需）：需填充到的目标长度。若其小于当前字符串的长度，则返回当前字符串本身。</li><li>padString （可选）：用于填充的字符串。默认为空格。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>str.padStart(<span class="hljs-number">5</span>); <span class="hljs-comment">// &#x27;  aaa&#x27;</span><br>str.padStart(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;s&#x27;</span>); <span class="hljs-comment">// &#x27;ssaaa&#x27;</span><br>str.padStart(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;sssss&#x27;</span>); <span class="hljs-comment">// &#x27;ssaaa&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="trim-删除空格"><a href="#trim-删除空格" class="headerlink" title="trim() 删除空格"></a>trim() 删除空格</h3><p>trim() 方法会将调用该方法的字符串的两端删除空白字符。</p><h3 id="trimEnd-删除结尾空格"><a href="#trimEnd-删除结尾空格" class="headerlink" title="trimEnd() 删除结尾空格"></a>trimEnd() 删除结尾空格</h3><p>trimEnd() 方法会将调用该方法的字符串的结尾删除空白字符。trimRight() 是此方法的别名。</p><h3 id="trimStart-删除开头空格"><a href="#trimStart-删除开头空格" class="headerlink" title="trimStart() 删除开头空格"></a>trimStart() 删除开头空格</h3><p>trimStart() 方法会将调用该方法的字符串的开头删除空白字符。trimLeft() 是此方法的别名。</p><h2 id="查找返回"><a href="#查找返回" class="headerlink" title="查找返回"></a>查找返回</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.prototype.at()<br><span class="hljs-built_in">String</span>.prototype.charAt()<br><span class="hljs-built_in">String</span>.prototype.indexOf()<br><span class="hljs-built_in">String</span>.prototype.lastIndexOf()<br><span class="hljs-built_in">String</span>.prototype.includes()<br><span class="hljs-built_in">String</span>.prototype.startsWith()<br><span class="hljs-built_in">String</span>.prototype.endsWith()<br><span class="hljs-built_in">String</span>.prototype.match()<br><span class="hljs-built_in">String</span>.prototype.matchAll()<br><span class="hljs-built_in">String</span>.prototype.search()<br><span class="hljs-built_in">String</span>.prototype.charCodeAt()<br><span class="hljs-built_in">String</span>.prototype.codePointAt()<br></code></pre></td></tr></table></figure><h3 id="at-由位置找元素"><a href="#at-由位置找元素" class="headerlink" title="at() 由位置找元素"></a>at() 由位置找元素</h3><p>at() 方法用于在字符串中查找给定位置对应的字符，返回该位置处的字符，找不到则返回 undefined。</p><p>接收一个参数：</p><ul><li>index（可选）。要查找的字符的位置。接受负值，默认值为 0。<br>（方括号语法只能是正整数且必须给参数）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;<br>str.at(<span class="hljs-number">5</span>); <span class="hljs-comment">// &#x27;f&#x27;</span><br>str.at(-<span class="hljs-number">3</span>); <span class="hljs-comment">// &#x27;e&#x27;</span><br>str.charAt(<span class="hljs-number">10</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="charAt-由位置找元素"><a href="#charAt-由位置找元素" class="headerlink" title="charAt() 由位置找元素"></a>charAt() 由位置找元素</h3><p>charAt() 方法用于在字符串中查找给定的一个位置，返回该位置处的字符，找不到则返回空字符串。</p><p>接收一个参数：</p><ul><li>index（可选）：要查找的字符的位置。不接受负值，默认值为 0。<br>（方括号语法只能是正整数且必须给参数）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;<br>str.charAt(<span class="hljs-number">5</span>); <span class="hljs-comment">// &#x27;f&#x27;</span><br>str.charAt(-<span class="hljs-number">3</span>); <span class="hljs-comment">// &#x27;&#x27;</span><br>str.charAt(<span class="hljs-number">10</span>); <span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="indexOf-由元素找位置"><a href="#indexOf-由元素找位置" class="headerlink" title="indexOf() 由元素找位置"></a>indexOf() 由元素找位置</h3><p>indexOf() 方法用于在字符串中查找给定字符串对应的位置，从 fromIndex 位置开始，从前向后搜索，只返回首个满足条件的位置，如果不存在则返回 -1。使用严格相等搜索元素。</p><p>接收两个参数：</p><ul><li>searchValue（必需）：指定要查找的字符串。</li><li>fromIndex（可选）：起始搜索位置。接受负值，默认值为 0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;<br>str.indexOf(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 0</span><br>str.indexOf(<span class="hljs-string">&#x27;fg&#x27;</span>); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="lastIndexOf-由元素找位置"><a href="#lastIndexOf-由元素找位置" class="headerlink" title="lastIndexOf() 由元素找位置"></a>lastIndexOf() 由元素找位置</h3><p>lastIndexOf() 方法用于在字符串中查找给定字符串对应的位置，从 fromIndex 位置开始，从后向前搜索，只返回首个满足条件的位置，如果不存在则返回 -1。使用严格相等搜索元素。</p><p>接收两个参数：</p><ul><li>searchValue（必需）：指定要查找的字符串。</li><li>fromIndex（可选）：起始搜索位置。接受负值，默认值为 0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;<br>str.lastIndexOf(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 0</span><br>str.lastIndexOf(<span class="hljs-string">&#x27;fg&#x27;</span>); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="includes-是否包含元素"><a href="#includes-是否包含元素" class="headerlink" title="includes() 是否包含元素"></a>includes() 是否包含元素</h3><p>includes() 方法用于在字符串中查找给定字符串，从 fromIndex 位置开始，从后向前搜索，返回布尔值，表示是否至少找到一个与指定字符串匹配的项。使用严格相等搜索元素。</p><p>接收两个参数：</p><ul><li>searchString（必需）：要搜索的指定的字符串。</li><li>fromIndex（可选）：起始搜索位置。接受负值，默认值为 0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;<br>str.includes(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// true</span><br>str.includes(<span class="hljs-string">&#x27;i&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="startsWith-查找是否开头"><a href="#startsWith-查找是否开头" class="headerlink" title="startsWith() 查找是否开头"></a>startsWith() 查找是否开头</h3><p>startsWith() 方法用于判断调用该方法的字符串是否以给定的字符串开头，返回布尔值。</p><p>接收两个参数：</p><ul><li>searchString（必需）：要搜索的字符串。</li><li>position（可选）：起始搜索位置。接受负值，默认值为 0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;<br>str.startsWith(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// true</span><br>str.startsWith(<span class="hljs-string">&#x27;i&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="endsWith-查找是否结尾"><a href="#endsWith-查找是否结尾" class="headerlink" title="endsWith() 查找是否结尾"></a>endsWith() 查找是否结尾</h3><p>endsWith() 方法用于判断调用该方法的字符串是否以给定的字符串结尾，返回布尔值。</p><p>接收两个参数：</p><ul><li>searchString（必需）：要搜索的字符串。</li><li>position（可选）：起始搜索位置。接受负值，默认值为 0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span>;<br>str.includes(<span class="hljs-string">&#x27;fg&#x27;</span>); <span class="hljs-comment">// true</span><br>str.lastIndexOf(<span class="hljs-string">&#x27;i&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>match() 方法检索返回一个字符串匹配正则表达式的结果。</p><p>接收参数：</p><ul><li>regexp。一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果没有给出任何参数并直接使用 match() 方法，将会得到一 个包含空字符串的 [“”] 。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> paragraph = <span class="hljs-string">&#x27;The quick brown fox jumps over the lazy dog. It barked.&#x27;</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/[A-Z]/g</span>;<br>paragraph.match(regex); <span class="hljs-comment">// [&quot;T&quot;, &quot;I&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h3><p>matchAll() 方法检索返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</p><p>接收参数：</p><ul><li>regexp。一个正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp。RegExp必须是设置了全局模式g的形式，否则会抛出异常TypeError。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/t(e)(st(\d?))/g</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;test1test2&#x27;</span>;<br><span class="hljs-keyword">const</span> array = [...str.matchAll(regexp)];<br>array[<span class="hljs-number">0</span>]; <span class="hljs-comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]</span><br>array[<span class="hljs-number">1</span>]; <span class="hljs-comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>search() 方法执行正则表达式和调用该方法的字符串之间的一个搜索匹配。</p><p>接收参数：</p><ul><li>regexp。一个正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> paragraph = <span class="hljs-string">&#x27;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#x27;</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/[^\w\s]/g</span>;<br>paragraph.search(regex); <span class="hljs-comment">// 43</span><br>paragraph[paragraph.search(regex)]; <span class="hljs-comment">// &quot;.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="charCodeAt-查找返回-UTF-16-代码"><a href="#charCodeAt-查找返回-UTF-16-代码" class="headerlink" title="charCodeAt() 查找返回 UTF-16 代码"></a>charCodeAt() 查找返回 UTF-16 代码</h3><p>charCodeAt() 方法从调用该方法的字符串中返回指定位置的字符的 UTF-16 代码单元。</p><p>接收一个参数：</p><ul><li>index（可选）：要查找的字符的位置。介于 0 到字符串长度减 1 之间，默认为 0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sentence = <span class="hljs-string">&#x27;The quick brown fox jumps over the lazy dog.&#x27;</span>;<br><span class="hljs-keyword">const</span> index = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The character code <span class="hljs-subst">$&#123;sentence.charCodeAt(index)&#125;</span> is equal to <span class="hljs-subst">$&#123;sentence.charAt(index)&#125;</span>`</span>);<br><span class="hljs-comment">// &quot;The character code 113 is equal to q&quot;</span><br></code></pre></td></tr></table></figure><h3 id="codePointAt-查找返回-Unicode-编码"><a href="#codePointAt-查找返回-Unicode-编码" class="headerlink" title="codePointAt() 查找返回 Unicode 编码"></a>codePointAt() 查找返回 Unicode 编码</h3><p>codePointAt() 方法从调用该方法的字符串中返回指定位置的字符的 Unicode 编码点值的非负整数。</p><p>接收一个参数：</p><ul><li>pos（可选）：要查找的字符的位置。介于 0 到字符串长度减 1 之间，默认为 0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;ABC&#x27;</span>.codePointAt(<span class="hljs-number">1</span>);          <span class="hljs-comment">// 66</span><br><span class="hljs-string">&#x27;\uD800\uDC00&#x27;</span>.codePointAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 65536</span><br><span class="hljs-string">&#x27;XYZ&#x27;</span>.codePointAt(<span class="hljs-number">42</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.prototype.toLowerCase()<br><span class="hljs-built_in">String</span>.prototype.toUpperCase()<br><span class="hljs-built_in">String</span>.prototype.toLocaleLowerCase()<br><span class="hljs-built_in">String</span>.prototype.toLocaleUpperCase()<br><span class="hljs-built_in">String</span>.prototype.localeCompare()<br><span class="hljs-built_in">String</span>.prototype.normalize()<br><span class="hljs-built_in">String</span>.prototype.valueOf()<br><span class="hljs-built_in">String</span>.prototype.toString()<br></code></pre></td></tr></table></figure><h3 id="toLowerCase-转小写"><a href="#toLowerCase-转小写" class="headerlink" title="toLowerCase() 转小写"></a>toLowerCase() 转小写</h3><p>toLowerCase() 方法会将调用该方法的字符串的每个字母都转为小写形式并返回。<br>（如果调用该方法的值不是字符串类型会被强制转换）</p><h3 id="toUpperCase-转大写"><a href="#toUpperCase-转大写" class="headerlink" title="toUpperCase() 转大写"></a>toUpperCase() 转大写</h3><p>toUpperCase() 方法会将调用该方法的字符串的每个字母都转为大写形式并返回。<br>（如果调用该方法的值不是字符串类型会被强制转换）</p><h3 id="toLocaleLowerCase-转本地小写"><a href="#toLocaleLowerCase-转本地小写" class="headerlink" title="toLocaleLowerCase() 转本地小写"></a>toLocaleLowerCase() 转本地小写</h3><p>toLocaleLowerCase() 方法根据本地主机语言环境把字符串转换为小写格式并返回。</p><h3 id="toLocaleUpperCase-转本地大写"><a href="#toLocaleUpperCase-转本地大写" class="headerlink" title="toLocaleUpperCase() 转本地大写"></a>toLocaleUpperCase() 转本地大写</h3><p>toLocaleUpperCase() 方法根据本地主机语言环境把字符串转换为大写格式并返回。</p><h3 id="localeCompare"><a href="#localeCompare" class="headerlink" title="localeCompare()"></a>localeCompare()</h3><p>localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。</p><h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><p>normalize() 方法会按照指定的一种 Unicode 正规形式将当前字符串正规化。</p><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><p>valueOf() 方法返回指定对象的原始值。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>toString() 方法返回指定对象的字符串形式。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>方法属性</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器面试题</title>
    <link href="/2021/09/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/09/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844904021308735502">https://juejin.cn/post/6844904021308735502</a> 。<br><a href="https://juejin.cn/post/6844903951377104903">https://juejin.cn/post/6844903951377104903</a> 。</p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="常见浏览器内核"><a href="#常见浏览器内核" class="headerlink" title="常见浏览器内核"></a>常见浏览器内核</h2><table><thead><tr><th>浏览器</th><th>内核（渲染引擎）</th><th>JavaScript 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink</td><td>V8</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>Edge</td><td>EdgeHTML</td><td>Chakra(for JavaScript)</td></tr><tr><td>IE</td><td>Trident</td><td>Chakra(for JScript)</td></tr><tr><td>PhantomJS</td><td>Webkit</td><td>JavaScriptCore</td></tr></tbody></table><h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><ul><li>跨域</li><li>同源策略</li><li>解析渲染页面</li></ul>]]></content>
    
    
    <categories>
      
      <category>运行环境</category>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划和贪婪算法</title>
    <link href="/2021/09/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    <url>/2021/09/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="剪绳子问题"><a href="#剪绳子问题" class="headerlink" title="剪绳子问题"></a>剪绳子问题</h1><blockquote><p>有一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n &gt; 1 并且 m &gt; 1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？如，当绳子的长度是 8 时，把它剪成 2、3、3 三段，此时得到的最大乘积是18。</p></blockquote><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划是编程面试中的热门话题，如果求一个问题的最优解（通常是最大值或最小值），同时该问题能够分解成若干个子问题，而且子问题之间还有重叠的更小子问题，就可以考虑用动态规划来解决这个问题。</p><p>我们在应用动态规划之前要分析能否把大问题分解成小问题，分解后的每个小问题是否存在最优解。如果把小问题的最优解组合起来能够得到整个问题的最优解，那么我们可以应用动态规划解决这个问题。</p><ul><li><p>我们如何把长度为 n 的绳子剪成若干段，使得得到的各段长度的乘积最大。这个问题的目标是求剪出的各段绳子长度的乘积最大值：<strong>求一个问题的最优解 =&gt; 应用动态规划求解问题的第一个特点</strong></p></li><li><p>我们把长度为 n 的绳子剪成若干段后得到的乘积最大值定义为函数 f(n)。假设我们把第一刀剪在长度为 i (0 &lt; i &lt; n)的位置，于是把绳子剪成长度分别为 i 和 n-i 的两段。我们要想得到整个问题的最优解 f(n)，那么要同样用最优化的方法把长度为 i 和 n-i 的两段分别剪成若干段，使得它们各自剪出的每段绳子长度乘积最大：<strong>整体问题的最优解是依赖各个子问题的最优解 =&gt; 应用动态规划求解的问题的第二个特点</strong></p></li><li><p>假设绳子最初长度为 10，我们可以把绳子剪成长度分别为 4 和 6 的两段，也就是 f(4) 和 f(6) 都是 f(10) 的子问题。接下来分别求解这两个子问题。我们可以把长度为 4 的绳子剪成均为 2 的两段，即 f(2) 是 f(4) 的子问题。同样，我们也可以把长度为 6 的绳子剪成长度分别为 2 和 4 的两段，即 f(2) 和 f(4) 都是 f(6) 的子问题。注意到， f(2) 是 f(4) 和 f(6) 公共的更小的子问题：<strong>把大问题分解成若干个小问题，这些小问题之间还有相互重叠的更小的子问题 =&gt; 应用动态规划求解的问题的第三个特点</strong></p></li><li><p>由于子问题在分解大问题的过程中重复出现，为了避免重复求解子问题，我们可以按照从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解：<strong>从上往下分析问题，从下往上解决问题  =&gt; 应用动态规划求解的问题的第四个特点</strong></p></li></ul><p>在应用动态规划解决问题的时候，我们总是从解决最小问题开始，并把已经解决的子问题的最优解存储下来(大部分面试题都是存储在一维或者二维数组里)，并把子问题的最优解组合起来逐步解决大的问题。</p><p>在应用动态规划的时候，我们每一步都可能面临若干个选择。由于我们不知道哪个才是最优的解法，只好把所有的可能都尝试一遍，然后比较得出最优方法。如果用数学的语言来表示，这就是 f(n) = max(f(i)×(n-i))，其中 0 &lt; i &lt; n。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cuttingRope</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>).fill(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>      dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i], j * (i - j), j * dp[i - j])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h1><p>贪婪算法和动态规划不一样。当应用贪婪算法解决问题的时候，每一步都可以做出一个贪婪的选择。基于此选择，我们确定能够得到最优解。为什么这样的贪婪选择能够得到最优解？需要用数学方式来证明贪婪选择是正确的。</p><p>如果绳子的长度大于 5，则每次都剪出一段长度为 3 的绳子。如果剩下的绳子的长度仍然大于 5，接着剪出一段长度为 3 的绳子。重复这个步骤，直到剩下的绳子的长度小于 5。剪出一段长度为 3 的绳子，就是我们 <strong>在每一步做出贪婪选择</strong> 。为什么这样的贪婪选择能够得到最优解？这是应用贪婪算法时，都需要问的问题：<strong>需要用数学方式来证明贪婪选择是正确的</strong> 。</p><p>首先，当 n ≥ 5 的时候，我们可以证明 2(n - 2) &gt; n并且 3(n - 3) &gt; n。也就是说，当绳子剩下的长度大于或者等于 5 的时候，我们就把它剪成长度为 3 或者 2 的绳子段。另外，当 n ≥ 5 时 3(n - 3) ≥ 2 (n - 2)，因此我们应该尽可能地多剪长度为 3 的绳子段。前面证明的前提是 n ≥ 5。那么当绳子的长度为 4 呢？在长度为 4 的绳子上剪一刀，有两种可能的结果: 2 × 2 &gt; 1 × 3，同时 2 × 2 = 4，也就是说，当绳子长度为 4 时其实没有必要剪，只是题目的要求是至少要剪一刀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cuttingRope</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 下面内容可以加上也可以去掉</span><br>  <span class="hljs-comment">// else if (n == 4) &#123;</span><br>  <span class="hljs-comment">//   return 4</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">5</span>) &#123;<br>      n = n - <span class="hljs-number">3</span>;<br>      num++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">3</span>, num) * n<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cuttingRope</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> ** (n / <span class="hljs-number">3</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n % <span class="hljs-number">3</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> ** (<span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">3</span>) - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> * <span class="hljs-number">2</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n % <span class="hljs-number">3</span> === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> ** <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">3</span>) * <span class="hljs-number">2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归和循环</title>
    <link href="/2021/09/07/%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF/"/>
    <url>/2021/09/07/%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>如果我们需要重复多次计算相同的问题，通常可以采用递归或循环两种不同的方法。</p><ul><li>递归是在一个函数的内部调用这个函数自身</li><li>循环是通过设置计算的初始值和终止条件，在一个范围内重复运算</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>递归实现的代码会比较简洁，递归实现要比循环简单得多，但性能不如循环。</p><p>递归从尾到头（自上而下）实现，循环从头到尾（自下而上）实现。</p><p>递归是函数调用其自身，而函数的调用有时间和空间的消耗。每一次调用函数，都需要在内存中分配空间以保存参数、返回地址、临时变量，而且入栈和出栈都需要时间。</p><p>递归中有可能很多计算是重复的，从而对性能带来负面影响。递归的本质是把一个问题分解成两个或者多个小问题。如果小问题内存在重叠的部分，就会存在重复的计算。</p><p>递归还有可能引起更严重的问题：调用栈溢出。每个进程的栈的容量是有限的，当递归调用的层级太多时，就会超出栈的容量导致栈溢出。不过，对此 JS 提出了尾递归优化，改善了此问题。</p><p>当使用动态规划解决问题时都是用递归的思路分析，但递归分解的子问题中存在大量的重复，因此总是使用自下而上的循环来实现代码。</p><h2 id="斐波那契数列问题"><a href="#斐波那契数列问题" class="headerlink" title="斐波那契数列问题"></a>斐波那契数列问题</h2><blockquote><p>斐波那契数列的定义如下：<br>F(0) = 0; F(1) = 1; F(N) = F(N - 1) + F(N - 2)，其中 N &gt; 1。<br>求斐波那契数列的第 n 项（即 F(N)）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">1</span> ? n : <span class="hljs-built_in">arguments</span>.callee(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">arguments</span>.callee(n - <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 循环</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, sum;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    sum = a + b;<br>    a = b;<br>    b = sum; <br>  &#125;<br>  <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h2><blockquote><p>假设你正在爬楼梯，需要 n 阶你才能到达楼顶。<br>每次可以爬 1 或 2 个台阶，有多少种不同的方法可以爬到楼顶？（n 是一个正整数）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">2</span> ? n : <span class="hljs-built_in">arguments</span>.callee(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">arguments</span>.callee(n - <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 循环</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span> ,sum;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    sum = a + b;<br>    a = b;<br>    b = sum;<br>  &#125;<br>  <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript稀疏数组与密集数组</title>
    <link href="/2021/09/06/JavaScript%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%86%E9%9B%86%E6%95%B0%E7%BB%84/"/>
    <url>/2021/09/06/JavaScript%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%86%E9%9B%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://juejin.cn/post/6975531514444562462">https://juejin.cn/post/6975531514444562462</a> 。</p><h1 id="new-Array-len"><a href="#new-Array-len" class="headerlink" title="new Array(len)"></a>new Array(len)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [empty × 5]  </span><br><span class="hljs-built_in">console</span>.log(arr.map); <span class="hljs-comment">// ƒ map() &#123; [native code] &#125;</span><br><span class="hljs-built_in">console</span>.log(arr.length); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>使用<code>new Array(len)</code>创建的数组中，Array 相应的方法、属性都存在，但数组中的元素是「empty」。</p><p>在 ECMAScript 标准中介绍了<code>new Array(len)</code>做了什么，精简一下主要干了这几件事：</p><ul><li>判断 len 是否为合法数字（小于 2^32 - 1 的正整数），如果不是则抛出错误；</li><li>创建一个 JavaScript Array 实例；</li><li>将这个实例对象的 length 属性设置为入参的值。</li></ul><p>其实，<code>const arr = new Array(len);</code> 相当于 <code>const arr = [];arr.length = len;</code>。但是，数组中此时并没有包含任何实际的元素，而且，不能理所当然地认为它包含 len 个值为 undefined 的元素。</p><h1 id="emptyVSundefined"><a href="#emptyVSundefined" class="headerlink" title="emptyVSundefined"></a><code>empty</code>VS<code>undefined</code></h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>),<br>      undefinedArr = [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>];<br><br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [empty × 2] </span><br><span class="hljs-built_in">console</span>.log(undefinedArr); <span class="hljs-comment">// [undefined, undefined]</span><br><br>arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// undefined</span><br>undefinedArr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// undefined</span><br><br>arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(item) &#125;); <span class="hljs-comment">// 无输出</span><br>undefinedArr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(item) &#125;); <span class="hljs-comment">// 输出两个 undefined  </span><br><br><span class="hljs-built_in">console</span>.log(arr.hasOwnProperty(<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(undefinedArr.hasOwnProperty(<span class="hljs-number">0</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>arr 和 undefinedArr 只有在访问单个具体元素时表现一致，在其他一些情况下大都不一样。</p><p>至于为什么 arr 在访问具体单个元素时返回 undefined，可以从 JS 引擎解析的角度去看。在 v8 源码上对于 empty 的描述是一个空的对象引用，但 JS 基本类型中并无这种类型，故用 undefined 来代替。这种表现就像我们在控制台访问一个不存在变量时，通常得到的就是 undefined。arr 由于没有任何实际的元素，所以 forEach 的 callback 并不会执行，而 undefinedArr 是有填充值的。</p><h1 id="稀疏数组和密集数组"><a href="#稀疏数组和密集数组" class="headerlink" title="稀疏数组和密集数组"></a>稀疏数组和密集数组</h1><p>如果 arr 和 undefinedArr 细分应该是两类数组，arr 类的为稀疏数组 ，undefinedArr 类的为密集数组。</p><ul><li>稀疏数组：索引不连续，数组长度大于元素个数的数组。可以简单理解为有 empty 的数组。</li><li>密集数组：索引连续，数组长度等于元素个数的数组。绝大部分数组是此类数组。</li></ul><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><ul><li>稀疏数组 =&gt; 密集数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 稀疏数组</span><br><span class="hljs-comment">// [empty × 5]</span><br><span class="hljs-comment">// ES5 方法（方法已经被废弃）</span><br><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, arr); <span class="hljs-comment">// 生成密集数组</span><br><span class="hljs-comment">// [undefined, undefined, undefined, undefined, undefined]</span><br><span class="hljs-comment">// ES6 方法</span><br><span class="hljs-built_in">Array</span>.from(arr); <span class="hljs-comment">// 生成密集数组</span><br><span class="hljs-comment">// [undefined, undefined, undefined, undefined, undefined]</span><br></code></pre></td></tr></table></figure></li><li>密集数组 =&gt; 稀疏数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]; <span class="hljs-comment">// 密集数组</span><br><span class="hljs-comment">// [2, 3, 4, 5, 6]</span><br>arr.length = <span class="hljs-number">10</span>; <span class="hljs-comment">// 生成稀疏数组</span><br><span class="hljs-comment">// [2, 3, 4, 5, 6, empty × 5]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="创建稀疏数组"><a href="#创建稀疏数组" class="headerlink" title="创建稀疏数组"></a>创建稀疏数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">const</span> arr1 = [];<br>arr1.length = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">const</span> arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 3</span><br><span class="hljs-keyword">const</span> arr3 = [,,,,,]<br></code></pre></td></tr></table></figure><h2 id="稀疏数组特性"><a href="#稀疏数组特性" class="headerlink" title="稀疏数组特性"></a>稀疏数组特性</h2><ul><li>稀疏数组在大多数遍历数组方法中，回调函数遇到「empty」元素不会执行（会跳过）</li><li>稀疏数组在访问元素的速度上比密集数组慢</li><li>稀疏数组在一些数组方法中与密集数组存在差异</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之Object方法属性</title>
    <link href="/2021/09/06/JavaScript%E4%B9%8BObject%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/09/06/JavaScript%E4%B9%8BObject%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844904094730027015">https://juejin.cn/post/6844904094730027015</a> 。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object</a> 。</p><h1 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.fromEntries()<br></code></pre></td></tr></table></figure><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p>Object.fromEntries() 方法用于把可迭代对象转换为一个对象，返回转换后新生成的对象。</p><p>接收一个参数：</p><ul><li>iterable（必需）：可迭代对象，其元素为键值对（如，两个元素的数组等）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([ [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>], [<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">42</span>] ]),<br>      arr = [ [<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>], [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>] ];<br><span class="hljs-built_in">Object</span>.fromEntries(map); <span class="hljs-comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br><span class="hljs-built_in">Object</span>.fromEntries(arr); <span class="hljs-comment">// &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="检测对象"><a href="#检测对象" class="headerlink" title="检测对象"></a>检测对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.is()<br><span class="hljs-built_in">Object</span>.isExtensible()<br><span class="hljs-built_in">Object</span>.isSealed()<br><span class="hljs-built_in">Object</span>.isFrozen()<br></code></pre></td></tr></table></figure><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>Object.is() 方法用于判断两个值是否为同一个值，返回布尔值。</p><p>Object.is() 方法和<code>===</code>运算符几乎相等，除了：</p><ul><li>Object.is() 方法将数字 -0 和 +0 视为不相等 ，将 NaN 与 NaN 视为相等。</li><li><code>===</code>运算符和<code>==</code>运算符都将数字 -0 和 +0 视为相等 ，将 NaN 与 NaN 视为不相等。</li></ul><p>接收两个参数：</p><ul><li>value1（必需）：被比较的第一个值。</li><li>value2（必需）：被比较的第二个值。</li></ul><h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h3><p>Object.isExtensible() 方法用于判断一个对象是否可扩展（是否可以在它上面添加新属性），返回布尔值。</p><p>默认情况下，对象是可扩展的：即可以为他们添加新的属性。以及它们的 <strong>proto</strong> 属性可以被更改。Object.preventExtensions()、Object.seal()、Object.freeze() 方法都可以标记一个对象为不可扩展。</p><p>接收一个参数：</p><ul><li>obj（必需）：被检测的对象。</li></ul><h3 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed()"></a>Object.isSealed()</h3><p>Object.isSealed() 方法用于判断一个对象是否被密封，返回布尔值。</p><p>一个对象是密封的是指它不可扩展，且所有自身属性都不可配置，故不可删除（但不一定不可写）的对象。</p><p>接收一个参数：</p><ul><li>obj（必需）：被检测的对象。</li></ul><h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h3><p>Object.isFrozen() 方法用于判断一个对象是否被冻结，返回布尔值。</p><p>一个对象是冻结的是指它不可扩展，所有属性都是不可配置的，且所有数据属性（即没有 getter 或者 setter 组件的访问器的属性）都是不可写的。</p><p>接收一个参数：</p><ul><li>obj（必需）：被检测的对象。</li></ul><h2 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign()<br><span class="hljs-built_in">Object</span>.create()<br><span class="hljs-built_in">Object</span>.preventExtensions()<br><span class="hljs-built_in">Object</span>.seal()<br><span class="hljs-built_in">Object</span>.freeze()<br></code></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>Object.assign() 方法用于把一个或多个源对象的所有 <strong>可枚举属性</strong> 从分配到目标对象，返回目标对象。<br>（浅拷贝一个或多个源对象分配到目标对象）</p><p>接收参数：</p><ul><li>target（必需）：目标对象。</li><li>sources（至少一个）：源对象，可以有多个。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> aaa = &#123;<span class="hljs-attr">score</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jeff&#x27;</span>&#125;;<br><br><span class="hljs-built_in">Object</span>.assign(&#123;&#125;, aaa, &#123;<span class="hljs-attr">score</span>: <span class="hljs-number">2</span>&#125;); <span class="hljs-comment">// &#123;score: 2, name: &#x27;Jeff&#x27;&#125;</span><br><span class="hljs-built_in">console</span>.log(aaa);                   <span class="hljs-comment">// &#123;score: 1, name: &#x27;Jeff&#x27;&#125;</span><br><br><span class="hljs-keyword">let</span> bbb = &#123;...aaa, <span class="hljs-attr">score</span>: <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// 和上面使用 Object.assign() 效果一样。</span><br><span class="hljs-built_in">console</span>.log(aaa); <span class="hljs-comment">// &#123;score: 1, name: &#x27;Jeff&#x27;&#125;</span><br><span class="hljs-built_in">console</span>.log(bbb); <span class="hljs-comment">// &#123;score: 2, name: &#x27;Jeff&#x27;&#125;</span><br><br><span class="hljs-built_in">Object</span>.assign(aaa, &#123;<span class="hljs-attr">score</span>: <span class="hljs-number">2</span>&#125;); <span class="hljs-comment">// &#123;score: 2, name: &#x27;Jeff&#x27;&#125;</span><br><span class="hljs-built_in">console</span>.log(aaa);               <span class="hljs-comment">// &#123;score: 2, name: &#x27;Jeff&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>Object.create() 方法用于使用指定的原型对象和属性创建一个新对象，返回创建的新对象。<br>（原型式继承，原型模式的封装）</p><p>接收两个参数：</p><ul><li>proto（必需）：新创建对象的原型对象。</li><li>propertiesObject（可选）：需要传入一个对象，该对象的属性类型参照 Object.defineProperties() 的第二个参数。如果该参数被指定且不为 undefined，该传入对象的自有可枚举属性(即其自身定义的属性，而不是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符。</li></ul><h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h3><p>Object.preventExtensions() 方法用于让一个对象不可扩展，也就是永远不能再添加新的属性。返回不可扩展的对象。</p><p>如果一个对象可以添加新的属性，则这个对象是可扩展的。Object.preventExtensions() 将对象标记为不再可扩展，这样它将永远不会具有它被标记为不可扩展时持有的属性之外的属性。注意一般来说，不可扩展对象的属性可能仍然可被删除。尝试将新属性添加到不可扩展对象将静默失败或抛出 TypeError（最常见的情况是 strict mode 中，但不排除其他情况）。</p><p>Object.preventExtensions() 方法仅阻止添加自身的属性。但是其对象类型的原型依然可以添加新的属性。该方法使得目标对象的 [[prototype]] 不可变；任何重新赋值 [[prototype]] 操作都会抛出 TypeError 。这种行为只针对内部的 [[prototype]] 属性， 目标对象的其它属性将保持可变。</p><p>一旦将对象变为不可扩展的对象，就再也不能使其可扩展。</p><p>接收一个参数：</p><ul><li>obj（必需）：被操作的对象。</li></ul><h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h3><p>Object.seal() 方法用于封闭一个对象，阻止添加新属性，并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。返回被封闭的对象。</p><p>通常，一个对象是可扩展的（可以添加新的属性）。密封一个对象会让这个对象变的不能添加新属性，并且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出 TypeError。</p><p>不会影响从原型链上继承的属性。但 <strong>proto</strong> 属性的值也会不能修改。</p><p>接收一个参数：</p><ul><li>obj（必需）：被操作的对象。</li></ul><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><p>Object.freeze() 方法用于冻结一个对象，一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。返回被冻结的对象。</p><p>被冻结对象自身的所有属性都不可能以任何方式被修改。任何的修改尝试都会失败，无论是静默地还是通过抛出 TypeError 异常（最常见但不仅限于 strict mode）。</p><p>数据属性的值不可更改，访问器属性（有 getter 和 setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改。没有数组元素可以被添加或移除。</p><p>接收一个参数：</p><ul><li>obj（必需）：被操作的对象。</li></ul><h2 id="查看对象"><a href="#查看对象" class="headerlink" title="查看对象"></a>查看对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.setPrototypeOf()<br><span class="hljs-built_in">Object</span>.getPrototypeOf()<br><span class="hljs-built_in">Object</span>.defineProperty()<br><span class="hljs-built_in">Object</span>.defineProperties()<br><span class="hljs-built_in">Object</span>.hasOwn()<br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor()<br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors()<br><span class="hljs-built_in">Object</span>.getOwnPropertyNames()<br><span class="hljs-built_in">Object</span>.getOwnPropertySymbols()<br><span class="hljs-built_in">Object</span>.getPrototypeOf()<br><span class="hljs-built_in">Object</span>.keys()<br><span class="hljs-built_in">Object</span>.values()<br><span class="hljs-built_in">Object</span>.entries()<br></code></pre></td></tr></table></figure><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>Object.setPrototypeOf() 方法用于为指定对象设置原型对象，返回指定对象。</p><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf() 方法用于得到指定对象的原型对象，返回指定对象的原型对象。</p><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>Object.defineProperty() 方法用于直接在指定对象上定义一个新属性，或者修改指定对象的现有属性，并返回此对象。</p><p>接收三个参数：</p><ul><li>obj（必需）：要定义或修改属性的对象。</li><li>prop（必需）：要定义或修改的属性的名称或 Symbol 类型。</li><li>descriptor（必需）：要定义或修改的属性描述符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;property1&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-comment">// &#123;property1: 42&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><p>Object.defineProperties() 方法用于直接在指定对象上定义多个新属性，或者修改多个指定对象的现有属性，并返回此对象。</p><p>接收两个参数：</p><ul><li>obj（必需）：要在其上定义或修改属性的对象。</li><li>props（必需）：要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符共有两种：数据描述符和访问器描述符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperties(obj, &#123;<br>  <span class="hljs-string">&#x27;property1&#x27;</span>: &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;,<br>  <span class="hljs-string">&#x27;property2&#x27;</span>: &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;<br>&#125;);<br><span class="hljs-comment">// &#123;property1: true, property2: &#x27;Hello&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Object-hasOwn"><a href="#Object-hasOwn" class="headerlink" title="Object.hasOwn()"></a>Object.hasOwn()</h3><p>实验中，类似于 Object.prototype.hasOwnProperty() 方法。<br>Object.hasOwn() 方法用于判断 <strong>指定对象自身上</strong> 是否具有指定的属性，返回布尔值。<br>（<strong>可枚举属性</strong> 和 <strong>不可枚举属性</strong> 都可以判断）<br>（in 操作符会在可以通过对象访问指定属性时返回 true，而无论这个属性是在实例上还是在原型上）</p><p>接收两个参数：</p><ul><li>obj（必需）：用于判断的指定对象。</li><li>props（必需）：用于判断的指定属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;oa&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;ob&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>o.oc = <span class="hljs-number">333</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">555</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>obj.c = <span class="hljs-number">666</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;oa&#x27;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;ob&#x27;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;oc&#x27;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;a&#x27;</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// true</span><br><br>obj.oa = <span class="hljs-number">777</span>;<br>obj.ob = <span class="hljs-number">888</span>;<br>obj.oc = <span class="hljs-number">999</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, ob: 888, oc: 999, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;oa&#x27;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;ob&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;oc&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;a&#x27;</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.hasOwn(obj, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>Object.getOwnPropertyNames() 方法用于返回一个数组，其包含 <strong>指定对象自身上的</strong> 所有的属性名。<br>（<strong>可枚举属性</strong> 和 <strong>不可枚举属性</strong> 都会返回）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;oa&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;ob&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>o.oc = <span class="hljs-number">333</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">555</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>obj.c = <span class="hljs-number">666</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><br>obj.oa = <span class="hljs-number">777</span>;<br>obj.ob = <span class="hljs-number">888</span>;<br>obj.oc = <span class="hljs-number">999</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, ob: 888, oc: 999, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;ob&#x27;, &#x27;oc&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h3><p>Object.getOwnPropertySymbols() 方法用于返回一个数组，其包含 <strong>指定对象自身上的</strong> 所有的符号属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;oa&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;ob&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>o.oc = <span class="hljs-number">333</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">555</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>obj.c = <span class="hljs-number">666</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.getOwnPropertySymbols(obj); <span class="hljs-comment">// []</span><br><br>obj.oa = <span class="hljs-number">777</span>;<br>obj.ob = <span class="hljs-number">888</span>;<br>obj.oc = <span class="hljs-number">999</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, ob: 888, oc: 999, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj); <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>Object.getOwnPropertyDescriptor() 方法用于返回 <strong>指定对象自身上的</strong> 指定的属性配置。<br>（<strong>可枚举属性</strong> 和 <strong>不可枚举属性</strong> 都可以返回）</p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>Object.getOwnPropertyDescriptors() 方法用于返回 <strong>指定对象自身上的</strong> 所有的属性配置。<br>（<strong>可枚举属性</strong> 和 <strong>不可枚举属性</strong> 都会返回）</p><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>Object.keys() 方法返回一个数组，其包含了 <strong>指定对象自身上的</strong> <strong>可枚举属性的</strong> 属性名。数组中值的排列顺序和使用 for-in 循环遍历该对象时返回的顺序一致（区别是 for-in 循环还会枚举原型链中的属性）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;oa&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;ob&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>o.oc = <span class="hljs-number">333</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">555</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>obj.c = <span class="hljs-number">666</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.keys(obj); <span class="hljs-comment">// [&#x27;c&#x27;]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> aaa <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(aaa);<br>&#125;<br><span class="hljs-comment">// c</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> bbb <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(bbb);<br>&#125;<br><span class="hljs-comment">// c</span><br><span class="hljs-comment">// oc</span><br><br>obj.oa = <span class="hljs-number">777</span>;<br>obj.ob = <span class="hljs-number">888</span>;<br>obj.oc = <span class="hljs-number">999</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, ob: 888, oc: 999, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.keys(obj); <span class="hljs-comment">// [&#x27;c&#x27;, &#x27;ob&#x27;, &#x27;oc&#x27;]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> aaa <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(aaa);<br>&#125;<br><span class="hljs-comment">// c</span><br><span class="hljs-comment">// ob</span><br><span class="hljs-comment">// oc</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> bbb <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(bbb);<br>&#125;<br><span class="hljs-comment">// c</span><br><span class="hljs-comment">// ob</span><br><span class="hljs-comment">// oc</span><br></code></pre></td></tr></table></figure><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>Object.values() 方法返回一个数组，其包含了 <strong>指定对象自身上的</strong> <strong>可枚举属性的</strong> 属性值。数组中值的排列顺序和使用 for-in 循环遍历该对象时返回的顺序一致（区别是 for-in 循环还会枚举原型链中的属性）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;oa&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;ob&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>o.oc = <span class="hljs-number">333</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">555</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>obj.c = <span class="hljs-number">666</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.values(obj); <span class="hljs-comment">// [666]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> aaa <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.values(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(aaa);<br>&#125;<br><span class="hljs-comment">// 666</span><br><br>obj.oa = <span class="hljs-number">777</span>;<br>obj.ob = <span class="hljs-number">888</span>;<br>obj.oc = <span class="hljs-number">999</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, ob: 888, oc: 999, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.values(obj); <span class="hljs-comment">// [666, 888, 999]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> aaa <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.values(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(aaa);<br>&#125;<br><span class="hljs-comment">// 666</span><br><span class="hljs-comment">// 888</span><br><span class="hljs-comment">// 999</span><br></code></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>Object.entries() 方法返回一个数组，其包含了 <strong>指定对象自身上的</strong> <strong>可枚举属性的</strong> 属性键值对组。数组中值的排列顺序和使用 for-in 循环遍历该对象时返回的顺序一致（区别是 for-in 循环还会枚举原型链中的属性）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;oa&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;ob&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>o.oc = <span class="hljs-number">333</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">555</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>obj.c = <span class="hljs-number">666</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.entries(obj); <span class="hljs-comment">// [[&#x27;c&#x27;, 666]]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> aaa <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(aaa);<br>&#125;<br><span class="hljs-comment">// [&#x27;c&#x27;, 666]</span><br><br>obj.oa = <span class="hljs-number">777</span>;<br>obj.ob = <span class="hljs-number">888</span>;<br>obj.oc = <span class="hljs-number">999</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, ob: 888, oc: 999, a: 444, b: 555&#125;</span><br><span class="hljs-built_in">Object</span>.entries(obj); <span class="hljs-comment">// [[&#x27;c&#x27;, 666], [&#x27;ob&#x27;, 888], [&#x27;oc&#x27;, 999]]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> aaa <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(aaa);<br>&#125;<br><span class="hljs-comment">// [&#x27;c&#x27;, 666]</span><br><span class="hljs-comment">// [&#x27;ob&#x27;, 888]</span><br><span class="hljs-comment">// [&#x27;oc&#x27;, 999]</span><br></code></pre></td></tr></table></figure><h1 id="对象实例属性"><a href="#对象实例属性" class="headerlink" title="对象实例属性"></a>对象实例属性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.constructor<br><span class="hljs-built_in">Object</span>.prototype.__proto__<br></code></pre></td></tr></table></figure><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>constructor 属性用于返回或设置原型对象对应的构造函数。</p><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>__proto__ 属性用于返回或设置创建该对象的构造函数的原型对象。<br>（建议用 Object.getPrototypeOf() 方法替换该属性）</p><h1 id="对象实例方法"><a href="#对象实例方法" class="headerlink" title="对象实例方法"></a>对象实例方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf()<br><span class="hljs-built_in">Object</span>.prototype.hasOwnProperty()<br><span class="hljs-built_in">Object</span>.prototype.propertyIsEnumerable()<br><span class="hljs-built_in">Object</span>.prototype.valueOf()<br><span class="hljs-built_in">Object</span>.prototype.toString()<br><span class="hljs-built_in">Object</span>.prototype.toLocaleString()<br></code></pre></td></tr></table></figure><h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h2><p>isPrototypeOf() 方法用于判断 <strong>指定对象</strong> 是否在给定对象的原型链上，返回布尔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;oa&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;ob&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>o.oc = <span class="hljs-number">333</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">555</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>obj.c = <span class="hljs-number">666</span>;<br><br>o.isPrototypeOf(obj); <span class="hljs-comment">// true</span><br>obj.isPrototypeOf(o); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h2><p>hasOwnProperty() 方法用于判断 <strong>指定对象自身上</strong> 是否具有指定的属性，返回布尔值。<br>（<strong>可枚举属性</strong> 和 <strong>不可枚举属性</strong> 都可以判断）<br>（in 操作符会在可以通过对象访问指定属性时返回 true，而无论这个属性是在实例上还是在原型上）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;oa&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;ob&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>o.oc = <span class="hljs-number">333</span>;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">444</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;b&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">555</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;);<br>obj.c = <span class="hljs-number">666</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, a: 444, b: 555&#125;</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;oa&#x27;</span>); <span class="hljs-comment">// false</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;ob&#x27;</span>); <span class="hljs-comment">// false</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;oc&#x27;</span>); <span class="hljs-comment">// false</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;a&#x27;</span>);  <span class="hljs-comment">// true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">// true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// true</span><br><br><br>obj.oa = <span class="hljs-number">777</span>;<br>obj.ob = <span class="hljs-number">888</span>;<br>obj.oc = <span class="hljs-number">999</span>;<br><br>obj; <span class="hljs-comment">// &#123;c: 666, ob: 888, oc: 999, a: 444, b: 555&#125;</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;oa&#x27;</span>); <span class="hljs-comment">// false</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;ob&#x27;</span>); <span class="hljs-comment">// true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;oc&#x27;</span>); <span class="hljs-comment">// true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;a&#x27;</span>);  <span class="hljs-comment">// true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">// true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable()"></a>propertyIsEnumerable()</h2><p>propertyIsEnumerable() 方法用于判断 <strong>指定对象自身上</strong> 指定的属性是否可被枚举，返回布尔值。</p><h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h2><p>valueOf() 方法返回指定对象的原始值。</p><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>toString() 方法返回指定对象的字符串形式。</p><p>可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。</p><h2 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h2><p>toLocaleString() 方法用于反映对象所在的本地化执行环境，返回一个表示该对象的字符串。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>方法属性</tag>
      
      <tag>Object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之Array方法属性</title>
    <link href="/2021/09/01/JavaScript%E4%B9%8BArray%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/09/01/JavaScript%E4%B9%8BArray%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://juejin.cn/post/6844903614918459406">https://juejin.cn/post/6844903614918459406</a> 。</li><li><a href="https://juejin.cn/post/6844903945173729288">https://juejin.cn/post/6844903945173729288</a> 。</li><li><a href="https://juejin.cn/post/6945996368880091173">https://juejin.cn/post/6945996368880091173</a> 。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a> 。</li></ol><h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>()<br><span class="hljs-comment">// ES5：</span><br><span class="hljs-built_in">Array</span>.isArray()<br><span class="hljs-comment">// ES6：</span><br><span class="hljs-built_in">Array</span>.of() <br><span class="hljs-built_in">Array</span>.from()<br></code></pre></td></tr></table></figure><h2 id="Array-数组构造器"><a href="#Array-数组构造器" class="headerlink" title="Array() 数组构造器"></a>Array() 数组构造器</h2><p>Array() 用于创建数组对象，返回新创建的数组。</p><p>接收参数：</p><ul><li>elementN。数组构造器会根据给定的元素创建一个数组，但是当仅有一个参数且为数字时除外（详见下面的 arrayLength 参数）。注意，后者仅适用于用数组构造器创建数组，而不适用于用方括号创建的数组字面量。</li><li>arrayLength。如果传递给数组构造器的唯一参数是 0 到 2<sup>32</sup> - 1（包括）之间的整数，这将返回一个新数组，新数组 length 属性设置为 arrayLength（注意：这意味着一个 arrayLength 空槽数组，而不是具有实际 undefined 值的槽（稀疏数组））。</li></ul><p>注意，Array() 可以调用或不调用 new。两者都会创建一个新的数组实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// [empty × 7]</span><br><span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>); <span class="hljs-comment">// [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;]</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// [empty × 7]</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>); <span class="hljs-comment">// [&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;]</span><br><br>[<span class="hljs-number">7</span>] <span class="hljs-comment">// [7]</span><br></code></pre></td></tr></table></figure><h2 id="Array-isArray-是否是数组"><a href="#Array-isArray-是否是数组" class="headerlink" title="Array.isArray() 是否是数组"></a>Array.isArray() 是否是数组</h2><p>Array.isArray() 方法用于确定一个值是否为数组，不管该值是在哪个全局执行上下文中创建的，返回布尔值。</p><h2 id="Array-of-创建数组"><a href="#Array-of-创建数组" class="headerlink" title="Array.of() 创建数组"></a>Array.of() 创建数组</h2><p>Array.of() 方法用于将任意数量的参数转换为数组，返回新创建的数组。</p><p>接收参数：</p><ul><li>要组成数组的参数。可以是任意数量。</li></ul><p>Array.of() 和 Array() 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，Array(7) 创建一个长度为 7 的空数组（这里是指有 7 个空位的数组，而不是 7 个 undefined 组成的数组）。<br>Array.of() 和 方括号的数组字面量的规则一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// [1, 2, 3, 4] </span><br><span class="hljs-built_in">Array</span>.of(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [undefined]</span><br><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">7</span>); <span class="hljs-comment">// [7]</span><br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]; <span class="hljs-comment">// [1, 2, 3, 4] </span><br>[<span class="hljs-literal">undefined</span>]; <span class="hljs-comment">// [undefined]</span><br>[<span class="hljs-number">7</span>]; <span class="hljs-comment">// [7]</span><br></code></pre></td></tr></table></figure><h2 id="Array-from-创建数组"><a href="#Array-from-创建数组" class="headerlink" title="Array.from() 创建数组"></a>Array.from() 创建数组</h2><p>Array.from() 方法用于将一个可迭代对象或伪数组对象转换为数组，返回新创建的数组。</p><p>接收三个参数：</p><ul><li>arrayLike（必需）。任何可迭代对象或类数组对象。</li><li>mapFn（可选）。arrayLike 的每个元素会执行该回调函数。这个函数可以直接增强新数组的值，类似 Array.prototype.map() 方法，对元素进行处理，将处理后的值放入新创建的数组。</li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj0 = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;c&#x27;</span>&#125;,<br>      obj1 = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>&#125;,<br>      arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]; <br><span class="hljs-built_in">Array</span>.from(obj0); <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Array</span>.from(obj1); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="hljs-built_in">Array</span>.from(arr, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x**<span class="hljs-number">2</span>); <span class="hljs-comment">// [1, 4, 9, 16]</span><br><span class="hljs-built_in">Array</span>.from(<span class="hljs-string">&quot;Matt&quot;</span>); <span class="hljs-comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]</span><br></code></pre></td></tr></table></figure><h1 id="数组实例属性"><a href="#数组实例属性" class="headerlink" title="数组实例属性"></a>数组实例属性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.length<br></code></pre></td></tr></table></figure><h2 id="length-数组长度"><a href="#length-数组长度" class="headerlink" title="length 数组长度"></a>length 数组长度</h2><p>length 属性用于返回或设置数组的元素个数（数组的长度），可以设置该属性来改变数组的元素个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.length; <span class="hljs-comment">// 5</span><br>arr.length = <span class="hljs-number">2</span>;<br>arr; <span class="hljs-comment">// [1, 2]</span><br>arr.length = <span class="hljs-number">10</span>;<br>arr; <span class="hljs-comment">// [1, 2, empty × 8]</span><br></code></pre></td></tr></table></figure><h1 id="数组实例方法"><a href="#数组实例方法" class="headerlink" title="数组实例方法"></a>数组实例方法</h1><h2 id="操作改变数组"><a href="#操作改变数组" class="headerlink" title="操作改变数组"></a>操作改变数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 操作改变数组</span><br><span class="hljs-comment">// ES5：</span><br><span class="hljs-built_in">Array</span>.prototype.pop()<br><span class="hljs-built_in">Array</span>.prototype.shift()<br><span class="hljs-built_in">Array</span>.prototype.push()<br><span class="hljs-built_in">Array</span>.prototype.unshift()<br><span class="hljs-built_in">Array</span>.prototype.splice()<br><span class="hljs-built_in">Array</span>.prototype.sort()<br><span class="hljs-built_in">Array</span>.prototype.reverse() <br><span class="hljs-comment">// ES6：</span><br><span class="hljs-built_in">Array</span>.prototype.fill()<br><span class="hljs-built_in">Array</span>.prototype.copyWithin()<br></code></pre></td></tr></table></figure><h3 id="pop-末尾删除"><a href="#pop-末尾删除" class="headerlink" title="pop() 末尾删除"></a>pop() 末尾删除</h3><p>pop() 方法用于删除数组中的最后一个元素，返回被删除的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.pop();  <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="shift-开头删除"><a href="#shift-开头删除" class="headerlink" title="shift() 开头删除"></a>shift() 开头删除</h3><p>shift() 方法用于删除数组中的第一个元素，返回被删除的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.shift();  <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="push-末尾添加"><a href="#push-末尾添加" class="headerlink" title="push() 末尾添加"></a>push() 末尾添加</h3><p>push() 方法用于向数组的末尾添加一个或多个元素，返回添加元素后数组的元素个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.push(<span class="hljs-string">&#x27;456&#x27;</span>,<span class="hljs-string">&#x27;789&#x27;</span>); <span class="hljs-comment">// 5</span><br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//  [1, 2, 3, &quot;456&quot;, &quot;789&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="unshift-开头添加"><a href="#unshift-开头添加" class="headerlink" title="unshift() 开头添加"></a>unshift() 开头添加</h3><p>unshift() 方法用于向数组的开头添加一个或多个元素，返回添加元素后数组的元素个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.unshift(<span class="hljs-string">&#x27;000&#x27;</span>, <span class="hljs-string">&#x27;111&#x27;</span>); <span class="hljs-comment">// 5</span><br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//  [&quot;000&quot;, &quot;111&quot;, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="fill-填充替换"><a href="#fill-填充替换" class="headerlink" title="fill() 填充替换"></a>fill() 填充替换</h3><p>fill() 方法用于给数组填充一个给定的值，返回填充替换后的数组。</p><p>接收三个参数：</p><ul><li>value（必需）。用来填充的值。</li><li>start（可选）。替换的起始位置，替换含该位置。默认值为 0，接收负数。</li><li>end（可选）。替换的结束位置，替换不含该位置。默认值为数组的长度，接收负数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>      b = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> , <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<br>a.fill(<span class="hljs-string">&#x27;000&#x27;</span>); <span class="hljs-comment">// [&quot;000&quot;, &quot;000&quot;, &quot;000&quot;]</span><br>b.fill(<span class="hljs-string">&#x27;000&#x27;</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// [4, 5, 6, 7, &#x27;000&#x27;, 9]</span><br>b.fill(<span class="hljs-string">&#x27;666&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// [4, 5, 6, &#x27;666&#x27;, &#x27;666&#x27;, 9]</span><br></code></pre></td></tr></table></figure><h3 id="copyWithin-复制替换"><a href="#copyWithin-复制替换" class="headerlink" title="copyWithin() 复制替换"></a>copyWithin() 复制替换</h3><p>copyWithin() 方法用于浅复制数组的一部分到同一数组中的其他位置，返回复制替换后的数组。</p><p>接收三个参数：</p><ul><li>target（必需）。替换的起始位置。接收负数。</li><li>start（可选）。浅复制元素的起始位置，复制含该位置。默认值为 0，接收负数。</li><li>end（可选）。浅复制元素的结束位置，复制不含该位置。默认值为数组的长度，接收负数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>      b = [<span class="hljs-string">&#x27;O1&#x27;</span>, <span class="hljs-string">&#x27;K1&#x27;</span>, <span class="hljs-string">&#x27;O2&#x27;</span>, <span class="hljs-string">&#x27;K2&#x27;</span>, <span class="hljs-string">&#x27;O3&#x27;</span>, <span class="hljs-string">&#x27;K3&#x27;</span>];<br>a.copyWithin(<span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// [4, 2, 3, 4, 5]</span><br>b.copyWithin(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// [&quot;O1&quot;, &quot;K1&quot;, &quot;K2&quot;, &quot;O3&quot;, &quot;O3&quot;, &quot;K3&quot;] </span><br></code></pre></td></tr></table></figure><h3 id="splice-修改"><a href="#splice-修改" class="headerlink" title="splice() 修改"></a>splice() 修改</h3><p>splice() 方法通过删除或替换现有元素或原地添加新的元素的方式来修改数组，返回被删除的元素。<br>（以数组的方式返回，没有元素被删除则返回空数组）</p><p>接收参数：</p><ul><li>start（必需）。修改的开始位置。如果超出数组的长度，则从数组末尾开始修改可接受负数。</li><li>deleteCount（可选）。表示要删除的数组元素的个数。如果被省略或者大于 start 之后的元素的总数，则从 start 后面的元素都将被删除。如果为 0 则不会删除元素。</li><li>item1，item2，…（可选）。向数组添加的任意数量元素。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>],<br>      b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br>a.splice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// [4, 5, 6, 7]</span><br>b.splice(-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [7]</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>],<br>      b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br>a.splice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;添加&#x27;</span>); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// [&#x27;添加&#x27;, 4, 5 ,6, 7]</span><br>b.splice(-<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;添加1&#x27;</span>, <span class="hljs-string">&#x27;添加2&#x27;</span>); <span class="hljs-comment">// [6, 7]</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// [1, 2, 3, 4, 5, &#x27;添加1&#x27;, &#x27;添加2&#x27;]</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>],<br>      b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br>a.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;添加1&#x27;</span>, <span class="hljs-string">&#x27;添加2&#x27;</span>); <span class="hljs-comment">// []</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// [&#x27;添加1&#x27;, &#x27;添加2&#x27;, 1, 2, 3, 4, 5, 6, 7]</span><br>b.splice(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;添加1&#x27;</span>, <span class="hljs-string">&#x27;添加2&#x27;</span>); <span class="hljs-comment">// []</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6, &#x27;添加1&#x27;, &#x27;添加2&#x27;, 7] </span><br></code></pre></td></tr></table></figure><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort() 排序"></a>sort() 排序</h3><p>sort() 方法用于对数组元素使用原地算法进行排序，返回排序后的数组。由于它取决于具体的实现，因此无法保证排序的时间复杂度和空间复杂度。</p><p>接收一个参数：</p><ul><li>compareFunction（可选）。用来指定按某种顺序进行排列的函数。默认按字母升序排序，若元素不是字符串，会调用 toString() 方法将元素转化为字符串的 Unicode 位点，然后再比较。<ul><li>firstEl：第一个用于比较的元素。</li><li>secondEl：第二个用于比较的元素。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>],<br>      b = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">8</span>],<br>      c = [<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">8</span>];<br>a.sort(); <span class="hljs-comment">// [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Mango&quot;, &quot;Orange&quot;]</span><br>b.sort(); <span class="hljs-comment">// [1, 10, 20, 25, 3, 8]</span><br>c.sort(<span class="hljs-function">(<span class="hljs-params">n1, n2</span>) =&gt;</span> n1 &gt; n2 ? <span class="hljs-number">1</span> : n1 &lt; n2 ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>); <span class="hljs-comment">// [1, 3, 8, 10, 20, 25]</span><br></code></pre></td></tr></table></figure><h3 id="reverse-颠倒"><a href="#reverse-颠倒" class="headerlink" title="reverse() 颠倒"></a>reverse() 颠倒</h3><p>reverse() 方法用于颠倒数组中的元素，返回颠倒后的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>a.reverse(); <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure><h2 id="操作不改变数组"><a href="#操作不改变数组" class="headerlink" title="操作不改变数组"></a>操作不改变数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 操作不改变数组</span><br><span class="hljs-comment">// ES5：</span><br><span class="hljs-built_in">Array</span>.prototype.slice()<br><span class="hljs-built_in">Array</span>.prototype.concat()<br><span class="hljs-built_in">Array</span>.prototype.indexOf()<br><span class="hljs-built_in">Array</span>.prototype.lastIndexOf()<br><span class="hljs-built_in">Array</span>.prototype.join()<br><span class="hljs-built_in">Array</span>.prototype.toString()<br><span class="hljs-built_in">Array</span>.prototype.toLocaleString()<br><span class="hljs-comment">// ES7：</span><br><span class="hljs-built_in">Array</span>.prototype.includes() <br><span class="hljs-comment">// ES10：</span><br><span class="hljs-built_in">Array</span>.prototype.flat()<br><span class="hljs-built_in">Array</span>.prototype.flatMap()<br><span class="hljs-comment">// 实验中：</span><br><span class="hljs-built_in">Array</span>.prototype.at()<br></code></pre></td></tr></table></figure><h3 id="slice-提取"><a href="#slice-提取" class="headerlink" title="slice() 提取"></a>slice() 提取</h3><p>slice() 方法用于将数组的一部分提取到一个新数组，返回新数组。</p><p>接收两个参数：</p><ul><li>start（可选）。从该位置开始提取原数组中的元素。默认值为 0，接受负值。</li><li>end（可选）。在该位置前结束提取原数组中的元素。默认值为数组的长度加 1，接受负值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>];<br>a.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// [&#x27;hello&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="concat-合并"><a href="#concat-合并" class="headerlink" title="concat() 合并"></a>concat() 合并</h3><p>concat() 方法用于合并任意数量的值或数组为一个新数组，返回新数组。<br>合并时，是对数组的浅拷贝。</p><p>接收参数：</p><ul><li>valueN。可以是具体的值，也可以是数组。可以是任意多个。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>      b = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>      c = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],<br>      d = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>      f = [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>]];<br>a.concat(b); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br>a.concat(b, c); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br>a.concat(<span class="hljs-string">&#x27;添加元素&#x27;</span>, b, c); <span class="hljs-comment">// [1, 2, 3, &quot;添加元素&quot;, 4, 5, 6, 7, 8, 9]</span><br>d.concat(f); <span class="hljs-comment">// [1, 2, 3, [4]]</span><br></code></pre></td></tr></table></figure><h3 id="flat-拉平"><a href="#flat-拉平" class="headerlink" title="flat() 拉平"></a>flat() 拉平</h3><p>flat() 方法用于对数组按照指定的深度递归遍历，将所有遍历到的元素合并为一个新数组并返回。</p><p>接收参数：</p><ul><li>depth（可选）。指定要提取嵌套数组的结构深度，默认值为 1。使用 Infinity，可展开任意深度的嵌套数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]],<br>      arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]],<br>      arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]]]],<br>      arr4 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, , <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr1.flat(); <span class="hljs-comment">// [1, 2, 3, 4]</span><br>arr2.flat(); <span class="hljs-comment">// [1, 2, 3, 4, [5, 6]]</span><br>arr2.flat(<span class="hljs-number">2</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br>arr3.flat(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br>arr4.flat(); <span class="hljs-comment">// [1, 2, 4, 5]</span><br></code></pre></td></tr></table></figure><h3 id="flatMap-调用拉平"><a href="#flatMap-调用拉平" class="headerlink" title="flatMap() 调用拉平"></a>flatMap() 调用拉平</h3><p>flatMap() 方法用于对数组先进行<code>Array.prototype.map()</code>方法，再对返回的新数组进行 depth 为 1 的<code>Array.prototype.flat()</code>方法 ，返回最终拉平后返回的新数组。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&quot;it&#x27;s Sunny in&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;China&quot;</span>];<br>arr1.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.split(<span class="hljs-string">&quot; &quot;</span>)); <span class="hljs-comment">// [[&quot;it&#x27;s&quot;,&quot;Sunny&quot;,&quot;in&quot;],[&quot;&quot;],[&quot;China&quot;]]</span><br>arr1.flatMap(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.split(<span class="hljs-string">&quot; &quot;</span>)); <span class="hljs-comment">// [&quot;it&#x27;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;China&quot;]</span><br><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr2.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x * <span class="hljs-number">2</span>]); <span class="hljs-comment">// [[2], [4], [6], [8]]</span><br>arr2.flatMap(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x * <span class="hljs-number">2</span>]); <span class="hljs-comment">// [2, 4, 6, 8]</span><br>arr2.flatMap(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [[x * <span class="hljs-number">2</span>]]); <span class="hljs-comment">// [[2], [4], [6], [8]]</span><br></code></pre></td></tr></table></figure><h3 id="at-由位置找元素"><a href="#at-由位置找元素" class="headerlink" title="at() 由位置找元素"></a>at() 由位置找元素</h3><p>at() 方法用于在数组中查找给定位置对应的元素，返回该位置处的元素，找不到返回 undefined。</p><p>接收一个参数：</p><ul><li>index（可选）。要查找的位置。接收负数，默认值为 0。（方括号语法只能是正整数且必须给参数）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.at(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 333</span><br></code></pre></td></tr></table></figure><h3 id="indexOf-由元素找位置"><a href="#indexOf-由元素找位置" class="headerlink" title="indexOf() 由元素找位置"></a>indexOf() 由元素找位置</h3><p>indexOf() 方法用于在数组中查找给定元素对应的位置，从 fromIndex 位置开始，从前向后搜索，只返回首个满足条件的元素位置，如果不存在则返回 -1。使用严格相等搜索元素。</p><p>接收两个参数：</p><ul><li>searchValue（必需）：给定的要查找的元素。</li><li>fromIndex（可选）：起始搜索位置。接受负值，默认值为 0。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.indexOf(<span class="hljs-number">333</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="lastIndexOf-由元素找位置"><a href="#lastIndexOf-由元素找位置" class="headerlink" title="lastIndexOf() 由元素找位置"></a>lastIndexOf() 由元素找位置</h3><p>lastIndexOf() 方法用于在数组中查找给定元素对应的位置，从 fromIndex 位置开始，从后向前搜索，只返回首个满足条件的元素位置，如果不存在则返回 -1。使用严格相等搜索元素。</p><p>接收两个参数：</p><ul><li>searchValue（必需）：给定的要查找的元素。</li><li>fromIndex（可选）：起始搜索位置。接受负值，默认值为 0。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.lastIndexOf(<span class="hljs-number">333</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="includes-是否包含元素"><a href="#includes-是否包含元素" class="headerlink" title="includes() 是否包含元素"></a>includes() 是否包含元素</h3><p>includes() 方法用于在数组中查找给定元素，从 fromIndex 位置开始，从后向前搜索，返回布尔值，表示是否至少找到一个与指定元素匹配的项。使用严格相等搜索元素。</p><p>接收两个参数：</p><ul><li>searchValue（必需）：给定的要查找的元素。</li><li>fromIndex（可选）：起始搜索位置。接受负值，默认值为 0。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.includes(<span class="hljs-number">333</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="join-转字符串"><a href="#join-转字符串" class="headerlink" title="join() 转字符串"></a>join() 转字符串</h3><p>join() 方法用于把数组中的所有元素通过指定的分隔符连接组成一个字符串，返回值为新生成的字符串。</p><p>接收一个参数：</p><ul><li>指定的分隔符（可选）。默认使用逗号作为分隔符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>];<br>a.join(); <span class="hljs-comment">// &#x27;hello,world&#x27;</span><br>a.join(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// &#x27;helloworld&#x27;</span><br>a.join(<span class="hljs-string">&#x27;+&#x27;</span>); <span class="hljs-comment">// &#x27;hello+world&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="toString-转字符串"><a href="#toString-转字符串" class="headerlink" title="toString() 转字符串"></a>toString() 转字符串</h3><p>toString() 方法用于把数组转换为由逗号链接起来的字符串，返回值为新生成的字符串。和 join() 方法一样，都是用于数组转字符串，但是不能自定义字符串的分隔符，不推荐使用。</p><h3 id="toLocaleString-转字符串"><a href="#toLocaleString-转字符串" class="headerlink" title="toLocaleString() 转字符串"></a>toLocaleString() 转字符串</h3><p>toString() 方法用于将数组中每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a =[&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;OBKoro1&#x27;</span>&#125;, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()];<br>a.toLocaleString(); <span class="hljs-comment">// &quot;[object Object], 23, abcd, 2021/9/2 下午4:32:53&quot;</span><br></code></pre></td></tr></table></figure><h2 id="回调函数遍历数组"><a href="#回调函数遍历数组" class="headerlink" title="回调函数遍历数组"></a>回调函数遍历数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 操作不改变数组</span><br><span class="hljs-comment">// ES5：</span><br><span class="hljs-built_in">Array</span>.prototype.forEach()<br><span class="hljs-built_in">Array</span>.prototype.map()<br><span class="hljs-built_in">Array</span>.prototype.filter()<br><span class="hljs-built_in">Array</span>.prototype.some()<br><span class="hljs-built_in">Array</span>.prototype.every()<br><span class="hljs-built_in">Array</span>.prototype.reduce()<br><span class="hljs-built_in">Array</span>.prototype.reduceRight()<br><span class="hljs-comment">// ES6：</span><br><span class="hljs-built_in">Array</span>.prototype.find()<br><span class="hljs-built_in">Array</span>.prototype.findIndex()<br><span class="hljs-built_in">Array</span>.prototype.keys()<br><span class="hljs-built_in">Array</span>.prototype.values()<br><span class="hljs-built_in">Array</span>.prototype.entries() <br></code></pre></td></tr></table></figure><h3 id="forEach-循环"><a href="#forEach-循环" class="headerlink" title="forEach() 循环"></a>forEach() 循环</h3><p>forEach() 方法用于对数组每一个元素执行一次回调函数，返回值为 undefined。<br>类似 for 循环遍历数组，但 forEach() 除抛出异常之外，不会停止或中断循环，更不会返回值。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.forEach(<span class="hljs-function">(<span class="hljs-params">value, key, self</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>  <span class="hljs-built_in">console</span>.log(key);<br>  <span class="hljs-built_in">console</span>.log(self);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;111222333&quot;</span>; <span class="hljs-comment">// 不会停止执行</span><br>&#125;)<br><br><span class="hljs-comment">// 111</span><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// [111, 222, 333]</span><br><br><span class="hljs-comment">// 222</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// [111, 222, 333]</span><br><br><span class="hljs-comment">// 333</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// [111, 222, 333]</span><br><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="map-调用"><a href="#map-调用" class="headerlink" title="map() 调用"></a>map() 调用</h3><p>map() 方法用于对数组每一个元素执行一次回调函数，返回一个新的数组，新数组中的元素由调用数组中的每一个元素执行回调函数得来，相当于是对原数组进行映射。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.map(<span class="hljs-function">(<span class="hljs-params">value, key, self</span>) =&gt;</span> value * <span class="hljs-number">2</span>); <span class="hljs-comment">// [222, 444, 666]</span><br></code></pre></td></tr></table></figure><h3 id="filter-过滤所有"><a href="#filter-过滤所有" class="headerlink" title="filter() 过滤所有"></a>filter() 过滤所有</h3><p>filter() 方法用于对调用数组的每一个元素执行一次回调函数，返回一个新的数组，新数组中的元素都是满足回调函数条件的调用数组元素。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.filter(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value &gt;= <span class="hljs-number">222</span>); <span class="hljs-comment">// [222, 333]</span><br></code></pre></td></tr></table></figure><h3 id="some-部分满足"><a href="#some-部分满足" class="headerlink" title="some() 部分满足"></a>some() 部分满足</h3><p>some() 方法用于对调用数组的每一个元素执行一次回调函数，判断数组中是否有满足回调函数条件的元素，有一个元素满足条件返回值为 true，没有满足条件的元素返回值为 false。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>];<br>list.some(<span class="hljs-function">(<span class="hljs-params">value, key, self</span>) =&gt;</span> value &gt;= <span class="hljs-number">10</span>); <span class="hljs-comment">// true</span><br>list.some(<span class="hljs-function">(<span class="hljs-params">value, key, self</span>) =&gt;</span> value &gt;= <span class="hljs-number">5</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="every-全部满足"><a href="#every-全部满足" class="headerlink" title="every() 全部满足"></a>every() 全部满足</h3><p>every() 方法用于对调用数组的每一个元素执行一次回调函数，判断数组所有元素是否都符合回调函数条件，元素都满足条件返回值为 true，有一个元素不满足返回值为 false。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>];<br>list.every(<span class="hljs-function">(<span class="hljs-params">value, key, self</span>) =&gt;</span> value &gt;= <span class="hljs-number">10</span>); <span class="hljs-comment">// false</span><br>list.every(<span class="hljs-function">(<span class="hljs-params">value, key, self</span>) =&gt;</span> value &gt;= <span class="hljs-number">5</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="find-查找元素"><a href="#find-查找元素" class="headerlink" title="find() 查找元素"></a>find() 查找元素</h3><p>find() 方法用于对数组每一个元素执行一次回调函数，找出数组中第一个满足回调函数的元素，从数组的最小索引开始，返回第一个满足回调函数的元素值，如果没有符合的元素则返回 undefined。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.find(<span class="hljs-function">(<span class="hljs-params">value, index, self</span>) =&gt;</span> value &gt;= <span class="hljs-number">222</span>); <span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure><h3 id="findIndex-查找元素位置"><a href="#findIndex-查找元素位置" class="headerlink" title="findIndex() 查找元素位置"></a>findIndex() 查找元素位置</h3><p>findIndex() 方法用于对数组每一个元素执行一次回调函数，找出数组中第一个满足回调函数的元素，从数组的最小索引开始，返回第一个满足回调函数的元素位置，如果没有符合的元素则返回 -1。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>thisArg（可选）：执行回调函数时 this 绑定对象的值。默认值为 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.findIndex(<span class="hljs-function">(<span class="hljs-params">value, index, self</span>) =&gt;</span> value &gt;= <span class="hljs-number">222</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="reduce-正序累加"><a href="#reduce-正序累加" class="headerlink" title="reduce() 正序累加"></a>reduce() 正序累加</h3><p>reduce() 方法用于对调用数组的每一个元素，从第一项开始遍历到最后一项执行回调函数作为累加器，最终合并为一个值并返回。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>previousValue（必需），初始值，或者上一次归并函数的返回值</li><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>initialValue（可选）：指定第一次回调的第一个参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.reduce(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> prev += cur, <span class="hljs-number">0</span>); <span class="hljs-comment">// 666</span><br>list.reduce(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> prev += cur, <span class="hljs-number">100</span>); <span class="hljs-comment">// 766</span><br><br>[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]].reduce(<span class="hljs-function">(<span class="hljs-params">arr1, arr2</span>) =&gt;</span> arr1.concat(arr2), [<span class="hljs-number">4</span>]); <span class="hljs-comment">// [4, 0, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="reduceRight-倒序累加"><a href="#reduceRight-倒序累加" class="headerlink" title="reduceRight() 倒序累加"></a>reduceRight() 倒序累加</h3><p>reduce() 方法用于对调用数组的每一个元素，从最后一项开始遍历到第一项执行回调函数作为累加器，最终合并为一个值并返回。</p><p>接收两个参数：</p><ul><li>callback（必需）：回调函数。<ul><li>previousValue（必需），初始值，或者上一次归并函数的返回值</li><li>currentValue（必需），数组当前元素的值</li><li>index（可选），当前元素的索引值</li><li>arr（可选），数组对象本身</li></ul></li><li>initialValue（可选）：指定第一次回调的第一个参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">333</span>];<br>list.reduceRight(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> prev += cur, <span class="hljs-number">0</span>); <span class="hljs-comment">// 666</span><br>list.reduceRight(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> prev += cur, <span class="hljs-number">100</span>); <span class="hljs-comment">// 766</span><br><br>[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]].reduceRight(<span class="hljs-function">(<span class="hljs-params">arr1, arr2</span>) =&gt;</span> arr1.concat(arr2), [<span class="hljs-number">4</span>]); <span class="hljs-comment">// [4, 2, 3, 0, 1]</span><br></code></pre></td></tr></table></figure><h3 id="keys-遍历索引"><a href="#keys-遍历索引" class="headerlink" title="keys() 遍历索引"></a>keys() 遍历索引</h3><p>keys() 方法返回数组索引的迭代器（Array Iterator 对象）。<br>使用 ES6 的解构可以非常容易地在循环中拆分键/值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>, <span class="hljs-string">&quot;qux&quot;</span>];<br><span class="hljs-built_in">Array</span>.from(a.keys()); <span class="hljs-comment">// [0, 1, 2, 3]</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> index <span class="hljs-keyword">of</span> a.keys()) &#123;<br>  <span class="hljs-built_in">console</span>.log(index);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="values-遍历元素"><a href="#values-遍历元素" class="headerlink" title="values() 遍历元素"></a>values() 遍历元素</h3><p>values() 方法返回数组元素的迭代器（Array Iterator 对象）。<br>使用 ES6 的解构可以非常容易地在循环中拆分键/值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>, <span class="hljs-string">&quot;qux&quot;</span>];<br><span class="hljs-built_in">Array</span>.from(a.values()); <span class="hljs-comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> a.values()) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><span class="hljs-comment">// foo</span><br><span class="hljs-comment">// bar</span><br><span class="hljs-comment">// baz</span><br><span class="hljs-comment">// qux</span><br></code></pre></td></tr></table></figure><h3 id="entries-遍历索引元素对"><a href="#entries-遍历索引元素对" class="headerlink" title="entries() 遍历索引元素对"></a>entries() 遍历索引元素对</h3><p>entries() 方法返回数组索引/值对的迭代器（Array Iterator 对象）。<br>使用 ES6 的解构可以非常容易地在循环中拆分键/值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>, <span class="hljs-string">&quot;qux&quot;</span>];<br><span class="hljs-built_in">Array</span>.from(a.entries()); <span class="hljs-comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [index, value] <span class="hljs-keyword">of</span> a.entries()) &#123;<br>  <span class="hljs-built_in">console</span>.log(index, value);<br>&#125;<br><span class="hljs-comment">// 0 foo </span><br><span class="hljs-comment">// 1 bar </span><br><span class="hljs-comment">// 2 baz </span><br><span class="hljs-comment">// 3 qux</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>方法属性</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue部署问题</title>
    <link href="/2021/08/25/Vue%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/08/25/Vue%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-项目打包到服务器报错-net-ERR-ABORTED-404-Not-Found"><a href="#Vue-项目打包到服务器报错-net-ERR-ABORTED-404-Not-Found" class="headerlink" title="Vue 项目打包到服务器报错 net::ERR_ABORTED 404 (Not Found)"></a>Vue 项目打包到服务器报错 net::ERR_ABORTED 404 (Not Found)</h1><p>参考：<a href="https://cli.vuejs.org/zh/config/#publicpath">https://cli.vuejs.org/zh/config/#publicpath</a> 。</p><p>在 vue.config.js 中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;./&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Vue-项目打包到服务器刷新后-404-问题"><a href="#Vue-项目打包到服务器刷新后-404-问题" class="headerlink" title="Vue 项目打包到服务器刷新后 404 问题"></a>Vue 项目打包到服务器刷新后 404 问题</h1><p>参考：<br><a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html">https://router.vuejs.org/zh/guide/essentials/history-mode.html</a> 。<br><a href="https://juejin.cn/post/6995361415758348318">https://juejin.cn/post/6995361415758348318</a> 。<br><a href="https://segmentfault.com/a/1190000022654970">https://segmentfault.com/a/1190000022654970</a> 。</p>]]></content>
    
    
    <categories>
      
      <category>框架和类库</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架和类库</tag>
      
      <tag>Vue</tag>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript内存和拷贝</title>
    <link href="/2021/08/23/JavaScript%E5%86%85%E5%AD%98%E5%92%8C%E6%8B%B7%E8%B4%9D/"/>
    <url>/2021/08/23/JavaScript%E5%86%85%E5%AD%98%E5%92%8C%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844903873992196110">https://juejin.cn/post/6844903873992196110</a> 。<br><a href="https://juejin.cn/post/6955962274917908488">https://juejin.cn/post/6955962274917908488</a> 。<br><a href="https://juejin.cn/post/6844904197595332622">https://juejin.cn/post/6844904197595332622</a> 。<br><a href="https://juejin.cn/post/6844903929705136141">https://juejin.cn/post/6844903929705136141</a> 。</p><h1 id="栈堆内存"><a href="#栈堆内存" class="headerlink" title="栈堆内存"></a>栈堆内存</h1><p>JavaScript 是动态语言，因为在声明变量之前并不需要确认其数据类型，所以 JavaScript 变量没有数据类型，值才有数据类型，变量可以随时持有任何类型的数据 。</p><p>JavaScript 内存空间分为栈（stack）、堆（heap）、池（一般也会归类为栈）。<br>其中，栈存放变量，堆存放复杂对象，池存放常量（也叫常量池）。</p><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为是一种后入先出的数据结构。由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。</p><p>堆是一种经过排序的树形数据结构，每个结点都有一个值。通常，我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，我们只需要关心书的名字。</p><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>JavaScript 的栈空间就是我们所说的调用栈（执行上下文栈），是用来存储执行上下文的。<br>其包含变量空间与词法环境，var、function 等保存在变量环境；let、const 声明的变量等保存在词法环境。</p><p>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定。</p><p>所以，栈空间通常都不会设置太大，基本类型在内存中占有固定大小的空间，所以它们的值保存在栈空间，我们通过按值访问。它们也不需要手动管理，由操作系统来管理，函数调时创建，调用结束则消失。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。如果存储在栈，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</p><p>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。因此，当我们需要访问堆内存中的引用数据类型时，实际上我们首先是从变量中获取了该对象的地址指针，然后再从堆内存中取得我们需要的数据。所以引用数据类型是。</p><p>所以，堆空间通常很大，能存放很多大的数据，我们通过按引用访问，不过缺点是分配内存和回收内存都会占用一定的时间。一般堆空间由程序员手动管理，如果程序结束还存在，则可能由操作系统回收。</p><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br>  <span class="hljs-keyword">var</span> c = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;an&#x27;</span> &#125; <span class="hljs-comment">// 引用类型</span><br>&#125;<br><span class="hljs-comment">// 函数调用</span><br>foo()<br></code></pre></td></tr></table></figure><p><img src="/images/%E6%A0%88%E5%A0%86%E7%A9%BA%E9%97%B4.png" alt="栈堆空间示意图（来自掘金@三分钟学前端An）"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>基本数据类型变量大小固定，且操作简单容易，所以把它们放入栈中存储。引用数据类型变量大小不固定，所以把它们分配给堆中，让它们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。</p><p>栈内存由于它的特点，所以它的系统效率较高。<br>堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。</p><h2 id="为何区分"><a href="#为何区分" class="headerlink" title="为何区分"></a>为何区分</h2><p>区分栈内存与堆内存与垃圾回收机制有关，为了使程序运行时占用的内存最小。</p><p>执行方法时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里。方法执行结束后，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的。</p><p>我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法结束而销毁，即使方法执行结束，这个对象还可能被另一个引用变量所引用，这个对象依然不会被销毁，只有当一个对象没有被任何引用变量引用时，系统的垃圾回收机制才会在核实的时候回收它。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包中的变量并不保存在栈内存中，而是保存在堆内存中。这也就解释了为什么创建闭包函数的上下文已经被销毁，而闭包函数还能引用那个上下文的变量。</p><p>闭包中的变量没有保存在栈内存中，而是保存在堆内存中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span> <span class="hljs-comment">// 创建局部变量 num 和局部函数 bar</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// bar() 是函数内部方法，是一个闭包</span><br>    num++<br>    <span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 使用了外部函数声明的变量，内部函数可以访问外部函数的变量</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> bar <span class="hljs-comment">// bar 被外部函数作为返回值返回了，返回的是一个闭包</span><br>&#125;<br><span class="hljs-keyword">let</span> test = foo();<br>test() <span class="hljs-comment">// 2</span><br>test() <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.dir(test) <span class="hljs-comment">// 结果看下图，闭包中的变量没有保存在栈内存中，而是保存在堆内存中：</span><br></code></pre></td></tr></table></figure><p><img src="/images/%E9%97%AD%E5%8C%85%E5%A0%86%E5%86%85%E5%AD%981.png" alt="来自掘金@三分钟学前端An"></p><p>即使闭包没有被返回，闭包中的变量还是保存到了堆堆内存中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span> <span class="hljs-comment">// 创建局部变量 num 和局部函数 bar</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// bar() 是函数内部方法，是一个闭包</span><br>      num++ <br>      <span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 使用了外部函数声明的变量，内部函数可以访问外部函数的变量</span><br>  &#125;<br>  bar() <span class="hljs-comment">// 2</span><br>  bar() <span class="hljs-comment">// 3</span><br>  <span class="hljs-built_in">console</span>.dir(bar)<br>&#125;<br>foo() <span class="hljs-comment">// 结果看下图，即使不返回函数（闭包没有被返回），闭包中的变量还是保存到了堆堆内存中：</span><br></code></pre></td></tr></table></figure><p><img src="/images/%E9%97%AD%E5%8C%85%E5%A0%86%E5%86%85%E5%AD%982.png" alt="来自掘金@三分钟学前端An"></p><p>现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。所以 JS 引擎判断当前是一个闭包时，就会在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JS 无法访问）。</p><h1 id="赋值和拷贝"><a href="#赋值和拷贝" class="headerlink" title="赋值和拷贝"></a>赋值和拷贝</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>对于 <strong>基本数据类型</strong> 的赋值、深拷贝、浅拷贝，操作一样：在栈内存创建开辟地址。</p><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>对于 <strong>引用数据类型</strong> 的赋值、深拷贝、浅拷贝：</p><p>当将一个对象赋值给一个新的对象的时候，赋的其实是该对象在栈中的地址（指针），而不是堆中的数据。也就是说，两个对象指向的是同一个堆内存，因而无论哪个对象发生改变，其实都是改变的堆内存的内容。因此，两个对象是联动的。</p><p>浅拷贝会在堆内存开辟地址，创建一个对象，然后遍历原对象。当原对象的属性值是基本数据类型，则拷贝基本数据类型的值；当原对象的属性值是引用数据类型，则拷贝的是引用数据类型在栈中的地址（指针）。</p><p>深拷贝也在堆内存开辟地址，创建一个对象，然后遍历原对象。当原对象的属性值是基本数据类型，则拷贝基本数据类型的值；当原对象的属性值是引用数据类型，则在堆内存开辟地址拷贝引用数据类型。</p><p><img src="/images/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="浅拷贝（来自掘金@ConardLi）"><br><img src="/images/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt="深拷贝（来自掘金@ConardLi）"></p><p>赋值和浅拷贝的区别在于对象第一层数据对原对象的影响。<br>如果是赋值，改变都会直接影响原对象。<br>如果是浅拷贝，属性值是原始值，改变不会影响原对象；属性值是引用值，改变会影响原对象。<br>如果是深拷贝，属性值是原始值，改变不会影响原对象；属性值是引用值，改变也不会影响原对象。</p><h3 id="赋值示例"><a href="#赋值示例" class="headerlink" title="赋值示例"></a>赋值示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&#x27;str1&#x27;</span>;<br><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>, <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>] &#125;;<br><span class="hljs-comment">// 赋值</span><br><span class="hljs-keyword">let</span> str2 = str1;<br><span class="hljs-keyword">let</span> arr2 = arr1;<br><span class="hljs-keyword">let</span> obj2 = obj1;<br><span class="hljs-built_in">console</span>.log(str2); <span class="hljs-comment">// str1</span><br><span class="hljs-built_in">console</span>.log(arr2); <span class="hljs-comment">// [0, 0, 0]</span><br><span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">// &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [2, 3], 4 ] &#125;</span><br><span class="hljs-comment">// 修改值</span><br>str2 = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>arr2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;bbb&#x27;</span>;<br>obj2.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj2.arr[<span class="hljs-number">1</span>] = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br><span class="hljs-comment">// 结果</span><br><span class="hljs-built_in">console</span>.log(str1, str2); <br><span class="hljs-comment">// str1   aaa</span><br><span class="hljs-built_in">console</span>.log(arr1, arr2); <br><span class="hljs-comment">// [&#x27;bbb&#x27;, 0, 0]   [&#x27;bbb&#x27;, 0, 0]</span><br><span class="hljs-built_in">console</span>.log(obj1, obj2); <br><span class="hljs-comment">// &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [5, 6, 7], 4 ] &#125;</span><br><span class="hljs-comment">// &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [5, 6, 7], 4 ] &#125;</span><br></code></pre></td></tr></table></figure><h3 id="浅拷贝示例"><a href="#浅拷贝示例" class="headerlink" title="浅拷贝示例"></a>浅拷贝示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&#x27;str1&#x27;</span>;<br><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>, <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>] &#125;;<br><span class="hljs-comment">// 浅拷贝方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowClone</span>(<span class="hljs-params">source</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> target = &#123;&#125;;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (source.hasOwnProperty(i)) &#123;<br>      target[i] = source[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br><span class="hljs-comment">// 浅拷贝</span><br><span class="hljs-keyword">let</span> str2 = shallowClone(str1);<br><span class="hljs-keyword">let</span> arr2 = shallowClone(arr1);<br><span class="hljs-keyword">let</span> obj2 = shallowClone(obj1);<br><span class="hljs-built_in">console</span>.log(str2); <span class="hljs-comment">// &#123; 0: &#x27;s&#x27;, 1: &#x27;t&#x27;, 2: &#x27;r&#x27;, 3: &#x27;1&#x27; &#125;</span><br><span class="hljs-built_in">console</span>.log(arr2); <span class="hljs-comment">// &#123; 0: 0, 1: 0, 2: 0 &#125;</span><br><span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">// &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [2, 3], 4 ] &#125;</span><br><span class="hljs-comment">// 修改值</span><br>str2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>arr2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;bbb&#x27;</span>;<br>obj2.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj2.arr[<span class="hljs-number">1</span>] = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br><span class="hljs-comment">// 结果</span><br><span class="hljs-built_in">console</span>.log(str1, str2); <br><span class="hljs-comment">// str1   &#123; 0: &#x27;aaa&#x27;, 1: &#x27;t&#x27;, 2: &#x27;r&#x27;, 3: &#x27;1&#x27; &#125;</span><br><span class="hljs-built_in">console</span>.log(arr1, arr2); <br><span class="hljs-comment">// [0, 0, 0]   &#123;0: &#x27;bbb&#x27;, 1: 0, 2: 0&#125;</span><br><span class="hljs-built_in">console</span>.log(obj1, obj2); <br><span class="hljs-comment">// &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [5, 6, 7], 4 ] &#125;</span><br><span class="hljs-comment">// &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [5, 6, 7], 4 ] &#125;</span><br></code></pre></td></tr></table></figure><h3 id="深拷贝示例"><a href="#深拷贝示例" class="headerlink" title="深拷贝示例"></a>深拷贝示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 深拷贝示例</span><br><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&#x27;str1&#x27;</span>;<br><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>, <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>] &#125;;<br><span class="hljs-comment">// 深拷贝方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj; <br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj);<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> obj;<br>  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>      cloneObj[key] = deepClone(obj[key]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj;<br>&#125;<br><span class="hljs-comment">// 深拷贝</span><br><span class="hljs-keyword">let</span> str2 = deepClone(str1);<br><span class="hljs-keyword">let</span> arr2 = deepClone(arr1);<br><span class="hljs-keyword">let</span> obj2 = deepClone(obj1);<br><span class="hljs-built_in">console</span>.log(str2); <span class="hljs-comment">// str1</span><br><span class="hljs-built_in">console</span>.log(arr2); <span class="hljs-comment">// [0, 0, 0]</span><br><span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">// &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [2, 3], 4 ] &#125;</span><br><span class="hljs-comment">// 修改值</span><br>str2 = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>arr2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;bbb&#x27;</span>;<br>obj2.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj2.arr[<span class="hljs-number">1</span>] = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br><span class="hljs-comment">// 结果</span><br><span class="hljs-built_in">console</span>.log(str1, str2); <br><span class="hljs-comment">// str1   aaa</span><br><span class="hljs-built_in">console</span>.log(arr1, arr2); <br><span class="hljs-comment">// [0, 0, 0]   [&#x27;bbb&#x27;, 0, 0]</span><br><span class="hljs-built_in">console</span>.log(obj1, obj2); <br><span class="hljs-comment">// &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [2, 3], 4 ] &#125;</span><br><span class="hljs-comment">// &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [5, 6, 7], 4 ] &#125;</span><br></code></pre></td></tr></table></figure><h3 id="引用数据类型总结"><a href="#引用数据类型总结" class="headerlink" title="引用数据类型总结"></a>引用数据类型总结</h3><table><thead><tr><th align="center">操作方式</th><th align="center">和原数据指向同一对象</th><th align="center">第一层数据为基本数据类型</th><th align="center">原数据中包含子对象</th></tr></thead><tbody><tr><td align="center">赋值</td><td align="center">是</td><td align="center">改变会使原数据一同改变</td><td align="center">改变会使原数据一同改变</td></tr><tr><td align="center">浅拷贝</td><td align="center">否</td><td align="center">改变不会使原数据一同改变</td><td align="center">改变会使原数据一同改变</td></tr><tr><td align="center">深拷贝</td><td align="center">否</td><td align="center">改变不会使原数据一同改变</td><td align="center">改变不会使原数据一同改变</td></tr></tbody></table><h1 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h1><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Kobe&#x27;</span>, <span class="hljs-attr">address</span>:&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">100</span>&#125;&#125;;<br><span class="hljs-keyword">let</span> obj2 = &#123;... obj1&#125;;<br>obj1.address.x = <span class="hljs-number">200</span>;<br>obj1.name = <span class="hljs-string">&#x27;wade&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj2&#x27;</span>,obj2); <span class="hljs-comment">// obj2 &#123; name: &#x27;Kobe&#x27;, address: &#123; x: 200, y: 100 &#125; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">person</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">41</span>&#125;, <span class="hljs-attr">sports</span>:<span class="hljs-string">&#x27;basketball&#x27;</span> &#125;;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj1);<br>obj2.person.name = <span class="hljs-string">&quot;wade&quot;</span>;<br>obj2.sports = <span class="hljs-string">&#x27;football&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">// &#123; person: &#123; name: &#x27;wade&#x27;, age: 41 &#125;, sports: &#x27;basketball&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;kobe&#x27;</span>&#125;];<br><span class="hljs-keyword">let</span> arr2 = arr1.concat();    <br>arr2[<span class="hljs-number">2</span>].username = <span class="hljs-string">&#x27;wade&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(arr1); <span class="hljs-comment">//[ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><h2 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;kobe&#x27;</span>&#125;];<br><span class="hljs-keyword">let</span> arr3 = arr1.slice();<br>arr3[<span class="hljs-number">2</span>].username = <span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-built_in">console</span>.log(arr1); <span class="hljs-comment">// [ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><h2 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> cloneTarget = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;<br>    cloneTarget[key] = target[key];<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneTarget;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h1><h2 id="HTML-API"><a href="#HTML-API" class="headerlink" title="HTML API"></a>HTML API</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> original = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;MDN&quot;</span> &#125;<br><span class="hljs-keyword">const</span> clone = structuredClone(original)<br><span class="hljs-built_in">console</span>.assert(clone !== original)       <span class="hljs-comment">// the objects are not the same (not same identity)</span><br><span class="hljs-built_in">console</span>.assert(clone.name === <span class="hljs-string">&quot;MDN&quot;</span>)     <span class="hljs-comment">// they do have the same values</span><br><span class="hljs-built_in">console</span>.assert(clone.itself === clone)   <span class="hljs-comment">// and the circular reference is preserved</span><br></code></pre></td></tr></table></figure><p>浏览器的 structuredClone() 缺点：</p><ul><li>原型：无法拷贝对象的原型链</li><li>函数：无法拷贝函数</li><li>不可克隆：并没有支持所有类型的拷贝，比如 Error</li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27; kobe&#x27;</span>&#125;];<br><span class="hljs-keyword">let</span> arr4 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(arr1));<br>arr4[<span class="hljs-number">2</span>].username = <span class="hljs-string">&#x27;duncan&#x27;</span>; <br><span class="hljs-built_in">console</span>.log(arr1, arr4)<br></code></pre></td></tr></table></figure><p>这种方法虽然可以实现数组和对象深拷贝，但不能处理函数和正则，因为这两者基于 JSON.stringify() 和 JSON.parse() 处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）。此外的问题还有：</p><ul><li><code>NaN</code>、<code>Infinity</code>变为<code>null</code></li><li><code>Set</code>、<code>Map</code>、<code>RegExp</code>、<code>Date</code>等数据类型无法拷贝</li><li><code>function</code>、<code>symbol</code>、<code>undefined</code>等属性会丢失</li><li>enumerable 为 false 的不可遍历属性丢失</li></ul><h2 id="手写实现-1"><a href="#手写实现-1" class="headerlink" title="手写实现"></a>手写实现</h2><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> cloneTarget = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;<br>      cloneTarget[key] = clone(target[key]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneTarget;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="考虑数组"><a href="#考虑数组" class="headerlink" title="考虑数组"></a>考虑数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> cloneTarget = <span class="hljs-built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;<br>      cloneTarget[key] = clone(target[key]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneTarget;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">target, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> cloneTarget = <span class="hljs-built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;<br>    <span class="hljs-keyword">if</span> (map.get(target)) &#123;<br>      <span class="hljs-keyword">return</span> map.get(target);<br>    &#125;<br>    map.set(target, cloneTarget);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;<br>      cloneTarget[key] = clone(target[key], map);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneTarget;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">target, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> isArray = <span class="hljs-built_in">Array</span>.isArray(target);<br>    <span class="hljs-keyword">let</span> cloneTarget = isArray ? [] : &#123;&#125;;<br><br>    <span class="hljs-keyword">if</span> (map.get(target)) &#123;<br>      <span class="hljs-keyword">return</span> map.get(target);<br>    &#125;<br>    map.set(target, cloneTarget);<br><br>    <span class="hljs-keyword">const</span> keys = isArray ? <span class="hljs-literal">undefined</span> : <span class="hljs-built_in">Object</span>.keys(target);<br>    forEach(keys || target, <span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (keys) &#123;<br>        key = value;<br>      &#125;<br>      cloneTarget[key] = clone2(target[key], map);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloneTarget;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数组扁平化</title>
    <link href="/2021/08/21/JavaScript%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    <url>/2021/08/21/JavaScript%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://juejin.cn/post/6844904025993773063">https://juejin.cn/post/6844904025993773063</a> 。</p><h1 id="数组扁平化的实现"><a href="#数组扁平化的实现" class="headerlink" title="数组扁平化的实现"></a>数组扁平化的实现</h1><p>数组拍平方法 Array.prototype.flat() 也叫数组扁平化、数组拉平、数组降维。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> animals = [<span class="hljs-string">&quot;🐷&quot;</span>, [<span class="hljs-string">&quot;🐶&quot;</span>, <span class="hljs-string">&quot;🐂&quot;</span>], [<span class="hljs-string">&quot;🐎&quot;</span>, [<span class="hljs-string">&quot;🐑&quot;</span>, [<span class="hljs-string">&quot;🐲&quot;</span>]], <span class="hljs-string">&quot;🐛&quot;</span>]];<br><span class="hljs-comment">// 不传参数时，默认“拉平”一层</span><br>animals.flat();<br><span class="hljs-comment">// [&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;, [&quot;🐑&quot;, [&quot;🐲&quot;]], &quot;🐛&quot;]</span><br><span class="hljs-comment">// 传入一个整数参数，整数即“拉平”的层数</span><br>animals.flat(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// [&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;, &quot;🐑&quot;, [&quot;🐲&quot;], &quot;🐛&quot;]</span><br><span class="hljs-comment">// Infinity 关键字作为参数时，无论多少层嵌套，都会转为一维数组</span><br>animals.flat(<span class="hljs-literal">Infinity</span>);<br><span class="hljs-comment">// [&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;, &quot;🐑&quot;, &quot;🐲&quot;, &quot;🐛&quot;]</span><br><span class="hljs-comment">// 传入 &lt;=0 的整数将返回原数组，不“拉平”</span><br>animals.flat(<span class="hljs-number">0</span>);<br>animals.flat(-<span class="hljs-number">10</span>);<br><span class="hljs-comment">// [&quot;🐷&quot;, [&quot;🐶&quot;, &quot;🐂&quot;], [&quot;🐎&quot;, [&quot;🐑&quot;, [&quot;🐲&quot;]], &quot;🐛&quot;]];</span><br><span class="hljs-comment">// 如果原数组有空位，flat()方法会跳过空位。</span><br>[<span class="hljs-string">&quot;🐷&quot;</span>, <span class="hljs-string">&quot;🐶&quot;</span>, <span class="hljs-string">&quot;🐂&quot;</span>, <span class="hljs-string">&quot;🐎&quot;</span>,,].flat();<br><span class="hljs-comment">// [&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;]</span><br></code></pre></td></tr></table></figure><p>Array.prototype.flat() 特性总结：</p><ul><li>Array.prototype.flat() 用于将嵌套的数组“拉平”变成一维的数组。该方法返回一个新数组，对原数据没影响。</li><li>不传参数时，默认“拉平”一层，可以传入一个整数，表示想要“拉平”的层数；传入小于等于零的整数将返回原数组，不“拉平”。Infinity 关键字作为参数时，无论多少层嵌套，都会转为一维数组。</li><li>如果原数组有空位，Array.prototype.flat() 会跳过空位。</li></ul><h1 id="实现一个简单的数组拍平-flat-函数"><a href="#实现一个简单的数组拍平-flat-函数" class="headerlink" title="实现一个简单的数组拍平 flat 函数"></a>实现一个简单的数组拍平 flat 函数</h1><p>思路非常简单：实现一个有数组拍平功能的 flat 函数，我们要做的就是在数组中找到是数组类型的元素，然后将他们展开。这就是实现数组拍平 flat 方法的关键思路。</p><p>解决实现这个思路需要克服的困难：</p><ul><li>第一个要解决的就是遍历数组的每一个元素；</li><li>第二个要解决的就是判断元素是否是数组；</li><li>第三个要解决的就是将数组的元素展开一层；</li></ul><h2 id="遍历数组的方案"><a href="#遍历数组的方案" class="headerlink" title="遍历数组的方案"></a>遍历数组的方案</h2><ul><li>for 循环</li><li>for…of</li><li>for…in</li><li>forEach()</li><li>entries()</li><li>keys()</li><li>values()</li><li>reduce()</li><li>map()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]], <span class="hljs-number">5</span>, <span class="hljs-string">&quot;string&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;同学&quot;</span> &#125;];<br><span class="hljs-comment">// for 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(arr[i]);<br>&#125;<br><span class="hljs-comment">// for...of</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><span class="hljs-comment">// for...in</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>  <span class="hljs-built_in">console</span>.log(arr[i]);<br>&#125;<br><span class="hljs-comment">// forEach 循环</span><br>arr.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;);<br><span class="hljs-comment">// entries()</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, value] <span class="hljs-keyword">of</span> arr.entries()) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><span class="hljs-comment">// keys()</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> arr.keys()) &#123;<br>  <span class="hljs-built_in">console</span>.log(arr[index]);<br>&#125;<br><span class="hljs-comment">// values()</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> arr.values()) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><span class="hljs-comment">// reduce()</span><br>arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(cur);<br>&#125;, []);<br><span class="hljs-comment">// map()</span><br>arr.map(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(value));<br></code></pre></td></tr></table></figure><h2 id="判断是数组的方法"><a href="#判断是数组的方法" class="headerlink" title="判断是数组的方法"></a>判断是数组的方法</h2><ul><li>Array.isArray 方法</li><li>Object.prototype.toString 方法</li><li>instanceof 操作符</li><li>constructor 属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]], <span class="hljs-number">5</span>, <span class="hljs-string">&quot;string&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;同学&quot;</span> &#125;];<br>arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span><br><span class="hljs-comment">// true</span><br>arr.constructor === <span class="hljs-built_in">Array</span><br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(arr) === <span class="hljs-string">&#x27;[object Array]&#x27;</span><br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">Array</span>.isArray(arr)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>instanceof 操作符是假定只有一种全局环境，如果网页中包含多个框架，多个全局环境，如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</li><li>constructor 属性可以被重写，所以不能确保一定是数组</li></ul><h2 id="将数组的元素展开一层的方案"><a href="#将数组的元素展开一层的方案" class="headerlink" title="将数组的元素展开一层的方案"></a>将数组的元素展开一层的方案</h2><ul><li>扩展运算符 + concat</li></ul><p>concat() 方法用于合并两个或多个数组，在拼接的过程中加上扩展运算符会展开一层数组。详细见下面的代码。</p><ul><li>concat +apply</li></ul><p>主要是利用 apply 在绑定作用域时，传入的第二个参数是一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。也就是在调用 apply 函数的过程中，会将传入的数组一个一个的传入到要执行的函数中，也就是相当对数组进行了一层的展开。</p><ul><li>toString  + split</li></ul><p>不推荐使用 toString + split 方法，因为操作字符串是和危险的事情，在上一文章中我做了一个操作字符串的案例还被许多小伙伴们批评了。如果数组中的元素所有都是数字的话，toString +split 是可行的，并且是一步搞定。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript运行机制</title>
    <link href="/2021/08/20/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/08/20/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://juejin.cn/post/6844903512845860872">https://juejin.cn/post/6844903512845860872</a> 。<br><a href="https://juejin.cn/post/6844904100195205133">https://juejin.cn/post/6844904100195205133</a> 。<br><a href="https://juejin.cn/post/6991849728493256741">https://juejin.cn/post/6991849728493256741</a> 。</p><h1 id="JavaScript-异步实现"><a href="#JavaScript-异步实现" class="headerlink" title="JavaScript 异步实现"></a>JavaScript 异步实现</h1><p>JavaScript 是一门单线程语言，虽然 HTML5 中提出 Web-Worker，但 JavaScript 是单线程这一核心仍未改变。所以一切 JavaScript 的”多线程”都是用单线程模拟出来的。</p><p>JavaScript 的主运行线程只有一个，但不是整个运行环境都是单线程。JavaScript 的运行环境主要是浏览器，它不仅是多线程的，而且是多进程的。</p><h1 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" class="headerlink" title="浏览器的多进程架构"></a>浏览器的多进程架构</h1><p>以 Chrome 浏览器为例，它由多个进程组成，每个进程都有自己核心的职责，它们相互配合来完成浏览器的整体功能。每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。</p><p>Chrome 浏览器采用多进程架构，其顶层存在一个 Browser 进程用以协调浏览器的其它进程。</p><p><img src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%9B%E7%A8%8B.png" alt="Chrome 浏览器的主要进程"></p><p>上图只是一个概括，意思是浏览器有这几类的进程和线程，并不是每种只有一个，比如渲染进程就有多个，每个页面都有自己的渲染进程。有时候使用浏览器会遇到某个页面崩溃或者没有响应的情况，这个页面对应的渲染进程可能崩溃了，但是其它页面并没有用这个渲染进程，它们各自有各自的渲染进程，所以其它页面并不会受影响。</p><p>最新 Chrome 浏览器包括：1个Browser进程、1个GPU进程、1个网络进程、多个渲染进程、多个插件进程。打开浏览器的一个页面至少需要 4 个进程：1个Browser进程、1个GPU进程、1个网络进程、1个渲染进程。</p><h2 id="Browser进程"><a href="#Browser进程" class="headerlink" title="Browser进程"></a>Browser进程</h2><p>负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，及负责与其他进程的协调工作，同时提供存储功能。</p><h2 id="GPU进程"><a href="#GPU进程" class="headerlink" title="GPU进程"></a>GPU进程</h2><p>负责整个浏览器界面的渲染。Chrome 刚开始发布的时候是没有GPU进程的，而使用GPU的初衷是为了实现3D CSS效果，只是后面网页、Chrome 的 UI 界面都用GPU来绘制，这使GPU成为浏览器普遍的需求，最后 Chrome 在多进程架构上也引入了GPU进程。</p><h2 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h2><p>负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程。</p><h2 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h2><p>负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响。每种类型的插件对应一个进程，仅当使用插件时才创建插件进程。</p><h2 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h2><p>负责控制显示标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎 Blink 和 JS V8 引擎都是运行在该进程中，默认情况下 Chrome 会为每个标签页创建一个渲染进程。渲染进程被称为浏览器渲染进程或浏览器内核，内部是多线程的。</p><h1 id="浏览器的渲染进程"><a href="#浏览器的渲染进程" class="headerlink" title="浏览器的渲染进程"></a>浏览器的渲染进程</h1><p>我们平时看到的浏览器呈现出页面过程中，大部分工作都是在渲染进程中完成，对于前端工程师来说，主要关心的还是渲染进程。</p><h2 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h2><p>GUI渲染线程负责渲染浏览器界面，解析 HTML 和 CSS，构建 DOM Tree、CSSOM Tree、Render Tree，布局和绘制页面。</p><p>当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程也会执行。</p><p>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎线程执行时 GUI 线程会被挂起（相当于被冻结了），GUI渲染线程会被保存在一个队列中，等到JS引擎线程空闲时再立即被执行。</p><h2 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h2><p>JS引擎线程是负责执行 JavaScript 的主线程，“JavaScript 是单线程的”就是指的这个线程。Chrome V8 引擎就是在这个线程运行的。JS引擎线程负责解析 Javascript 脚本，运行代码。一个页面只有一个JS引擎线程负责解析和执行 JavaScrip。</p><p>需要注意的是，这个线程跟GUI渲染线程是互斥的。互斥的原因是 JavaScript 也可以操作 DOM 和 CSSOM，如果JS引擎线程和GUI渲染线程同时操作，结果就混乱了，不知道到底渲染哪个结果。互斥带来的后果就是如果 JavaScript 长时间运行，GUI渲染线程就不能执行，造成页面的渲染不连贯，导致页面渲染加载阻塞，整个页面就感觉卡死了。</p><h2 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h2><p>setTimeout 和 setInterval 就运行在这里，它跟JS引擎线程不在同一个地方，因为JS引擎线程是单线程的，所以如果其处于阻塞状态，那么计时器就会不准确，所以需要单独的线程来负责计时器工作，因而“单线程的 JavaScrip”能够实现异步。</p><p>定时触发器线程其实只是一个计时的作用，它并不会真正执行时间到了的回调函数，真正执行这个回调函数的还是 JS引擎线程。所以当时间到了，定时触发器线程会将回调函数给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS引擎线程从事件队列取出这个回调函数执行。</p><h2 id="异步HTTP请求线程"><a href="#异步HTTP请求线程" class="headerlink" title="异步HTTP请求线程"></a>异步HTTP请求线程</h2><p>异步HTTP请求线程负责处理异步的 Ajax 请求，当请求完成后，它也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给JS引擎线程执行。</p><h2 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h2><p>事件触发线程主要用来控制事件循环，比如 JavaScript 执行遇到定时器，AJAX 异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到事件队列，等待JS引擎线程来处理。事件触发线程不仅会将定时器事件放入事件队列，其它满足条件的事件也是它负责放进事件队列。</p><p>JavaScript 异步的实现靠的就是浏览器的多线程，当主线程遇到异步任务时，就将这个任务交给对应的线程，当这个异步任务满足回调函数条件时，对应的线程又通过事件触发线程将这个任务放入事件队列，然后主线程从事件队列取出事件继续执行。事件队列（Event Queue）是事件循环（Event Loop）的一部分。</p><h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>Event Loop 是 JavaScript 管理事件执行的一个流程，具体的管理办法由它具体的运行环境确定。<br>JavaScript 的主要运行环境有两个：浏览器和 Node.js。这两个环境的 Event Loop 有区别。</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>Event Queue 里面的事件分两类：宏任务和微任务。</p><p>微任务拥有更高的优先级，Event Loop 遍历队列时会先检查微任务队列，如果里面有任务就全部拿来执行，执行完所有微任务之后再执行下一个宏任务。执行每个宏任务之前都检查微任务队列是否有任务，如果有会优先执行微任务队列。</p><table><thead><tr><th align="center">常见宏任务</th><th align="center">浏览器环境</th><th align="center">Node.js 环境</th></tr></thead><tbody><tr><td align="center">I/O</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">script（外层同步代码）</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">setTimeout</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">setInterval</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">setImmediate</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td align="center">requestAnimationFrame</td><td align="center">✅</td><td align="center">❌</td></tr></tbody></table><table><thead><tr><th align="center">常见微任务</th><th align="center">浏览器环境</th><th align="center">Node.js 环境</th></tr></thead><tbody><tr><td align="center">Promise</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">async/await</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">process.nextTick</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td align="center">MutaionObserver</td><td align="center">✅</td><td align="center">❌</td></tr></tbody></table><p>不同类型的任务会进入对应的 Event Queue，比如 setTimeout 和 setInterval 会进入相同的 Event Queue。</p><p>事件循环的顺序，决定 JS 代码的执行顺序。进入整体代码（宏任务）后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个事件队列执行完毕，再执行所有的微任务。</p><h2 id="浏览器的-Event-Loop"><a href="#浏览器的-Event-Loop" class="headerlink" title="浏览器的 Event Loop"></a>浏览器的 Event Loop</h2><p>Event Loop 是各个异步线程用来通讯和协同执行的机制。各个线程为了交换消息，还有一个公用的数据区，这就是 Event Queue。各个异步线程执行完后，通过事件触发线程将回调函数放到 Event Queue。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da2a8fb96e8c49d08589c1c31470d366~tplv-k3u1fbpfcp-watermark.awebp" alt="浏览器的 Event Loop"></p><p>执行流程：</p><ul><li>主线程执行时，先看要执行的是同步任务还是异步任务；</li><li>同步任务进入主线程，异步任务进入相对应的线程，主线程继续执行同步任务；</li><li>相对应的线程执行异步任务，满足条件后对应的线程将异步任务的回调函数放入 Event Queue；</li><li>主线程内的任务执行完毕后就去 Event Queue 取出里面的函数进入主线程执行；</li></ul><p>主线程不断循环上述执行流程，就是浏览器的 Event Loop。</p><h3 id="计时不准"><a href="#计时不准" class="headerlink" title="计时不准"></a>计时不准</h3><p>Event Loop 的这个流程里面其实还是隐藏了一些问题的，最典型的就是总是先执行同步任务，然后再执行 Event Queue 里面的回调函数。这个特性就直接影响了定时器的执行。如果主线程长时间被阻塞，定时器的回调函数就没机会执行，即使执行了时间也不准。所以写代码时一定不要长时间占用主线程。</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>setTimeout() 用于指定在一定时间后执行某些代码。实际中，是指经过指定时间后，把要执行的任务加入到 Event Queue 中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间大于指定的时间。</p><p>setTimeout(fn, 0) 含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少时间，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。但是，即便主线程为空，0 毫秒实际上也达不到。根据 HTML 的标准最低是 4 毫秒。而且，setTimeout(fn, 0) 会被强制改为 setTimeout(fn, 1)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行啦1&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行啦2&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;先执行这里&#x27;</span>);<br><span class="hljs-comment">// 先执行这里</span><br><span class="hljs-comment">// 执行啦2</span><br><span class="hljs-comment">// 执行啦1</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行啦1&#x27;</span>)<br>&#125;, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行啦2&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;先执行这里&#x27;</span>);<br><span class="hljs-comment">// 先执行这里</span><br><span class="hljs-comment">// 执行啦1</span><br><span class="hljs-comment">// 执行啦2</span><br></code></pre></td></tr></table></figure><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>setInterval() 用于指定每隔一段时间执行某些代码，直到取消循环或者页面卸载。setInterval() 会在每过指定的时间，将注册的函数放入 Event Queue。同理，如果 Event Queue 前面的任务耗时太久，一样需要等待。</p><p>唯一需要注意的一点是，对 setInterval(fn, ms) 来说，我们已经知道不是每过 ms 秒会执行一次 fn，而是每过 ms 秒，会有 fn 进入 Event Queue。一旦 setInterval 的回调函数 fn 执行时间超过了延迟时间 ms，那就完全看不出来有指定的时间间隔。</p><h2 id="Node-js-的-Event-Loop"><a href="#Node-js-的-Event-Loop" class="headerlink" title="Node.js 的 Event Loop"></a>Node.js 的 Event Loop</h2><p>Node.js 是运行在服务端的 JavaScrip，虽然它也用到了 V8 引擎，但是它的服务目的和环境不同，导致了它的 API 与原生 JavaScript 有些区别，它的 Event Loop 还要处理一些 I/O，比如新的网络连接等，所以与浏览器 Event Loop 也是不一样的。Node.js 的 Event Loop 是分阶段的，而且 Node.js 是先将外层的同步代码一次性全部执行完，遇到异步任务就塞到对应的阶段，然后进入 Event Queue 进行阶段循环。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3027cbdfe546433a84fd8f80733e99dd~tplv-k3u1fbpfcp-watermark.awebp" alt="Node.js 的 Event Loop"></p><p>不同阶段：</p><ul><li>timers：执行 setTimeout 和 setInterval 的回调函数；</li><li>pending callbacks：执行延迟到下一个循环迭代的 I/O 回调函数；</li><li>idle：仅系统内部使用；</li><li>prepare：仅系统内部使用；</li><li>poll：检索新的 I/O 事件、执行与 I/O 相关的回调函数；</li><li>check：setImmediate 在这里执行；</li><li>close callbacks：一些关闭的回调函数。</li></ul><p>不断循环上述执行阶段，就是 Node.js 的 Event Loop。</p><p>每个阶段都有一个自己先进先出的队列，只有当这个队列的事件执行完或者达到该阶段的上限时，才会进入下一个阶段。在每次事件循环之间，Node.js 都会检查它是否在等待任何一个 I/O 或者定时器，如果没有程序就关闭退出。我们的直观感受就是，如果一个 Node.js 程序只有同步代码，在控制台运行完后它就退出了。</p><p>需要注意的是 poll 阶段，它后面并不一定每次都是 check 阶段，poll 队列执行完后，如果没有 setImmediate 但是有定时器到期，它会绕回去执行定时器阶段。</p><h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate"></a>setImmediate</h3><p>在一个异步流程里，setImmediate 会比定时器先执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 Node.js 执行</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;outer&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>  &#125;, <span class="hljs-number">0</span>); <span class="hljs-comment">// setTimeout(fn, 0)会被强制改为setTimeout(fn, 1)</span><br>  setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>  &#125;);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// outer</span><br><span class="hljs-comment">// setImmediate</span><br><span class="hljs-comment">// setTimeout</span><br></code></pre></td></tr></table></figure><p>上面<code>console.log(&#39;setTimeout&#39;)</code>和<code>console.log(&#39;setImmediate&#39;)</code>都包在了一个 setTimeout 里面，如果直接写在最外层会怎么样呢？上面没有问题，但是，下面的代码输出结果不一定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 Node.js 执行</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;outer&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>); <span class="hljs-comment">// setTimeout(fn, 0)会被强制改为setTimeout(fn, 1)</span><br>setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// outer</span><br><span class="hljs-comment">// setImmediate</span><br><span class="hljs-comment">// setTimeout</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 Node.js 执行</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;outer&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>); <span class="hljs-comment">// setTimeout(fn, 0)会被强制改为setTimeout(fn, 1)</span><br>setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// outer</span><br><span class="hljs-comment">// setTimeout</span><br><span class="hljs-comment">// setImmediate</span><br></code></pre></td></tr></table></figure><p>分析执行流程：</p><ul><li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li><li>遇到 setTimeout，虽然设置是 0 毫秒触发，但是被 node.js 强制改为 1 毫秒，塞入 times 阶段</li><li>遇到 setImmediate 塞入 check 阶段</li><li>同步代码执行完毕，进入 Event Loop</li><li>先进入 times 阶段，检查是否过去 1 毫秒：若已过，满足 setTimeout 条件，执行回调；若未过，跳过</li><li>跳过空的阶段，进入 check 阶段，执行 setImmediate 回调</li></ul><p>关键就在这个 1 毫秒，如果同步代码执行时间较长，进入 Event Loop 的时候 1 毫秒已经过了，setTimeout 执行，如果 1 毫秒还没到，就先执行了 setImmediate。每次我们运行脚本时，机器的状态可能不一样，导致运行时有 1 毫秒的差距，一会儿 setTimeout 先执行，一会儿 setImmediate 先执行。但是这种情况只会发生在还没进入timers 阶段的时候。像第一个例子那样，因为已经在 timers 阶段，所以里面的 setTimeout 只能等下个循环，所以 setImmediate 肯定先执行。同理的还有其他 poll 阶段也是这样。</p><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><p>process.nextTick() 是一个特殊的异步任务，它不属于任何的 Event Loop 阶段。实际 Node 在遇到这个 API 时 Event Loop 根本就不会继续进行，而是马上停下来执行 process.nextTick()，执行完后继续 Event Loop。可以理解为，该任务执行在同步任务执行之后、异步任务执行之前；或者理解为，该任务在微任务队列最前列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 Node.js 执行</span><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;start&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br>  setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>    process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick 2&#x27;</span>);<br>    &#125;);<br>  &#125;);<br>  process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick 1&#x27;</span>);<br>  &#125;);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;end&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// start</span><br><span class="hljs-comment">// end</span><br><span class="hljs-comment">// nextTick 1</span><br><span class="hljs-comment">// setImmediate</span><br><span class="hljs-comment">// nextTick 2</span><br><span class="hljs-comment">// setTimeout</span><br></code></pre></td></tr></table></figure><p>分析执行流程：</p><ul><li>代码基本都在 readFile 回调里面，它自己执行时，已经在 poll 阶段</li><li>遇到 setTimeout(fn, 0)，其实是 setTimeout(fn, 1)，塞入之后的 timers 阶段</li><li>遇到 setImmediate 塞入 check 阶段</li><li>遇到 nextTick 立马执行，输出<code>nextTick 1</code></li><li>到 check 阶段，输出<code>setImmediate</code>，又遇到 nextTick 立马执行，输出<code>nextTick 2</code></li><li>到 timers 阶段，输出<code>setTimeout</code></li></ul><p>这种机制其实类似于微任务，但是并不完全一样，同时有 nextTick 和 Promise 时是 nextTick 先执行，原因是 nextTick 的队列比 Promise 队列优先级更高。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 Node.js 执行</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-built_in">Promise</span>.resolve();<br>setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;)<br>promise.then(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>)<br>&#125;);<br>process.nextTick(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fafa&#x27;</span>);<br><span class="hljs-comment">// fafa</span><br><span class="hljs-comment">// nextTick</span><br><span class="hljs-comment">// promise</span><br><span class="hljs-comment">// setImmediate</span><br></code></pre></td></tr></table></figure><h1 id="实践分析"><a href="#实践分析" class="headerlink" title="实践分析"></a>实践分析</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (params &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>      resolve(params)<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)<br>      reject(params)<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)<br>    &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryTest</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  test(x)<br>    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(res)<br>    &#125;)<br>    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(-err)<br>    &#125;)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)<br>tryTest(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>)<br>tryTest(-<span class="hljs-number">200</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>)<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 6</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 7</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 8</span><br><span class="hljs-comment">// 100 </span><br><span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (params &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>      resolve(params)<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>      reject(params)<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)<br>    &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryTest</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x1:&#x27;</span>, x);<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> test(x)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x2:&#x27;</span>, x);<br>  <span class="hljs-built_in">console</span>.log(res);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)<br>tryTest(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)<br>tryTest(-<span class="hljs-number">200</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>)<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// x1:100</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 6</span><br><span class="hljs-comment">// x1:-200</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 7</span><br><span class="hljs-comment">// x2:100 </span><br><span class="hljs-comment">// 100</span><br><span class="hljs-comment">// Uncaught (in promise) -200</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;)<br><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>);<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;console&#x27;</span>);<br><span class="hljs-comment">// promise</span><br><span class="hljs-comment">// console</span><br><span class="hljs-comment">// setTimeout</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printa</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1:&#x27;</span>, a);<br>  <span class="hljs-keyword">let</span> result = a + <span class="hljs-keyword">await</span> <span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2:&#x27;</span>, a);<br>  <span class="hljs-built_in">console</span>.log(result);<br>&#125;<br>printa();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;log&#x27;</span>);<br>a++;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3:&#x27;</span>, a);<br><span class="hljs-comment">// 1:0</span><br><span class="hljs-comment">// log</span><br><span class="hljs-comment">// 3:1</span><br><span class="hljs-comment">// 2:1</span><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printb</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1:&#x27;</span>, b);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-number">10</span> + b;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2:&#x27;</span>, b);<br>  <span class="hljs-built_in">console</span>.log(result);<br>&#125;<br>printb();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;log&#x27;</span>);<br>b++;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3:&#x27;</span>, b);<br><span class="hljs-comment">// 1:0</span><br><span class="hljs-comment">// log</span><br><span class="hljs-comment">// 3:1</span><br><span class="hljs-comment">// 2:1</span><br><span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> async2().then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async2 end&quot;</span>)<br>  &#125;);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 start&#x27;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br>async1();<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>  resolve();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise3&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">// script start</span><br><span class="hljs-comment">// async1 start</span><br><span class="hljs-comment">// async2 start</span><br><span class="hljs-comment">// promise1</span><br><span class="hljs-comment">// promise2</span><br><span class="hljs-comment">// async2 end</span><br><span class="hljs-comment">// promise3</span><br><span class="hljs-comment">// async1 end</span><br><span class="hljs-comment">// setTimeout</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> async3();<br>  <span class="hljs-keyword">await</span> async2().then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async2 end&quot;</span>)<br>  &#125;);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 start&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async3</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async3&#x27;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><br>async1();<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>  resolve();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise3&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">// script start</span><br><span class="hljs-comment">// async1 start</span><br><span class="hljs-comment">// async3</span><br><span class="hljs-comment">// promise1</span><br><span class="hljs-comment">// promise2</span><br><span class="hljs-comment">// async2 start</span><br><span class="hljs-comment">// promise3</span><br><span class="hljs-comment">// async2 end</span><br><span class="hljs-comment">// async1 end</span><br><span class="hljs-comment">// setTimeout</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 Node.js 执行</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>  &#125;)<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>    resolve();<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>)<br>  &#125;)<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);<br>  resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>)<br>&#125;)<br><br>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>);<br>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>);<br>  &#125;)<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>);<br>    resolve();<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)<br>  &#125;)<br>&#125;)<br><span class="hljs-comment">// 1 6 8 7 2 4 3 5 9 11 10 12</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>浏览器</tag>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue面试题</title>
    <link href="/2021/08/20/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/08/20/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-优点"><a href="#Vue-优点" class="headerlink" title="Vue 优点"></a>Vue 优点</h1><ul><li>轻量级框架。只关注视图层，体积小。</li><li>组件化。把单页应用中的模块拆分为一个个单独组件，清晰明了。</li><li>响应式数据绑定。自动对页面某些数据的变化做出同步响应。</li><li>使用虚拟 DOM 算法。使用虚拟 DOM 配合 diff 算法，提高性能。  </li></ul><h1 id="为什么-Vue-组件中-data-必须是一个函数"><a href="#为什么-Vue-组件中-data-必须是一个函数" class="headerlink" title="为什么 Vue 组件中 data 必须是一个函数"></a>为什么 Vue 组件中 data 必须是一个函数</h1><p>对象为引用类型，若 data 是对象，当复用组件时，同样的组件的 data 都指向同一个数据对象，使用相同的内存地址，导致数据混用：当在一个组件中修改 data 时，其他同样的组件的 data 会同时被修改；若 data 是函数，当复用组件时，都会调用函数，返回是一个新对象，使用不同的内存地址，数据不会混用。</p><h1 id="Vue-组件通信"><a href="#Vue-组件通信" class="headerlink" title="Vue 组件通信"></a>Vue 组件通信</h1><p>参考：<a href="https://juejin.cn/post/6999687348120190983">https://juejin.cn/post/6999687348120190983</a> 。</p><ul><li>父组件向子组件传递数据通过 props 传递</li><li>子组件向父组件传递数据通过 $emit 触发事件</li><li>获取当前组件的父组件 $parent、根组件 $root（不推荐）</li><li>获取当前组件的子组件 $children、组件实例 $refs （不推荐）</li><li>bus 事件总线</li><li>Vuex 状态管理</li></ul><h2 id="Vue2-x-组件通信共有-12-种："><a href="#Vue2-x-组件通信共有-12-种：" class="headerlink" title="Vue2.x 组件通信共有 12 种："></a>Vue2.x 组件通信共有 12 种：</h2><ul><li>props</li><li>$refs</li><li>$root</li><li>$emit / v-on</li><li>$children / $parent</li><li>$attrs / $listeners</li><li>provide / inject</li><li>.sync</li><li>v-model</li><li>EventBus</li><li>Vuex</li><li>slot</li></ul><h2 id="父子组件通信可以用："><a href="#父子组件通信可以用：" class="headerlink" title="父子组件通信可以用："></a>父子组件通信可以用：</h2><ul><li>props</li><li>$refs</li><li>$root</li><li>$emit / v-on</li><li>$children / $parent</li><li>$attrs / $listeners</li><li>provide / inject</li><li>.sync</li><li>v-model</li><li>EventBus</li><li>Vuex</li><li>slot</li></ul><h2 id="兄弟组件通信可以用："><a href="#兄弟组件通信可以用：" class="headerlink" title="兄弟组件通信可以用："></a>兄弟组件通信可以用：</h2><ul><li>$parent</li><li>EventBus</li><li>Vuex</li></ul><h2 id="跨层级组件通信可以用："><a href="#跨层级组件通信可以用：" class="headerlink" title="跨层级组件通信可以用："></a>跨层级组件通信可以用：</h2><ul><li>$root</li><li>$attrs / $listeners</li><li>provide / inject</li><li>EventBus</li><li>Vuex</li></ul><h1 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h1><p>v-if 确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，首次渲染时，v-if 条件为真才会在 DOM 树上，v-if 条件为假则什么也不做，不会在 DOM 树上，直到条件变为真才会在 DOM 树上；对应，v-show 无论首次渲染时是否真假都会在 DOM 树上，如果条件不为真，其对应 CSS 为<code>dispaly: none</code>。</p><p>因此，操作元素时，v-if 更消耗性能，因为 v-if 在使用过程中有 DOM 的添加和删除，v-show 在使用过程中只是操作 CSS。v-if 适用于在运行时很少改变条件、不会频繁切换条件的场景。v-show 适用于在运行时经常改变条件、需要频繁切换条件的场景。</p><h1 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h1><h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h2><ul><li>支持缓存，依赖其他属性值，只有其依赖值的数据发生改变，才会触发相应的操作；</li><li>不支持异步；</li><li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值；</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed；</li><li>如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法；</li><li>适用于在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来。</li></ul><h2 id="侦听属性-watch"><a href="#侦听属性-watch" class="headerlink" title="侦听属性 watch"></a>侦听属性 watch</h2><ul><li>不支持缓存，监听到值的变化，就会直接触发相应的操作；</li><li>支持异步；</li><li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li><li>当一个属性发生变化时，需要执行对应的操作，一对多；</li><li>监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数；</li><li>适用于观测某个值的变化去完成一段复杂的业务逻辑。</li></ul><h1 id="Vue-Loader-是什么？使用它的用途有哪些？"><a href="#Vue-Loader-是什么？使用它的用途有哪些？" class="headerlink" title="Vue Loader 是什么？使用它的用途有哪些？"></a>Vue Loader 是什么？使用它的用途有哪些？</h1><p>Vue Loader 是一个 webpack 的 loader，是 vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。</p><h1 id="Vue-指令"><a href="#Vue-指令" class="headerlink" title="Vue 指令"></a>Vue 指令</h1><ul><li>v-text</li><li>v-html</li><li>v-show</li><li>v-if</li><li>v-else</li><li>v-else-if</li><li>v-for</li><li>v-on</li><li>v-bind</li><li>v-model</li><li>v-slot</li><li>v-pre</li><li>v-cloak</li><li>v-once</li></ul><h1 id="使用-v-for-时-key-的作用"><a href="#使用-v-for-时-key-的作用" class="headerlink" title="使用 v-for 时 key 的作用"></a>使用 v-for 时 key 的作用</h1><p>当 Vue 用 - v-for 正在更新已渲染过的元素列表时使用“就地复用”策略。如果数据项的顺序被改变，Vue 将不是移动 DOM 元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>key 属性用于方便 Vue 跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key 属性。key 属性只能为 Strig 或 Number 类型。<br>如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，Vue 会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p><h1 id="nextTick-使用场景和原理"><a href="#nextTick-使用场景和原理" class="headerlink" title="$nextTick 使用场景和原理"></a>$nextTick 使用场景和原理</h1><p>Vue 实现响应式并不是数据发生变化后 DOM 立即变化，而是按照一定的策略来进行 DOM 更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p><h1 id="Vue-数据双向绑定原理"><a href="#Vue-数据双向绑定原理" class="headerlink" title="Vue 数据双向绑定原理"></a>Vue 数据双向绑定原理</h1><p>参考：<a href="https://juejin.cn/post/6844903903822086151">https://juejin.cn/post/6844903903822086151</a> 。<br>Demo：<a href="https://github.com/xuekeven/js-learn_vue2/tree/main/15.vue%E5%8E%9F%E7%90%86%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/%E5%93%8D%E5%BA%94%E6%80%A7/4.mini-observer.html">https://github.com/xuekeven/js-learn_vue2/tree/main/15.vue原理高级教程/响应性/4.mini-observer.html</a> 。</p><p>1、实现一个监听器 Observer ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；<br>2、实现一个订阅器 Dep，用来收集订阅者，对监听器 Observer 和 订阅者 Watcher 进行统一管理；<br>3、实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的方法，从而更新视图；<br>4、实现一个解析器 Compile，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。</p><h1 id="Vue3-对比-Vue2"><a href="#Vue3-对比-Vue2" class="headerlink" title="Vue3 对比 Vue2"></a>Vue3 对比 Vue2</h1><p>参考：<a href="https://juejin.cn/post/6892295955844956167">https://juejin.cn/post/6892295955844956167</a> 。</p><h1 id="观察者模式与发布订阅模式"><a href="#观察者模式与发布订阅模式" class="headerlink" title="观察者模式与发布订阅模式"></a>观察者模式与发布订阅模式</h1><p>参考：<a href="https://juejin.cn/post/6844903603107266567">https://juejin.cn/post/6844903603107266567</a> 。</p>]]></content>
    
    
    <categories>
      
      <category>框架和类库</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>框架和类库</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络面试题</title>
    <link href="/2021/08/20/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/08/20/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="OSI-七层模型和-TCP-IP-四层模型"><a href="#OSI-七层模型和-TCP-IP-四层模型" class="headerlink" title="OSI 七层模型和 TCP/IP 四层模型"></a>OSI 七层模型和 TCP/IP 四层模型</h2><p>参考：<a href="https://juejin.cn/post/6939691851746279437">https://juejin.cn/post/6939691851746279437</a> 。</p><p>OSI 七层模型：（从上到下）应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。<br>TCP/IP 四层模型：（从上到下）应用层，传输层，网络层，数据链路层。</p><table><thead><tr><th align="center">TCP/IP 四层模型</th><th align="center">典型协议</th><th align="center">对应的 OSI 七层模型</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">HTTP、FTP</td><td align="center">应用层、表示层、会话层</td></tr><tr><td align="center">传输层</td><td align="center">TCP、UDP</td><td align="center">传输层</td></tr><tr><td align="center">网络层</td><td align="center">IP</td><td align="center">网络层</td></tr><tr><td align="center">数据链路层</td><td align="center">-</td><td align="center">数据链路层、物理层</td></tr></tbody></table><h2 id="浏览器输入一个-URL-按下回车后发生了什么"><a href="#浏览器输入一个-URL-按下回车后发生了什么" class="headerlink" title="浏览器输入一个 URL 按下回车后发生了什么"></a>浏览器输入一个 URL 按下回车后发生了什么</h2><p>参考：<br><a href="https://juejin.cn/post/6935232082482298911">https://juejin.cn/post/6935232082482298911</a> 。<br><a href="https://juejin.cn/post/6844904021308735502">https://juejin.cn/post/6844904021308735502</a> 。</p><ul><li>输入网址并解析<ul><li>URL 解析</li><li>DNS 查询</li><li>HTTP 缓存</li></ul></li><li>TCP 三次握手建立连接</li><li>浏览器发送 HTTP 请求报文</li><li>服务器处理 HTTP 请求报文并返回 HTTP 响应报文</li><li>浏览器处理 HTTP 响应报文</li><li>TCP 四次挥手断开连接</li><li>浏览器渲染页面<ul><li>解析 HTML 文件，构建 DOM Tree</li><li>解析 CSS 文件，构建 CSSOM Tree</li><li>利用 DOM Tree 和 CSSOM Tree 构建 Render Tree</li><li>布局 Render Tree 计算每个节点的位置大小等信息（回流）</li><li>绘制 Render Tree 每个节点像素信息渲染到屏幕（重绘）</li><li>合并渲染层</li></ul></li></ul><h2 id="WebSocket-与-Ajax-的区别"><a href="#WebSocket-与-Ajax-的区别" class="headerlink" title="WebSocket 与 Ajax 的区别"></a>WebSocket 与 Ajax 的区别</h2><p>参考：<a href="https://juejin.cn/post/6939691851746279437">https://juejin.cn/post/6939691851746279437</a> 。</p><table><thead><tr><th>区别</th><th>WebSocket</th><th>Ajax</th></tr></thead><tbody><tr><td>本质</td><td>是异步 JavaScript 和 XML，是一种创建交互式网页的应用的网页开发技术</td><td>是 HTML5 的一种新协议，实现了浏览器和服务器的实时通信</td></tr><tr><td>生命周期</td><td>WebSocket 是长连接，会话一直保持</td><td>Ajax 发送接收之后就会断开</td></tr><tr><td>适用范围</td><td>WebSocket 用于前后端实时交互数据</td><td>Ajax 非实时</td></tr><tr><td>发起人</td><td>WebSocket 服务器端和客户端相互推送</td><td>Ajax 客户端发起</td></tr></tbody></table><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-请求方式"><a href="#HTTP-请求方式" class="headerlink" title="HTTP 请求方式"></a>HTTP 请求方式</h2><p>参考：<a href="https://juejin.cn/post/6939691851746279437">https://juejin.cn/post/6939691851746279437</a> 。</p><ul><li>GET：获取数据</li><li>HEAD：获取数据的元信息</li><li>POST：提交数据</li><li>PUT：修改数据</li><li>DELETE：删除数据</li><li>CONNECT：建立连接隧道，用于代理服务器</li><li>OPTIONS：列出可对资源实行的请求方法，常用于跨域</li><li>TRACE：追踪请求-响应的传输路径</li></ul><p>GET 是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。<br>POST 是是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。</p><p>GET 方法就是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全的，而且每次的结果都是相同的。POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以不安全，而且多次提交数据就会创建多个资源，所以不幂等。</p><h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p>参考：<br><a href="https://juejin.cn/post/6844903517702848526">https://juejin.cn/post/6844903517702848526</a> 。<br><a href="https://juejin.cn/post/6844904021308735502">https://juejin.cn/post/6844904021308735502</a> 。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>HTTP 缓存属于客户端缓存。我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件。我们将缓存分为强制缓存和协商缓存。两类缓存机制同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如果缓存命中，则不再进行缓存协商。</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>当缓存数据库中已有所请求的数据，而且没有过期时，属于强制缓存命中，浏览器不会向服务器发送请求，而是直接返回状态码 200 并且从缓存数据库获取数据；当缓存数据库中没有所请求的数据或是数据已过期，属于强制缓存未命中，浏览器才会向服务器发起请求。<br><img src="/images/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98.png" alt="强制缓存（来源掘金@北海北方）"></p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>如果是缓存数据库的数据已过期，则浏览器向服务器发起请求前，会先从缓存数据库中获取到一个缓存数据标识，得到标识后请求服务器来验证数据是否失效（新鲜）。如果标识没有失效（资源未更新），属于协商缓存命中，服务器返回状态码 304 并且告诉浏览器直接使用缓存数据库资源；如果标识失效（资源更新），属于协商缓存未命中，服务器返回状态码 200 和新资源。<br><img src="/images/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png" alt="协商缓存（来源掘金@北海北方）"></p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>浏览器和服务器是如何判断缓存是否过期和失效呢？浏览器和服务器进行交互的时候会发送一些请求数据和响应数据，我们称之为 HTTP 报文。报文中包含首部header和主体部分body。与缓存相关的规则信息就包含在header中。boby中的内容是 HTTP 请求真正要传输的部分。HTTP 缓存机制在首部header中相关参数为 Expires、Cache-Control、Last-Modified、If-Modified-Since、Etag、If-None-Match 等。</p><h4 id="强制缓存-1"><a href="#强制缓存-1" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>对于强制缓存，服务器响应的header中会用两个字段来表明：Expires 和 Cache-Control。</p><ul><li>Expires</li></ul><p>Expires 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于此时间，则直接使用缓存数据库的数据。但是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的，这将导致缓存命中的误差。</p><ul><li>Cache-Control</li></ul><p>Cache-Control 有很多属性，不同的属性代表的意义也不同。最主要是 max-age，当 max-age 设为 300 时，则代表在这个请求正确返回时间的 300 秒（5 分钟）内再次加载资源，就会命中强制缓存。除 max-age 外，还有其它比较常用的设置值，可组合使用。</p><p>Expires 是 HTTP1.0 头字段，Cache-Control 是 HTTP1.1 头字段，如果 Expires 和 Cache-Control 同时存在，则 Cache-Control 会覆盖 Expires。</p><h4 id="协商缓存-1"><a href="#协商缓存-1" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断数据是否失效。</p><ul><li>Last-Modified：</li></ul><p>服务器在响应请求时，通过此字段告诉浏览器当前资源的最后修改时间。</p><ul><li>If-Modified-Since</li></ul><p>浏览器再次请求服务器时，浏览器的请求报文头部会包含此字段，后面跟着在缓存数据库中获得的最后修改时间 Last-Modified。服务器接收到此请求头后发现有 If-Modified-Since，则与被请求资源的最后修改时间来进行对比。</p><ul><li>Etag</li></ul><p>服务器在响应请求时，通过此字段告诉浏览器当前资源的唯一标识（生成规则由服务器决定）。</p><ul><li>If-None-Match</li></ul><p>浏览器再次请求服务器时，浏览器的请求报文头部会包含此字段，后面跟着在缓存数据库中获得的唯一标识 Etag。服务器接收到此请求头后发现有 If-None-Match，则与被请求资源的唯一标识来进行对比。</p><p>在精准度上，ETag 优于 Last-Modified，因为 ETag 是按照内容给资源上标识，因此能准确感知资源的变化，而 Last-Modified 则不一样，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况：①资源文件被编辑，但是文件内容并没有更改，那这样也会造成缓存失效；②Last-Modified 能够感知的单位时间是秒，如果资源文件在 1 秒内被多次改变，那么此时的 Last-Modified 并没有体现出修改了。</p><p>在性能上，Last-Modified 优于 ETag，因为 Last-Modified 仅仅只是记录一个时间点，而 Etag 需要根据文件具体内容生成哈希值。服务器会优先考虑 ETag。</p><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p>当强制缓存命中或者协商缓存中命中时，我们直接从缓存中获取资源，那这些资源究竟缓存在什么位置呢？浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><p>Service Worker 借鉴了 Web Worker 的思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。</p><p>Memory Cache 是内存缓存。已经加载过该资源且缓存在内存当中，直接从内存中读取数据。关闭浏览器后数据将不存在，再次打开相同的页面时不可能再是 from memory cache。从效率上讲它是最快的，但从存活时间讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p><p>Disk Cache 是磁盘缓存。已经在之前的某个时间加载过该资源，直接从硬盘中读取数据，关闭浏览器后数据依然存在，再次打开相同的页面时可能仍然是 from disk cache。从效率上讲比内存缓存慢，但它的优势在于存储容量和存储时长。比较大的 JS 和 CSS 文件会直接被丢进 Disk Cache，反之丢进 Memory Cache。内存使用率比较高的时候，文件优先进入磁盘。</p><p>Push Cache 是推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 的内容，虽然现在应用并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。</p><h3 id="缓存优点"><a href="#缓存优点" class="headerlink" title="缓存优点"></a>缓存优点</h3><ul><li>减少了冗余的数据传递，节省宽带流量</li><li>减少了服务器的负担，大大提高了网站性能</li><li>加快了浏览器加载网页的速度</li></ul><h3 id="不同请求"><a href="#不同请求" class="headerlink" title="不同请求"></a>不同请求</h3><ul><li><strong>地址栏写入URL</strong>：浏览器发现缓存中有这个文件，不用继续请求，直接从缓存拿（最快）</li><li><strong>F5</strong>：去服务器看看缓存中的文件是否过期，于是浏览器就发送一个请求</li><li><strong>Ctrl + F5</strong>：先将缓存中的文件删除，然后去服务器请求完整的资源文件</li></ul><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><table><thead><tr><th align="center"></th><th align="center">类别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">Information（信息状态码）</td><td align="center">提示信息，表示目前是协议的中间状态，还需要后续操作</td></tr><tr><td align="center">2xx</td><td align="center">Success（成功状态码）</td><td align="center">成功，报文已经收到并被正确处理</td></tr><tr><td align="center">3xx</td><td align="center">Redirection（重定向状态码）</td><td align="center">重定向，资源位置发送变动，需要客户端重新请求</td></tr><tr><td align="center">4xx</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">客户端错误，请求报文错误，服务器无法处理</td></tr><tr><td align="center">5xx</td><td align="center">Server Error（服务端错误状态码）</td><td align="center">服务器错误，服务器在处理请求时内部出错</td></tr></tbody></table><table><thead><tr><th align="center">常用状态码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">请求成功，一切正常</td></tr><tr><td align="center">301</td><td align="center">永久重定向，请求的资源已经不存在，需用新 URL 访问，浏览器会自动重定向并缓存</td></tr><tr><td align="center">302</td><td align="center">临时重定向，请求的资源还在，但暂时需用新 URL 访问，浏览器会自动重定向不缓存</td></tr><tr><td align="center">303</td><td align="center">临时重定向，重定向到新地址时，客户端必须使用GET方法请求新地址</td></tr><tr><td align="center">304</td><td align="center">缓存重定向，请求的资源未修改，重定向至已存在的缓存文件，用于缓存控制</td></tr><tr><td align="center">307</td><td align="center">临时重定向，和302相似，唯一区别是不允许将请求方法从POST改为GET</td></tr><tr><td align="center">308</td><td align="center">永久重定向，和301相似，唯一区别是不允许将请求方法从POST改为GET</td></tr><tr><td align="center">400</td><td align="center">客户端请求报文错误，但原因未知</td></tr><tr><td align="center">401</td><td align="center">用户身份验证未通过</td></tr><tr><td align="center">403</td><td align="center">服务器理解请求但拒绝授权禁止访问，不是客户端的请求出错</td></tr><tr><td align="center">404</td><td align="center">请求的资源在服务器上不存在或未找到</td></tr><tr><td align="center">500</td><td align="center">服务器处理错误，但原因未知</td></tr><tr><td align="center">503</td><td align="center">服务器繁忙，暂时无法响应</td></tr></tbody></table><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>成功，表示请求在服务器被正常处理。</p><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>永久重定向，表示请求的资源已经不存在，需用新 URI 访问，浏览器会自动重定向并缓存。</p><h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>临时重定向，表示请求的资源还在，但暂时需用新 URL 访问，浏览器会自动重定向不缓存。</p><h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>临时重定向，与 302 有相同的含义，不同的是，重定向到新地址时，浏览器必须使用 GET 请求方法。</p><h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>临时重定向，与 302 有相同的含义，不同的是，重定向到新地址时，不允许将请求方法从 POST 改为 GET。</p><h3 id="308-Permanent-Redirect"><a href="#308-Permanent-Redirect" class="headerlink" title="308 Permanent Redirect"></a>308 Permanent Redirect</h3><p>永久重定向，与 301 有相同的含义，不同的是，重定向到新地址时，不允许将请求方法从 POST 改为 GET。</p><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>客户端请求报文错误，但原因未知。</p><h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>用户身份验证未通过。</p><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>服务器理解请求但拒绝授权禁止访问，不是客户端的请求出错。</p><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>请求的资源在服务器上不存在或未找到，也可能是服务器端在拒绝请求且不想说明原因。</p><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>服务器处理错误，但原因未知。</p><h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>服务器繁忙，暂时无法响应。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>参考：<br><a href="https://juejin.cn/post/6844904021308735502">https://juejin.cn/post/6844904021308735502</a> 。<br><a href="https://juejin.cn/post/6844903599303032845">https://juejin.cn/post/6844903599303032845</a> 。<br><a href="http://ruanyifeng.com/blog/2014/02/ssl_tls.html">http://ruanyifeng.com/blog/2014/02/ssl_tls.html</a> 。</p><p>HTTP 的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，就是HTTP 数据经过 TCP 层，然后经过 WIFI 路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是常说的中间人攻击。而且，客户端和服务器无法互相认证，无法确认对方是否是真正的而非伪装的服务器和客户端。</p><p>为了安全，我们引入新的加密方案，即 HTTPS。HTTPS 并不是一个新的协议，而是一个加强版的 HTTP。其原理是在 HTTP 和 TCP 之间建立了一个中间层，HTTP 和 TCP 通信时并不是像以前直接通信，而是经过了一个中间层进行加密，这个中间层也叫安全层。</p><p>安全层使用 TLS/SSL 协议，核心就是对数据加解密。TLS/SSL 的功能实现主要依赖于三类算法：散列函数、对称加密和非对称加密。其中，非对称加密实现身份认证和密钥协商，对称加密用协商的密钥对数据加密，散列函数验证信息的完整性。</p><h1 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h1><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p>参考：<br><a href="https://juejin.cn/post/6939691851746279437">https://juejin.cn/post/6939691851746279437</a> 。<br><a href="https://juejin.cn/post/6972027657047244837">https://juejin.cn/post/6972027657047244837</a> 。</p><p>TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。UDP 是一个面向无连接的传输层协议。</p><table><thead><tr><th align="center">对比</th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">是否连接</td><td align="center">连接</td><td align="center">无连接</td></tr><tr><td align="center">传输可靠</td><td align="center">可靠传输</td><td align="center">不可靠传输</td></tr><tr><td align="center">传输方式</td><td align="center">面向字节流</td><td align="center">面向报文</td></tr><tr><td align="center">首部开销</td><td align="center">开销大，20字节到60字节不等</td><td align="center">开销小，仅8字节</td></tr><tr><td align="center">适用场景</td><td align="center">要求可靠传输的应用，如文件传输</td><td align="center">适用实时应用，如直播、视频会议</td></tr><tr><td align="center">连接对象个数</td><td align="center">只支持一对一通信</td><td align="center">支持一对一、一对多、多对一、多对多通信</td></tr></tbody></table><ul><li>是否连接</li></ul><p>连接，指的是客户端和服务端的连接。<br>在双方互相通信之前，TCP 需要三次握手建立连接，UDP 没有建立连接的过程。</p><ul><li>传输可靠</li></ul><p>TCP 的可靠性体现在有状态和可控制的。TCP 会精准记录哪些数据被发送，哪些数据被对方接收，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错，这是有状态。当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发，这是可控制。</p><p>UDP 不可靠性首先体现在无连接上，通信都不需要建立连接；其次因为它是无状态和不可控的。UDP 收到什么数据就传递什么数据，并且也不会备份数据，发送数据时也不会关心对方是否已经正确接收到数据。</p><ul><li>传输方式</li></ul><p>TCP 为了维护状态，将一个个 IP 包变成了字节流。UDP 的数据传输是基于数据报的，继承了 IP 特性。</p><p>TCP 向上层提供面向连接的可靠服务，UDP 向上层提供无连接不可靠服务。虽然 UDP 没有 TCP 传输准确，但是也能在很多实时性要求高的地方有所作为。对数据准确性要求高、速度可以相对较慢，可选用 TCP。</p><h2 id="TCP-的三次握手和四次挥手"><a href="#TCP-的三次握手和四次挥手" class="headerlink" title="TCP 的三次握手和四次挥手"></a>TCP 的三次握手和四次挥手</h2><p>参考：<br><a href="https://juejin.cn/post/6939691851746279437">https://juejin.cn/post/6939691851746279437</a> 。<br><a href="https://juejin.cn/post/6844903625513238541">https://juejin.cn/post/6844903625513238541</a> 。<br><a href="https://yuanrengu.com/2020/77eef79f.html">https://yuanrengu.com/2020/77eef79f.html</a> 。</p><h3 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h3><ul><li>一开始客户端和服务端都处于 CLOSED 状态，然后服务端开始监听某个端口进入 LISTEN 状态</li><li>第一次握手：客户端向服务端发送报文：SYN = 1，seq = x，客户端变为 SYN-SENT 状态</li><li>第二次握手：服务端收到客户端报文后向客户端发送报文：SYN = 1，ACK = 1，seq = y，ack = x + 1，服务端变为 SYN-REVD 状态</li><li>第三次握手：客户端收到服务端报文后向服务端发送报文：ACK = 1，seq = x + 1，ack = y + 1，客户端变为 EASTABLISHED 状态，服务端收到报文变为 ESTABLISHED 状态，双方建立连接</li></ul><h3 id="四次挥手过程（客户端主动关闭）"><a href="#四次挥手过程（客户端主动关闭）" class="headerlink" title="四次挥手过程（客户端主动关闭）"></a>四次挥手过程（客户端主动关闭）</h3><ul><li>一开始客户端和服务端都处于 ESTABLISH 状态</li><li>第一次挥手：客户端向服务端发送报文：FIN = 1，seq = u，客户端变为 FIN_WAIT_1 状态</li><li>第二次挥手：服务端收到客户端报文后向客户端发送报文：ACK = 1，seq = v，ack= u + 1，服务端变为 CLOSED_WAIT 状态。客户端收到服务端的报文之后变为 FIN_WAIT_2 状态</li><li>第三次挥手：服务端向客户端发送报文：FIN = 1，ACK = 1，seq = w，ack= u + 1，服务端变为 LAST_ACK 状态</li><li>第四次挥手：客户端收到服务端报文后经过 2MSL 时间后变为 CLOSED 状态，期间向服务端发送报文：ACK = 1，seq = u + 1，ack= w + 1，客户端变为 TIME_WAIT 状态。服务端收到客户端报文变为 CLOSED 状态</li></ul><h3 id="为什么需要三次握手，两次不行吗"><a href="#为什么需要三次握手，两次不行吗" class="headerlink" title="为什么需要三次握手，两次不行吗"></a>为什么需要三次握手，两次不行吗</h3><ul><li>第一次握手：客户端发送网络包，服务端接收。<ul><li>客户端就能得出结论：客户端的发送能力正常。</li><li>服务端就能得出结论：客户端的发送能力、服务端的接收能力正常。</li></ul></li><li>第二次握手：服务端发送网络包，客户端接收。<ul><li>客户端就能得出结论：客户端的发送、接收能力正常，服务端的发送、接收能力正常。</li><li>服务端就能得出结论：客户端的发送能力、服务端的发送、接收能力正常。<br>（服务端并不能确认客户端的接收能力是否正常，所以两次握手不行）</li></ul></li><li>第三次握手：客户端发送网络包，服务端接收。<ul><li>客户端就能得出结论：客户端的发送、接收能力正常，服务端的发送、接收能力正常。</li><li>服务端就能得出结论：客户端的发送、接收能力正常，服务端的发送、接收能力正常。</li></ul></li></ul><h3 id="为什么需要四次挥手，三次不行吗"><a href="#为什么需要四次挥手，三次不行吗" class="headerlink" title="为什么需要四次挥手，三次不行吗"></a>为什么需要四次挥手，三次不行吗</h3><p>TCP 不允许连接处于半打开状态时就单向传输数据，所以在三次握手建立连接时，服务器会把 ACK 和 SYN 放在一起发给客户端，其中，ACK 用来打开客户端的发送通道，SYN 用来打开服务器的发送通道。这样原本的四次握手就成为三次握手。</p><p>但是当连接处于半关闭状态时，TCP 是允许单向传输数据的。我们把先关闭连接的一方叫做主动方，后关闭连接的一方叫做被动方。当主动方关闭连接时，被动方仍然可以在不调用 close 函数的状态下，长时间发送数据，此时连接处于半关闭状态。这一特性是 TCP 的双向通道互相独立所致，却这也使得关闭连接必须通过四次挥手才能做到。</p><h3 id="为什么需要等待-2MSL"><a href="#为什么需要等待-2MSL" class="headerlink" title="为什么需要等待 2MSL"></a>为什么需要等待 2MSL</h3><p>如果不等待，但是服务端还有很多数据包要给客户端发，且此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱，所以最保险方法是等服务器发来的数据包都被接收后再启动新应用。</p><p>1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端。<br>1个 MSL 保证对端没有收到 ACK 报文，那么对端进行重传的 FIN 报文能够到达。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>网络</tag>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写JavaScript</title>
    <link href="/2021/08/20/%E6%89%8B%E5%86%99JavaScript/"/>
    <url>/2021/08/20/%E6%89%8B%E5%86%99JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CreatePerson1</span>(<span class="hljs-params">name, age, job</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>  o.name = name;<br>  o.age = age;<br>  o.job = job;<br>  o.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> o;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = CreatePerson1(<span class="hljs-string">&quot;Nich&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Teacher&quot;</span>);<br><span class="hljs-keyword">let</span> person2 = CreatePerson1(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br>person1.sayName(); <span class="hljs-comment">// &quot;Nich&quot;</span><br>person2.sayName(); <span class="hljs-comment">// &quot;Greg&quot;</span><br></code></pre></td></tr></table></figure><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CreatePerson2</span>(<span class="hljs-params">name, age, job</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>  <span class="hljs-built_in">this</span>.job = job;<br>  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> CreatePerson2(<span class="hljs-string">&quot;Nich&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Teacher&quot;</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> CreatePerson2(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br>person1.sayName(); <span class="hljs-comment">// &quot;Nich&quot;</span><br>person2.sayName(); <span class="hljs-comment">// &quot;Greg&quot;</span><br></code></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CreatePerson3</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>CreatePerson3.prototype.name = <span class="hljs-string">&quot;Nich&quot;</span>;<br>CreatePerson3.prototype.age = <span class="hljs-number">25</span>;<br>CreatePerson3.prototype.job = <span class="hljs-string">&quot;Teacher&quot;</span>;<br>CreatePerson3.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> CreatePerson3();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> CreatePerson3();<br>person1.sayName(); <span class="hljs-comment">// &quot;Nich&quot;</span><br>person2.sayName(); <span class="hljs-comment">// &quot;Nich&quot;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>方式</th><th align="center">分析</th></tr></thead><tbody><tr><td>工厂模式</td><td align="center">可解决创建多个类似对象的问题，但没解决对象标识的问题（即新创建的对象是什么类型）</td></tr><tr><td>构造函数模式</td><td align="center">1.定义自定义构造函数可以确保其实例被标识为特定类型，相比工厂模式这是一个很大的好处。2.用构造函数定义的属性和方法会在每个实例上都创建一遍，创建时可以向构造函数传递参数，所有类型的数据都不会共享。3.正因为如此，主要问题在于创建实例时会重复创建相同的方法。</td></tr><tr><td>原型模式</td><td align="center">1.同一个构造函数创建的所有实例共享同一个原型对象上的属性和方法，在构造函数原型对象上定义的方法不用在每一个实例上重复创建。2.正因为如此，原型模式弱化了向构造函数传递参数的能力，会导致所有实例默认都取得相同的属性值。3.其主要问题在于创建实例时原型对象上的引用值属性会在所有实例间共享混用。</td></tr></tbody></table><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Nich&quot;</span>;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br>SuperType1.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.age = <span class="hljs-number">22</span>;<br>&#125;<br>SubType1.prototype = <span class="hljs-keyword">new</span> SuperType1();<br>SubType1.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance11 = <span class="hljs-keyword">new</span> SubType1();<br><span class="hljs-keyword">let</span> instance12 = <span class="hljs-keyword">new</span> SubType1();<br>instance11.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-built_in">console</span>.log(instance11.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br><span class="hljs-built_in">console</span>.log(instance12.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br>instance11.sayName(); <span class="hljs-comment">// &#x27;Nich&#x27;</span><br>instance11.sayAge(); <span class="hljs-comment">// 22</span><br>instance11.sayName === instance12.sayName; <span class="hljs-comment">// true</span><br>instance11.sayAge === instance12.sayAge; <span class="hljs-comment">// true</span><br>instance11 <span class="hljs-keyword">instanceof</span> SubType1; <span class="hljs-comment">// true</span><br>instance11 <span class="hljs-keyword">instanceof</span> SuperType1; <span class="hljs-comment">// true</span><br>instance11 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span><br>instance11 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType2</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>  &#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType2</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  SuperType2.call(<span class="hljs-built_in">this</span>, name);<br>  <span class="hljs-built_in">this</span>.age = <span class="hljs-number">22</span>;<br>  <span class="hljs-built_in">this</span>.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> instance21 = <span class="hljs-keyword">new</span> SubType2(<span class="hljs-string">&quot;Nich&quot;</span>);<br><span class="hljs-keyword">let</span> instance22 = <span class="hljs-keyword">new</span> SubType2(<span class="hljs-string">&quot;Greg&quot;</span>);<br>instance21.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-built_in">console</span>.log(instance21.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br><span class="hljs-built_in">console</span>.log(instance22.colors); <span class="hljs-comment">// [&quot;red, blue, green&quot;]</span><br>instance21.sayName(); <span class="hljs-comment">// &#x27;Nich&#x27;</span><br>instance21.sayAge(); <span class="hljs-comment">// 22</span><br>instance21.sayName === instance22.sayName; <span class="hljs-comment">// false</span><br>instance21.sayAge === instance22.sayAge; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType3</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br>SuperType3.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType3</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  SuperType3.call(<span class="hljs-built_in">this</span>, name);<br>  <span class="hljs-built_in">this</span>.age = <span class="hljs-number">22</span>;<br>&#125;<br>SubType3.prototype = <span class="hljs-keyword">new</span> SuperType3();<br>SubType3.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance31 = <span class="hljs-keyword">new</span> SubType3(<span class="hljs-string">&quot;Nich&quot;</span>);<br><span class="hljs-keyword">let</span> instance32 = <span class="hljs-keyword">new</span> SubType3(<span class="hljs-string">&quot;Greg&quot;</span>);<br>instance31.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-built_in">console</span>.log(instance31.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br><span class="hljs-built_in">console</span>.log(instance32.colors); <span class="hljs-comment">// [&quot;red, blue, green&quot;]</span><br>instance31.sayName(); <span class="hljs-comment">// &#x27;Nich&#x27;</span><br>instance31.sayAge(); <span class="hljs-comment">// 22</span><br>instance31.sayName === instance32.sayName; <span class="hljs-comment">// true</span><br>instance31.sayAge === instance32.sayAge; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = o;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();<br>&#125;<br><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nich&quot;</span>,<br>  <span class="hljs-attr">colors</span>: [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>],<br>  <span class="hljs-function"><span class="hljs-title">sayName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance41 = object(person);<br><span class="hljs-keyword">let</span> instance42 = object(person);<br>instance41.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-built_in">console</span>.log(instance41.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br><span class="hljs-built_in">console</span>.log(instance42.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br>instance41.sayName(); <span class="hljs-comment">// &#x27;Nich&#x27;</span><br>instance41.sayName === instance42.sayName; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>即等于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nich&quot;</span>,<br>  <span class="hljs-attr">colors</span>: [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>],<br>  <span class="hljs-function"><span class="hljs-title">sayName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance43 = <span class="hljs-built_in">Object</span>.create(person);<br><span class="hljs-keyword">let</span> instance44 = <span class="hljs-built_in">Object</span>.create(person);<br>instance43.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-built_in">console</span>.log(instance43.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br><span class="hljs-built_in">console</span>.log(instance44.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br>instance43.sayName(); <span class="hljs-comment">// &#x27;Nich&#x27;</span><br>instance43.sayName === instance44.sayName; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.create(original); <span class="hljs-comment">// 不一定必须使用 Object.create()</span><br>  clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hi&quot;</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nich&quot;</span>,<br>  <span class="hljs-attr">colors</span>: [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>],<br>  <span class="hljs-function"><span class="hljs-title">sayName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance51 = createAnother(person);<br><span class="hljs-keyword">let</span> instance52 = createAnother(person);<br>instance51.sayName === instance52.sayName; <span class="hljs-comment">// true</span><br>instance51.sayHi === instance52.sayHi; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType6</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br>SuperType6.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType6</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  SuperType6.call(<span class="hljs-built_in">this</span>, name);<br>  <span class="hljs-built_in">this</span>.age = <span class="hljs-number">22</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> prototype = <span class="hljs-built_in">Object</span>.create(superType.prototype); <span class="hljs-comment">// 创建对象</span><br>  prototype.constructor = subType; <span class="hljs-comment">// 增强对象</span><br>  subType.prototype = prototype; <span class="hljs-comment">// 赋值对象</span><br>&#125;<br>inheritPrototype(SubType6, SuperType6);<br><span class="hljs-comment">// 运行完 inheritPrototype(SubType6, SuperType6) 再添加需要的方法，否则无效</span><br>SubType6.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance61 = <span class="hljs-keyword">new</span> SubType6(<span class="hljs-string">&quot;Nich&quot;</span>);<br><span class="hljs-keyword">let</span> instance62 = <span class="hljs-keyword">new</span> SubType6(<span class="hljs-string">&quot;Greg&quot;</span>);<br>instance61.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-built_in">console</span>.log(instance61.colors); <span class="hljs-comment">// [&quot;red, blue, green, black&quot;]</span><br><span class="hljs-built_in">console</span>.log(instance62.colors); <span class="hljs-comment">// [&quot;red, blue, green&quot;]</span><br>instance61.sayName(); <span class="hljs-comment">// &#x27;Nich&#x27;</span><br>instance61.sayAge(); <span class="hljs-comment">// 22</span><br>instance61.sayName === instance62.sayName; <span class="hljs-comment">// true</span><br>instance61.sayAge === instance62.sayAge; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center">方式</th><th align="center">分析</th></tr></thead><tbody><tr><td align="center">原型链继承</td><td align="center">有着原型模式一样的优缺点。是 ECMAScript 的主要继承方式。构造函数的原型对象是另一个构造函数的实例，以此类推，就在实例和原型之间构造了一条原型链。</td></tr><tr><td align="center">借用构造函数继承</td><td align="center">有着构造函数模式一样的优缺点。创建子类构造函数实例时，都会在子类构造函数上运行父类构造函数中的所有初始化代码，结果是每一个子类构造函数的实例都有父类构造函数的属性，亮点是可以在子类构造函数中借用多个父类构造函数。</td></tr><tr><td align="center">组合继承</td><td align="center">使用最多的继承模式。综合了原型链继承和借用构造函数继承，将两者的优点集中起来：使用原型链继承原型对象上的方法，使用借用构造函数继承属性。既可以把方法定义在原型对象上以实现重用，又可以让每个实例都有自己的属性。缺点是父类构造函数会被调用两次。</td></tr><tr><td align="center">原型式继承</td><td align="center">有着原型模式一样的优缺点。对原型模式的封装，Object.create() 方法将该概念规范化。</td></tr><tr><td align="center">寄生式继承</td><td align="center">有着构造函数模式一样的优缺点。以某种方式增强对象，然后返回这个对象。</td></tr><tr><td align="center">寄生式组合继承</td><td align="center">引用类型继承的最佳模式。组合继承的改进版：不通过调用父类构造函数给子类构造函数原型对象赋值，而是取得父类构造函数原型对象的一个副本，赋值给子类构造函数原型对象，同时指定该副本的 constructor 属性为子类构造函数。这样父类构造函数不会被调用两次。</td></tr></tbody></table><h1 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h1><p>参考：<a href="https://juejin.cn/post/6946022649768181774">https://juejin.cn/post/6946022649768181774</a> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.call(thisArg, arg1, arg2, ...)<br><span class="hljs-built_in">Function</span>.prototype.apply(thisArg, [argsArray]])<br><span class="hljs-built_in">Function</span>.prototype.bind(thisArg[, arg1[, arg2[, ...]]])<br></code></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.call2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> context = context || <span class="hljs-built_in">window</span>;<br>  context.fn = <span class="hljs-built_in">this</span>;<br><br>  <span class="hljs-keyword">const</span> args = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>    args.push(<span class="hljs-string">&quot;arguments[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;context.fn(&quot;</span> + args + <span class="hljs-string">&quot;)&quot;</span>);<br><br>  <span class="hljs-keyword">delete</span> context.fn;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>使用一个指定的 this 值和单独给出的一个数组对象（或类数组对象）来调用一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.apply2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> context = context || <span class="hljs-built_in">window</span>;<br>  context.fn = <span class="hljs-built_in">this</span>;<br><br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">if</span> (!arr) result = context.fn();<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">const</span> args = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      args.push(<span class="hljs-string">&quot;arr[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;context.fn(&quot;</span> + args + <span class="hljs-string">&quot;)&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">delete</span> context.fn;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>使用一个指定的 this 值和单独给出的一个数组对象（或类数组对象）来调用一个函数。</p><p>创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.bind2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">let</span> fNOP = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  <span class="hljs-keyword">let</span> fBound = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> bindArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">return</span> self.apply(<br>      <span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> fNOP ? <span class="hljs-built_in">this</span> : context,<br>      args.concat(bindArgs)<br>    );<br>  &#125;;<br><br>  fNOP.prototype = <span class="hljs-built_in">this</span>.prototype;<br>  fBound.prototype = <span class="hljs-keyword">new</span> fNOP();<br>  <span class="hljs-keyword">return</span> fBound;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>参考：<a href="https://juejin.cn/post/6844903613584654344">https://juejin.cn/post/6844903613584654344</a> 。</p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>JS 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息:</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔值</li><li>1：整数</li><li>null：所有机器码均为 0</li><li>undefined：用 −2^30 整数来表示</li></ul><p>因此，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instanceOf</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left); <span class="hljs-comment">// 也可以：let proto = left.__proto__</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto); <span class="hljs-comment">// 也可以：proto = proto.__proto__</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript作用域与执行上下文</title>
    <link href="/2021/08/19/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <url>/2021/08/19/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png" alt="作用域和执行上下文"></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/3">https://github.com/mqyqingfeng/Blog/issues/3</a> 。</p><h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。JavaScript 采用词法作用域（lexical scoping），也就是静态作用域。</p><p>JavaScript 作用域有三种：全局作用域、函数作用域、块级作用域。</p><h2 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h2><p>因为 JavaScript 采用的是词法作用域，所以函数作用域在函数定义的时候就决定了，函数的作用域基于函数创建的位置。与词法作用域相对的是动态作用域，如果使用的是动态作用域，那么函数作用域就是在被函数调用的时候才被决定。</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/4">https://github.com/mqyqingfeng/Blog/issues/4</a> 。</p><h2 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，但 JavaScript 引擎遇到一段怎样的代码时才会做“准备工作”？</p><p>JavaScript 可执行代码（executable code）就三种：全局代码、函数代码、eval 代码。比如，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，就叫做执行上下文（execution context）。</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>如何管理创建的那么多执行上下文呢？JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p><p>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候，首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，且只有当整个应用程序结束的时候执行上下文栈才会被清空。所以程序结束之前，执行上下文栈最底部永远有 globalContext。</p><p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。</p><h1 id="执行上下文之变量对象"><a href="#执行上下文之变量对象" class="headerlink" title="执行上下文之变量对象"></a>执行上下文之变量对象</h1><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/5">https://github.com/mqyqingfeng/Blog/issues/5</a> 。  </p><p>当 JavaScript 代码执行一段可执行代码（executable code）时，都会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：变量对象（Variable object）、作用域链（Scope chain）、this。</p><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。不同执行上下文下的变量对象会稍有不同，所以我们来聊聊全局上下文的变量对象和函数上下文的变量对象。</p><h2 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h2><p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。</p><p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p><p>注意，不要混淆全局上下文和全局对象。全局上下文包括变量对象、作用域链、this，全局上下文的变量对象中包含全局对象。</p><p>全局上下文的变量对象初始化只包括全局对象。</p><h2 id="函数上下文的变量对象"><a href="#函数上下文的变量对象" class="headerlink" title="函数上下文的变量对象"></a>函数上下文的变量对象</h2><p>在函数上下文中，我们用活动对象（activation object）来表示变量对象。  </p><p>活动对象（AO）和变量对象（VO）其实是一个东西，只是变量对象是规范上的或说是引擎上实现的，不可在 JavaScript 环境中访问。只有到当进入函数执行上下文中，这个执行上下文的变量对象才会被激活，所以叫 activation object。被激活的变量对象就是活动对象，只有活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p><p>函数上下文的变量对象初始化只包括 Arguments 对象。</p><h2 id="执行上下文的执行过程"><a href="#执行上下文的执行过程" class="headerlink" title="执行上下文的执行过程"></a>执行上下文的执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析（进入执行上下文）和执行（代码执行）。</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>全局上下文当进入执行上下文时，这时候还没有执行代码，变量对象会包括两方面。</p><ul><li>函数声明<ul><li>由名称和对应值（函数对象）组成一个变量对象的属性被创建</li><li>如果变量对象当中已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>使用<code>var</code>声明的变量：由名称和 undefined 值组成一个变量对象的属性被创建<br>（无论声明时是否已经初始化变量，此时值都为 undefined，等执行时再修改值）<br>（使用<code>let</code>和<code>const</code>声明的变量都属于未声明的变量，等执行时再添加到变量对象）</li><li>如果变量名称跟已经声明的函数相同，则变量声明不会干扰已经存在的属性</li><li>如果变量名称跟已经声明的变量相同，则变量声明将会覆盖已经存在的属性</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// ƒ a() &#123;</span><br>                <span class="hljs-comment">//   console.log(&#x27;a&#x27;);</span><br>                <span class="hljs-comment">// &#125;</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// Uncaught ReferenceError: b is not defined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// ƒ a() &#123;</span><br>                <span class="hljs-comment">//   console.log(&#x27;a&#x27;);</span><br>                <span class="hljs-comment">// &#125;</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// undefined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>函数上下文当进入执行上下文时，这时候还没有执行代码，变量对象会包括三方面。</p><ul><li>函数的所有形参<ul><li>由名称和对应值组成的一个变量对象的属性被创建<br>（有实参，属性值为对应值；没有实参，属性值为 undefined）</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象）组成一个变量对象的属性被创建</li><li>如果变量对象当中已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>使用<code>var</code>声明的变量：由名称和 undefined 值组成一个变量对象的属性被创建<br>（无论声明时是否已经初始化变量，此时值都为 undefined，等执行时再修改值）<br>（使用<code>let</code>和<code>const</code>声明的变量都处于暂时性死区，等执行时再添加到变量对象）</li><li>如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的属性</li><li>如果变量名称跟已经声明的变量相同，则变量声明将会覆盖已经存在的属性</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);           <br>  <span class="hljs-built_in">console</span>.log(b);<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;<br>&#125;<br>foo(); <br><span class="hljs-comment">// ƒ a() &#123;</span><br><span class="hljs-comment">//   console.log(&#x27;a&#x27;);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initialization</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);           <br>  <span class="hljs-built_in">console</span>.log(b);<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br>&#125;<br>foo();<br><span class="hljs-comment">// ƒ a() &#123;</span><br><span class="hljs-comment">//   console.log(&#x27;a&#x27;);</span><br><span class="hljs-comment">// &#125; </span><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，JavaScript 引擎会按顺序执行代码，根据代码，修改变量对象的值。</p><p>要特别注意的是，<code>var</code>、<code>let</code>、<code>const</code>三者声明的效果不同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>全局上下文的变量对象初始化只包括全局对象。</li><li>函数上下文的变量对象初始化只包括 Arguments 对象。</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值。</li><li>在代码执行阶段，会再次修改变量对象的属性值。</li></ul><p>需要特别注意的是，ES6 添加了 let 和 const 声明。使用 var 声明的变量会成为全局对象的属性，但是使用 let 和 const 声明的变量不会成为全局对象的属性，而是会成为的变量对象的属性，与全局对象“平级”。</p><p>因此，ES6 之前，全局上下文的变量对象就是全局对象；ES6 之后，全局上下文的变量对象包含全局对象和使用 let 和 const 声明的变量和对象。要特别注意的是，<code>var</code>、<code>let</code>、<code>const</code>三者声明的效果不同。</p><h1 id="执行上下文之作用域链"><a href="#执行上下文之作用域链" class="headerlink" title="执行上下文之作用域链"></a>执行上下文之作用域链</h1><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/6">https://github.com/mqyqingfeng/Blog/issues/6</a> 。</p><p>当 JavaScript 代码执行一段可执行代码（executable code）时，都会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：变量对象（Variable object）、作用域链（Scope chain）、this。</p><p>当查找变量的时候，会先从当前上下文的变量对象中查找，若没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>函数作用域在函数定义的时候就决定了。</p><p>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，它就会保存所有父变量对象到其中，可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链。</p><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建变量对象/活动对象后，就会将活动对象添加到作用链的前端。此时，执行上下文的作用域链，我们命名为 Scope：<code>Scope = [AO].concat([[Scope]])</code>。至此作用域链创建完毕。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>以下面的例子为例，来总结一下函数执行上下文中作用域链和变量对象的创建过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> scope2 = <span class="hljs-string">&#x27;local scope&#x27;</span>;<br>  <span class="hljs-keyword">return</span> scope2;<br>&#125;<br>checkscope();<br></code></pre></td></tr></table></figure><ol><li>checkscope 函数被创建，保存作用域链到内部属性 [[scope]]。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">checkscope.[[scope]] = [ globalContext.VO ];<br></code></pre></td></tr></table></figure></li><li>创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ECStack = [ globalContext, checkscopeContext ];<br></code></pre></td></tr></table></figure></li><li>不立刻执行 checkscope 函数，开始做准备工作。</li></ol><ul><li>第一步：复制函数 [[scope]] 属性创建作用域链。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">checkscopeContext = &#123; <br>  <span class="hljs-attr">Scope</span>: checkscope.[[scope]] <br>&#125;<br></code></pre></td></tr></table></figure></li><li>第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">checkscopeContext = &#123;<br>  <span class="hljs-attr">AO</span>: &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>      <span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>    &#125;,<br>    <span class="hljs-attr">scope2</span>: <span class="hljs-literal">undefined</span><br>  &#125;，<br>  <span class="hljs-attr">Scope</span>: checkscope.[[scope]],<br>&#125;<br></code></pre></td></tr></table></figure></li><li>第三步：将活动对象压入 checkscope 作用域链顶端。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">checkscopeContext = &#123;<br>  <span class="hljs-attr">AO</span>: &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>      <span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>    &#125;,<br>    <span class="hljs-attr">scope2</span>: <span class="hljs-literal">undefined</span><br>  &#125;,<br>  <span class="hljs-attr">Scope</span>: [AO, [[Scope]]]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>准备工作做完，开始执行函数，随着函数的执行，修改活动对象的属性值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">checkscopeContext = &#123;<br>  <span class="hljs-attr">AO</span>: &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>      <span class="hljs-attr">length</span>: <span class="hljs-number">0</span><br>    &#125;,<br>    <span class="hljs-attr">scope2</span>: <span class="hljs-string">&#x27;local scope&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">Scope</span>: [AO, [[Scope]]]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>函数执行完毕后，函数上下文从执行上下文栈中弹出。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ECStack = [ globalContext ];<br></code></pre></td></tr></table></figure></li></ol><h1 id="执行上下文之this"><a href="#执行上下文之this" class="headerlink" title="执行上下文之this"></a>执行上下文之this</h1><p>参考：<a href="https://juejin.cn/post/6844903488304971789">https://juejin.cn/post/6844903488304971789</a> 。</p><p>当 JavaScript 代码执行一段可执行代码（executable code）时，都会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：变量对象（Variable object）、作用域链（Scope chain）、this。</p><p>this 只在函数调用阶段确定，也就是执行上下文创建的阶段进行赋值，然后保存下来。这个特性导致了 this 的多变性：当函数在不同的调用方式下都可能会导致 this 的值不同。标准函数和箭头函数也有所不同。</p><h2 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h2><p>在标准函数中，this 引用的是把标准函数当成方法调用的对象。可分为 4 种情况。</p><h3 id="直接被调用"><a href="#直接被调用" class="headerlink" title="直接被调用"></a>直接被调用</h3><p>当独立调用函数的时候，严格模式下 this 会指向 undefined，非严格模式自动转为指向全局对象。</p><p>不管是全局函数被直接调用还是父函数里的子函数被父函数直接调用，都指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a) <br>    &#125;,<br>  <span class="hljs-attr">c</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a &#125;<br>      <span class="hljs-built_in">console</span>.log(fun());<br>    &#125;<br>&#125;;<br>obj.b(); <span class="hljs-comment">// 2</span><br>obj.c(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a) &#125;<br>  fun();<br>&#125;<br>b(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="作为对象的方法被调用"><a href="#作为对象的方法被调用" class="headerlink" title="作为对象的方法被调用"></a>作为对象的方法被调用</h3><p>当函数作为对象的方法被调用时，这时 this 指向调用它的对象。</p><p>当对象在全局代码中声明的时候，对象内部属性中的 this 指向全局对象；<br>当对象在一个函数中声明的时候，严格模式下 this 会指向 undefined，非严格模式自动转为指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-built_in">this</span>.a + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-built_in">this</span>.a + <span class="hljs-number">2</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> obj.c;<br>&#125;<br><span class="hljs-built_in">console</span>.log(fun()); <span class="hljs-comment">// 1002</span><br><span class="hljs-built_in">console</span>.log(obj.b); <span class="hljs-comment">// 1001</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a) &#125;<br>&#125;;<br>obj.b() <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">var</span> t = obj.b;<br>t(); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// obj 对象的 b 属性存储的是对该匿名函数的一个引用，可以理解为一个指针。</span><br><span class="hljs-comment">// 当赋值给 t 时并没有单独开辟内存空间存储新的函数，而是让 t 存储一个指针，该指针指向这个函数。</span><br><span class="hljs-comment">// 相当于执行了这么一段伪代码：</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a &#125; <span class="hljs-comment">// 此函数存储在堆中</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">b</span>: fun <span class="hljs-comment">// b 指向 fun 函数</span><br>&#125;<br><span class="hljs-keyword">var</span> t = fun; <span class="hljs-comment">// 此时的 t 就是一个指向 fun 函数的指针，调用 t，相当于直接调用 fun</span><br><span class="hljs-built_in">console</span>.log(t()); <span class="hljs-comment">// 1 </span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)<br>&#125;<br>obj1 = &#123;<br>  <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>  <span class="hljs-attr">fun</span>: obj2<br>&#125;<br>obj2 = &#123;<br>  <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>,<br>  <span class="hljs-attr">fun</span>:fun<br>&#125;<br>obj1.fun.fun(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="使用-call-或-apply-被调用"><a href="#使用-call-或-apply-被调用" class="headerlink" title="使用 call 或 apply 被调用"></a>使用 call 或 apply 被调用</h3><p>当函数使用 call 或 apply 被调用时，由其传入的参数作为 this 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">7</span>;<br>&#125;<br><span class="hljs-keyword">let</span> c = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">9</span><br>&#125;<br>fun.call(b); <span class="hljs-comment">// undefined</span><br>fun.call(c); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h3 id="作为构造函数被调用"><a href="#作为构造函数被调用" class="headerlink" title="作为构造函数被调用"></a>作为构造函数被调用</h3><p>当函数作为构造函数被调用时，那么其中的 this 就代表它即将 new 出来的对象。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，箭头函数 this 由其所在上下文的 this 所决定。</p><p>对箭头函数使用 apply 或 call 方法只是传入参数，改变不了 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">var</span> fun = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>fun(); <span class="hljs-comment">// 1</span><br>fun.call(obj); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">let</span> f = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>  f();<br>&#125;<br>fun(); <span class="hljs-comment">// 1</span><br>fun.call(obj); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a) &#125;<br>  f();<br>&#125;;<br>fun(); <span class="hljs-comment">// 1</span><br>fun.call(obj); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>函数的<code>color</code>与 <strong>其所在的上下文的作用域链</strong> 有关</li><li>箭头函数的<code>this.color</code>与 <strong>其所在的上下文的this</strong> 有关</li><li>标准函数的<code>this.color</code>与 <strong>把其当成方法调用的对象</strong> 有关</li></ul><p>注意，全局上下文的变量对象包含着全局对象和使用 let 和 const 声明的变量和对象。</p><p>练习：</p><ul><li>1.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// var 声明的变量会成为全局变量的属性</span><br><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>  <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(color); <span class="hljs-comment">// o 只是全局上下文的一个变量，不是块级作用域</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// 函数作为对象的方法被调用，this 指向调用它的对象</span><br>  &#125;,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(color); <span class="hljs-comment">// o 只是全局上下文的一个变量，不是块级作用域</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// 此箭头函数被定义在全局上下文</span><br>  &#125;<br>&#125;;<br>o.a(); <span class="hljs-comment">// red // blue</span><br>o.b(); <span class="hljs-comment">// red // red</span><br></code></pre></td></tr></table></figure></li><li>2.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// let 声明不会成为全局变量的属性</span><br><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>  <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(color); <span class="hljs-comment">// o 只是全局上下文的一个变量，不是块级作用域</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// 函数作为对象的方法被调用，this 指向调用它的对象</span><br>  &#125;,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(color); <span class="hljs-comment">// o 只是全局上下文的一个变量，不是块级作用域</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// 全局变量没有 color 属性</span><br>  &#125;<br>&#125;;<br>o.a(); <span class="hljs-comment">// red // blue</span><br>o.b(); <span class="hljs-comment">// red // undefined</span><br></code></pre></td></tr></table></figure></li><li>3.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// var 声明的变量会成为全局变量的属性</span><br>&#123;<br>  <span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;blue&#x27;</span>; <span class="hljs-comment">// let 声明不会成为全局变量的属性</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(color);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color);<br>  &#125;;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(color);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color);<br>  &#125;;<br>  a(); <span class="hljs-comment">// blue // red</span><br>  b(); <span class="hljs-comment">// blue // red</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>4.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// var 声明的变量会成为全局变量的属性</span><br>&#123;<br>  <span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;blue&#x27;</span>; <span class="hljs-comment">// var 声明的变量会成为全局变量的属性，会覆盖</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(color);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color);<br>  &#125;;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(color);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color);<br>  &#125;;<br>  a(); <span class="hljs-comment">// blue // blue</span><br>  b(); <span class="hljs-comment">// blue // blue</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>5.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// var 声明的变量会成为全局变量的属性</span><br>&#123;<br>  <span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;blue&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(color);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color);<br>  &#125;;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(color);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color);<br>  &#125;;<br>  a(); <span class="hljs-comment">// black // red</span><br>  b(); <span class="hljs-comment">// black // red</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>6.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// let 声明不会成为全局变量的属性</span><br>&#123;<br>  <span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;blue&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(color);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// 全局变量没有 color 属性</span><br>  &#125;;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(color);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color);<br>  &#125;;<br>  a(); <span class="hljs-comment">// black // undefined</span><br>  b(); <span class="hljs-comment">// black // undefined</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>7.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// var 声明的变量会成为全局变量的属性</span><br><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(color); <span class="hljs-comment">// o 只是全局上下文的一个变量，不是块级作用域</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color); <span class="hljs-comment">// 函数作为对象的方法被调用，this 指向调用它的对象</span><br>&#125;<br><span class="hljs-keyword">const</span> b = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(color); <span class="hljs-comment">// o 只是全局上下文的一个变量，不是块级作用域</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.color);<br>&#125;<br>o.a = a;<br>o.b = b;<br>a(); <span class="hljs-comment">// red // red</span><br>b(); <span class="hljs-comment">// red // red</span><br>o.a(); <span class="hljs-comment">// red // blue</span><br>o.b(); <span class="hljs-comment">// red // red</span><br></code></pre></td></tr></table></figure></li><li>8.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123; <br>  <span class="hljs-built_in">this</span>.royaltyName = <span class="hljs-string">&#x27;Henry&#x27;</span>; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.royaltyName)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123; <br>  <span class="hljs-built_in">this</span>.royaltyName = <span class="hljs-string">&#x27;Elizabeth&#x27;</span>; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.royaltyName)<br>&#125;<br>a(); <span class="hljs-comment">// Henry </span><br><span class="hljs-built_in">console</span>.log(royaltyName); <span class="hljs-comment">// Henry </span><br>b(); <span class="hljs-comment">// Elizabeth</span><br><span class="hljs-built_in">console</span>.log(royaltyName); <span class="hljs-comment">// Elizabeth</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/9">https://github.com/mqyqingfeng/Blog/issues/9</a> 。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。</p><p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。</p><p>所以，可以得出：闭包 = 函数 + 函数能够访问的自由变量。</p><h3 id="理论角度"><a href="#理论角度" class="headerlink" title="理论角度"></a>理论角度</h3><p>所有的 JavaScript 函数都是闭包。因为在创建函数的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p><h3 id="实践角度"><a href="#实践角度" class="headerlink" title="实践角度"></a>实践角度</h3><p>从实践角度，符合以下条件的函数才算是闭包：</p><ul><li>创建闭包的函数已经被销毁，但闭包仍然存在（比如，内部函数从父函数中返回）</li><li>闭包的代码中引用了自由变量</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>闭包及其变量长期在内存中，可长时间访问。</li><li>创建闭包的函数的变量可被外部访问。</li><li>私有化变量，避免污染全局变量。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>内存消耗很大，不能滥用闭包，否则会造成网页性能问题。</li><li>容易造成内存泄漏。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> count = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> ++num;<br>  &#125;<br>  aaa.renew = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; num = <span class="hljs-number">0</span>; &#125;<br>  <span class="hljs-keyword">return</span> aaa;<br>&#125;)()<br>count(); <span class="hljs-comment">// 1</span><br>count(); <span class="hljs-comment">// 2</span><br>count(); <span class="hljs-comment">// 3</span><br>count.renew();<br>count(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试题</title>
    <link href="/2021/08/18/CSS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/08/18/CSS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h1><p>参考：</p><ul><li><a href="https://juejin.cn/post/6964644611822190622">https://juejin.cn/post/6964644611822190622</a> 。</li><li><a href="https://juejin.cn/post/6953854318580203533">https://juejin.cn/post/6953854318580203533</a> 。</li></ul><table><thead><tr><th align="center">diaplay</th><th align="center">特点</th><th align="center">宽度、高度</th><th align="center">内边距、外边距</th></tr></thead><tbody><tr><td align="center">block</td><td align="center">块级元素，元素的前和后换行</td><td align="center">有效</td><td align="center">都有效</td></tr><tr><td align="center">inline</td><td align="center">行内元素，元素的前和后不换行</td><td align="center">无效</td><td align="center">水平方向有效，竖直方向无效</td></tr><tr><td align="center">inline-block</td><td align="center">行内块级元素，元素的前和后不换行</td><td align="center">有效</td><td align="center">都有效</td></tr></tbody></table><ul><li><strong>块级元素</strong>的元素之前和之后换行；<strong>行内元素</strong>和<strong>行内块级元素</strong>的元素之前和之后不换行。</li><li><strong>块级元素</strong>和<strong>行内块级元素</strong>可以包含块级元素、行内元素、行内块级元素；<strong>行内元素</strong>只能包含行内元素。</li><li><strong>块级元素</strong>和<strong>行内块级元素</strong>设置内边距、外边距都有效；<strong>行内元素</strong>设置内边距、外边距时水平方向有效、竖直方向无效。</li><li><strong>块级元素</strong>设置宽度、高度有效，但块级元素设置了宽度后仍会独占一行（宽度会变，但仍然会换行）；<strong>行内元素</strong>设置宽度、高度无效，<strong>行内块级元素</strong>设置宽度、高度有效。</li></ul><p>常见的块级元素：<code>&lt;div&gt;</code> <code>&lt;p&gt;</code> <code>&lt;h1&gt;</code> <code>&lt;h6&gt;</code> <code>&lt;ul&gt;</code> <code>&lt;ol&gt;</code> <code>&lt;li&gt;</code> <code>&lt;form&gt;</code> <code>&lt;header&gt;</code> <code>&lt;canvas&gt;</code> <code>&lt;dd&gt;</code> <code>&lt;dl&gt;</code> <code>&lt;audio&gt;</code> <code>&lt;video&gt;</code> <code>&lt;section&gt;</code> <code>&lt;hr&gt;</code> <code>&lt;br&gt;</code> <code>&lt;address&gt;</code> <code>&lt;article&gt;</code> <code>&lt;aside&gt;</code> <code>&lt;fieldset&gt;</code></p><p>常见的行内元素：<code>&lt;span&gt;</code> <code>&lt;a&gt;</code> <code>&lt;lable&gt;</code> <code>&lt;strong&gt;</code> <code>&lt;b&gt;</code> <code>&lt;small&gt;</code> <code>&lt;abbr&gt;</code> <code>&lt;button&gt;</code> <code>&lt;input&gt;</code> <code>&lt;textarea&gt;</code> <code>&lt;select&gt;</code> <code>&lt;code&gt;</code> <code>&lt;img&gt;</code> <code>&lt;br&gt;</code> <code>&lt;q&gt;</code> <code>&lt;i&gt;</code> <code>&lt;cite&gt;</code> <code>&lt;var&gt;</code> <code>&lt;kbd&gt;</code> <code>&lt;sub&gt;</code> <code>&lt;bdo&gt;</code></p><h1 id="行内块元素间的间隙问题"><a href="#行内块元素间的间隙问题" class="headerlink" title="行内块元素间的间隙问题"></a>行内块元素间的间隙问题</h1><p>参考：<a href="https://juejin.cn/post/6844904056121458695">https://juejin.cn/post/6844904056121458695</a> 。</p><p><code>display:inline-block</code>是种布局方法，它相比于与浮动、定位最大的不同就是没有父元素的匿名包裹特性，这使得<code>display:inline-block</code>属性的使用非常自由，可与文字、图片混排，还可内嵌<code>display:block</code>元素，又可置于<code>display:inline</code>水平的元素中。</p><p>在 CSS 布局中，如果我们想要将一些元素在同一行显示，其中的一种方法就是对要所有同行显示的元素设置<code>display:inline-block</code>。但会发现这些<code>display:inline-block</code>同行元素之间经常会出现一定的空隙，这就是“换行符/空格间隙问题”。</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>元素被当成行内块元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据<code>white-space</code>属性来处理：原来 HTML 代码中的回车换行被转成一个空白符，在字体不为 0 情况下，空白符占据一定宽度，所以<code>display:inline-block</code>元素之间就出现了空隙。</p><p>这些元素之间的间距会随着字体的大小而变化，当行内元素<code>font-size:16px</code>时，间距为 8px。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>设置父元素<code>font-size:0</code>，设置子元素对应<code>font-size</code></li><li>设置父元素<code>display:table; word-spacing:-1em</code></li><li>设置子元素<code>float:left</code></li></ul><h1 id="文本长度"><a href="#文本长度" class="headerlink" title="文本长度"></a>文本长度</h1><h2 id="超出宽度需要打点打点"><a href="#超出宽度需要打点打点" class="headerlink" title="超出宽度需要打点打点"></a>超出宽度需要打点打点</h2><ol><li>文字超过部分显示为省略号。用到属性：</li></ol><ul><li><a href="https://www.runoob.com/cssref/css3-pr-text-overflow.html">text-overflow</a></li><li><a href="https://www.runoob.com/cssref/pr-text-white-space.html">white-space</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.p</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">      <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">      <span class="hljs-attribute">text-overflow</span>: ellipsis;</span><br><span class="css">      <span class="hljs-attribute">white-space</span>: nowrap;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span><br>    我是一行自动换的文本123我是一行自动换的文本123我是一行自动换的文本123我是一行自动换的文本<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>文本超出两行，超出部分省略号显示。用到属性：</li></ol><ul><li><a href="https://www.runoob.com/cssref/css3-pr-word-break.html">word-break</a></li><li><a href="https://www.runoob.com/cssref/pr-text-white-space.html">white-space</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.p</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">      <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">      <span class="hljs-attribute">text-overflow</span>: ellipsis; <span class="hljs-comment">/* ? */</span></span><br><span class="css">      <span class="hljs-attribute">word-break</span>: break-all;  <span class="hljs-comment">/* ? */</span></span><br><span class="css">      <span class="hljs-attribute">display</span>: -webkit-box;</span><br><span class="css">      -webkit-box-orient: vertical;</span><br><span class="css">      -webkit-line-clamp: <span class="hljs-number">2</span>; <span class="hljs-comment">/* 这里是超出几行省略 */</span></span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span><br>    我是两行自动换的文本123我是两行自动换的文本123我是两行自动换的文本123我是两行自动换的文本<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用到相关属性： <a href="https://www.runoob.com/cssref/css3-pr-text-overflow.html">white-space</a></p><h2 id="长度够还打点"><a href="#长度够还打点" class="headerlink" title="长度够还打点"></a>长度够还打点</h2><p>可能是因为设置了max-width</p><h1 id="画图形"><a href="#画图形" class="headerlink" title="画图形"></a>画图形</h1><p>原理是利用元素的长度、宽度、、边框、背景颜色及其伪元素来实现。<br>如画一个对勾：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.checkbox</span><span class="hljs-selector-class">.checked</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2fd2fe</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">position</span>: relative;<br> &#125;<br><br><span class="hljs-selector-class">.checkbox</span><span class="hljs-selector-class">.checked</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>  <span class="hljs-attribute">border-right</span>: none;<br>  <span class="hljs-attribute">border-top</span>: none;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(-<span class="hljs-number">60deg</span>) <span class="hljs-built_in">translate</span>(<span class="hljs-number">7px</span>, -<span class="hljs-number">10px</span>);<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">8.5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h1><p>相关伪元素：</p><ul><li>div::-webkit-scrollbar 滚动条整体部分</li><li>div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条</li><li>div::-webkit-scrollbar-track 滚动条的轨道（里面装有 Thumb</li><li>div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置</li><li>div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去</li><li>div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</li><li>div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件。注意此方案有兼容性问题，一般需要隐藏滚动条时可以用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用 overflow-hidden 截掉滚动条部分。暴力且直接。</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> scrollBar &#123;<br>  &amp;::-webkit-scrollbar &#123;<br>    width: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;<br><br>    &amp;-track &#123;<br>      <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$Ra-5</span>;<br>      <span class="hljs-attribute">background-color</span>: transparent;<br>    &#125;<br><br>    &amp;-thumb &#123;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid transparent;<br>      <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$Ra-5</span>;<br>      <span class="hljs-attribute">background-color</span>: rgba(<span class="hljs-variable">$M10</span>, <span class="hljs-number">0.1</span>);<br>      <span class="hljs-attribute">background-clip</span>: content-box;<br><br>      &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: rgba(<span class="hljs-variable">$M1</span>, <span class="hljs-number">0.3</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h1><p>参考：<a href="https://juejin.cn/post/6844904200401502215">https://juejin.cn/post/6844904200401502215</a> 。</p><h2 id="display-none"><a href="#display-none" class="headerlink" title="display: none"></a>display: none</h2><ul><li>Render Tree：浏览器不会渲染元素，不占据空间</li><li>性能：动态改变此属性时会引起回流，性能较差</li><li>事件监听：无法进行 DOM 事件监听</li><li>继承：不会被子元素继承，子元素也不会被渲染</li><li>transition：transition 不支持 display</li></ul><h2 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility: hidden"></a>visibility: hidden</h2><ul><li>Render Tree：浏览器会渲染元素，元素被隐藏，会占据空间</li><li>性能：动态改变此属性时会引起重绘，性能一般</li><li>事件监听：无法进行 DOM 事件监听</li><li>继承：会被子元素继承，但可以设置子元素<code>visibility: visible</code>来取消隐藏子元素</li><li>transition：visibility 会立即显示，延时隐藏</li></ul><h2 id="opacity-0"><a href="#opacity-0" class="headerlink" title="opacity: 0"></a>opacity: 0</h2><ul><li>Render Tree：浏览器会渲染元素，元素未被隐藏，全透明，会占据空间</li><li>性能：提升为合成层，不会触发重绘，性能较高</li><li>事件监听：可以进行 DOM 事件监听</li><li>继承：会被子元素继承，且不能设置子元素 opacity: 1 来取消隐藏子元素</li><li>transition：opacity 延时显示和隐藏</li></ul><h1 id="两栏布局和三栏布局"><a href="#两栏布局和三栏布局" class="headerlink" title="两栏布局和三栏布局"></a>两栏布局和三栏布局</h1><p>Demo：</p><ul><li><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%A4%E6%A0%8F1-1.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/两栏1-1.html</a> 。</li><li><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%A4%E6%A0%8F1-2.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/两栏1-2.html</a> 。</li><li><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%89%E6%A0%8F1-1.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/三栏1-1.html</a> 。</li><li><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%89%E6%A0%8F1-2.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/三栏1-2.html</a> 。</li></ul><p>两栏：一栏固定，一栏自适应；三栏：左右固定，中间自适应。方式有：</p><ul><li>浮动</li><li>定位</li><li>表格布局</li><li>弹性布局</li><li>网格布局</li></ul><h1 id="圣杯布局和双飞翼布局"><a href="#圣杯布局和双飞翼布局" class="headerlink" title="圣杯布局和双飞翼布局"></a>圣杯布局和双飞翼布局</h1><p>参考：<a href="https://juejin.cn/post/6844903565278855181">https://juejin.cn/post/6844903565278855181</a> 。<br>Demo：</p><ul><li><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%89%E6%A0%8F_%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/三栏_圣杯布局.html</a> 。</li><li><a href="https://github.com/xuekeven/learn_web/blob/main/dome/CSS/%E4%B8%89%E6%A0%8F_%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html">https://github.com/xuekeven/learn_web/blob/main/dome/CSS/三栏_双飞翼布局.html</a> 。</li></ul><h2 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h2><ul><li>都是对三栏使用浮动，然后对左右两栏使用负外边距</li><li>都是把中间栏放在文档流最前面，让中间栏优先加载，并且中间栏占据宽度 100%</li><li>都是左右两栏自适应高度固定宽度，中间栏自适应宽度高度，两者的效果基本相同</li><li>圣杯布局是利用三栏父元素的左右内边距和左右两栏的相对定位（中间栏为两边腾开位置）</li><li>双飞翼布局是给中间栏添加内容层，利用该内容层的左右外边距（中间栏的内容层为两边腾开位置）</li></ul><h2 id="圣杯布局缺点"><a href="#圣杯布局缺点" class="headerlink" title="圣杯布局缺点"></a>圣杯布局缺点</h2><ul><li>最好给 body 设置最小宽度，否则可能会错乱</li><li>任何一栏的高度拉长，其它两栏不会自动填充</li></ul><h2 id="双飞翼布局缺点"><a href="#双飞翼布局缺点" class="headerlink" title="双飞翼布局缺点"></a>双飞翼布局缺点</h2><ul><li>增加一层节点，增加渲染树生成的计算量</li></ul><h1 id="元素同行显示"><a href="#元素同行显示" class="headerlink" title="元素同行显示"></a>元素同行显示</h1><ul><li>设置元素为行内元素或行内块元素</li><li>设置父元素为 flex 布局或 grid 布局</li><li>设置浮动</li></ul><h1 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h1><ul><li>盒模型</li><li>选择器</li><li>定位</li><li>BFC &amp; IFC</li><li>外边距</li><li>清除浮动</li><li>水平垂直居中</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML和CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用方法</title>
    <link href="/2021/08/07/Git%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/08/07/Git%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="OpenSSL SSL_read: Connection was reset, errno 10054"></a>OpenSSL SSL_read: Connection was reset, errno 10054</h1><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">http</span>.sslVerify <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><h1 id="git-更新本地代码方法"><a href="#git-更新本地代码方法" class="headerlink" title="git 更新本地代码方法"></a>git 更新本地代码方法</h1><p><a href="https://www.cnblogs.com/delav/p/11118555.html">https://www.cnblogs.com/delav/p/11118555.html</a></p><h1 id="git-连接远程仓库方法"><a href="#git-连接远程仓库方法" class="headerlink" title="git 连接远程仓库方法"></a>git 连接远程仓库方法</h1><h2 id="一、本地已创建仓库-然后与远程仓库关联"><a href="#一、本地已创建仓库-然后与远程仓库关联" class="headerlink" title="一、本地已创建仓库, 然后与远程仓库关联"></a>一、本地已创建仓库, 然后与远程仓库关联</h2><h3 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h3><p>  <code>git init</code></p><h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><p>  <code>git add .</code></p><h3 id="提交改变到缓存"><a href="#提交改变到缓存" class="headerlink" title="提交改变到缓存"></a>提交改变到缓存</h3><p>  <code>git commit -m &#39;description&#39;</code></p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>  <code>git branch -M main</code></p><h3 id="本地git仓库关联GitHub仓库"><a href="#本地git仓库关联GitHub仓库" class="headerlink" title="本地git仓库关联GitHub仓库"></a>本地git仓库关联GitHub仓库</h3><p>  <code>git remote add origin xxx</code></p><h3 id="提交到远程仓库"><a href="#提交到远程仓库" class="headerlink" title="提交到远程仓库"></a>提交到远程仓库</h3><p>  <code>git push -u origin main</code></p><h2 id="二、不用关联远程仓库-直接从远程仓库克隆到本地"><a href="#二、不用关联远程仓库-直接从远程仓库克隆到本地" class="headerlink" title="二、不用关联远程仓库, 直接从远程仓库克隆到本地"></a>二、不用关联远程仓库, 直接从远程仓库克隆到本地</h2><h3 id="从GitHub上克隆项目到本地"><a href="#从GitHub上克隆项目到本地" class="headerlink" title="从GitHub上克隆项目到本地"></a>从GitHub上克隆项目到本地</h3><p>  <code>git clone xxx</code>  </p><h3 id="添加文件到暂存区-1"><a href="#添加文件到暂存区-1" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><p>  <code>git add .</code></p><h3 id="提交改变到缓存-1"><a href="#提交改变到缓存-1" class="headerlink" title="提交改变到缓存"></a>提交改变到缓存</h3><p>  <code>git commit -m &#39;description&#39;</code></p><h3 id="提交到远程仓库-1"><a href="#提交到远程仓库-1" class="headerlink" title="提交到远程仓库"></a>提交到远程仓库</h3><p>  <code>git push -u origin main</code></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基本使用</title>
    <link href="/2021/08/07/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/08/07/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://www.runoob.com/git/git-tutorial.html">Git 教程 | 菜鸟教程</a> 。<br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单 - 阮一峰的网络日志</a> 。<br><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程 - 阮一峰的网络日志</a> 。</p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p>工作区 =&gt; 暂存区 =&gt; 版本库 =&gt; 远程仓库<br><img src="/images/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.jpg" alt="Git常用命令（来自@菜鸟教程）"><br><img src="/images/Git%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="Git关系图（来自@菜鸟教程）"></p><h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p><code>git init</code> 在当前目录新建一个 Git 仓库，会在当前目录生成一个 <code>.git</code> 目录</p><p><code>git init &lt;dirName&gt;</code> 在当前目录新建一个 <code>dirName</code> Git 仓库目录，会在 <code>dirName</code> 目录生成一个 <code>.git</code> 目录</p><h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p><code>git clone &lt;repo&gt;</code> 从 <code>repo</code> 地址克隆仓库到当前目录，<code>repo</code> 地址可以是 URL 地址也可以是本地地址</p><p><code>git clone &lt;repo&gt; &lt;dirName&gt;</code> 从 <code>repo</code> 地址克隆仓库到当前目录下的 <code>dirName</code> 目录</p><h1 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h1><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p><code>git add &lt;fileName&gt;</code> 添加当前目录下的 <code>fileName</code> 文件到暂存区（可同时添加多个）</p><p><code>git add &lt;dirName&gt;</code> 添加当前目录下的 <code>dirName</code> 目录到暂存区</p><p><code>git add .</code> 添加当前目录下的所有内容到暂存区</p><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p><code>git commit -m &lt;message&gt;</code> 将暂存区的所有内容提交到版本库，<code>message</code> 是备注信息</p><p><code>git commit &lt;fileName&gt; -m &lt;message&gt;</code> 将暂存区的 <code>fileName</code> 文件提交到版本库（可同时提交多个）</p><p><code>git commit -a</code> 修改文件后不需要执行 <code>git add</code> 命令，直接提交</p><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><p><code>git checkout &lt;fileName&gt;</code> 从暂存区回退 <code>fileName</code> 文件到工作区</p><p><code>git checkout .</code> 从暂存区回退所有内容到工作区</p><p><code>git checkout &lt;commit&gt; &lt;fileName&gt;</code> 从版本库的 <code>commit</code> 版本回退 <code>fileName</code> 文件到暂存区和工作区</p><p><code>git reset HEAD^</code> 重置暂存区所有内容到上个版本，但工作区不变</p><p><code>git reset HEAD^^</code> 重置暂存区所有内容到上上个版本，但工作区不变</p><p><code>git reset --hard</code> 重置暂存区与工作区所有内容到上个版本</p><p><code>git reset &lt;fileName&gt;</code> 重置暂存区 <code>fileName</code> 文件到上个版本，但工作区不变</p><p><code>git reset &lt;commit&gt;</code> 重置当前分支的指针为 <code>commit</code> 版本，但工作区不变</p><p><code>git reset --keep &lt;commit&gt;</code> 重置当前分支的 HEAD 为指定 <code>commit</code> 版本，但保持暂存区和工作区不变</p><p><code>git reset --hard &lt;commit&gt;</code> 重置当前分支的 HEAD 为指定 <code>commit</code> 版本，同时重置暂存区和工作区为 <code>commit</code> 版本</p><p><code>git revert &lt;commit&gt;</code> 新建 <code>commit</code> 版本用来撤销旧版本，后者的所有变化都将被前者抵消，并且应用到当前分支</p><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><p><code>git status</code> 查看当前版本状态（在你上次提交之后是否有对文件进行再次修改）</p><p><code>git status -s</code> 获得简短的结果</p><h2 id="删除工作区文件"><a href="#删除工作区文件" class="headerlink" title="删除工作区文件"></a>删除工作区文件</h2><p><a href="https://www.runoob.com/git/git-rm.html">https://www.runoob.com/git/git-rm.html</a></p><h2 id="操作工作区文件"><a href="#操作工作区文件" class="headerlink" title="操作工作区文件"></a>操作工作区文件</h2><p><a href="https://www.runoob.com/git/git-mv.html">https://www.runoob.com/git/git-mv.html</a></p><h1 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h1><h2 id="远程仓库的操作"><a href="#远程仓库的操作" class="headerlink" title="远程仓库的操作"></a>远程仓库的操作</h2><p><code>git remote -v</code> 显示远程仓库所有分支的信息</p><p><code>git remote show &lt;remote&gt;</code> 显示远程仓库 <code>remote</code> 分支的信息</p><p><code>git remote add &lt;repo&gt; &lt;url&gt;</code> 添加远程 <code>url</code> 地址仓库，并命名该仓库在本地的名字为 <code>repo</code>（常命名为 <code>origin</code>）</p><h2 id="上传代码并合并"><a href="#上传代码并合并" class="headerlink" title="上传代码并合并"></a>上传代码并合并</h2><p><code>git push &lt;repo&gt; &lt;branchName1&gt;:&lt;branchName2&gt;</code> 上传本地仓库的 <code>branchName1</code> 分支到远程 <code>repo</code> 仓库的 <code>branchName2</code> 分支</p><p><code>git push &lt;repo&gt; &lt;branchName&gt;</code> 上传本地仓库的 <code>branchName</code> 分支到远程 <code>repo</code> 仓库的 <code>branchName</code> 分支（本地分支名与远程分支名相同）</p><p><code>git push &lt;repo&gt; --force</code> 强行推送本地仓库的当前分支到远程 <code>repo</code> 仓库，即使有冲突（本地分支名与远程分支名相同）</p><p><code>git push &lt;repo&gt; --all</code> 推送本地仓库的所有分支到远程 <code>repo</code> 仓库</p><h2 id="下载代码并合并"><a href="#下载代码并合并" class="headerlink" title="下载代码并合并"></a>下载代码并合并</h2><p><code>git pull &lt;repo&gt; &lt;branchName1&gt;:&lt;branchName2&gt;</code> 从远程 <code>repo</code> 仓库下载 <code>branchName1</code> 分支到本地仓库 branchName2 分支</p><p><code>git pull &lt;repo&gt; &lt;branchName&gt;</code> 从远程 <code>repo</code> 仓库下载 <code>branchName</code> 分支到本地仓库 <code>branchName</code> 分支（本地分支名与远程分支名相同）</p><h2 id="从远程获取代码库"><a href="#从远程获取代码库" class="headerlink" title="从远程获取代码库"></a>从远程获取代码库</h2><p><code>git fetch &lt;repo&gt;</code> 下载远程 <code>repo</code> 仓库的所有变动</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h2><p><code>git branch</code> 列出所有本地分支</p><p><code>git branch -r</code> 列出所有远程分支</p><p><code>git branch -a</code> 列出所有本地分支和远程分支</p><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p><code>git branch &lt;branchName&gt;</code> 新建 <code>branchName</code> 分支，但依然停留在当前分支</p><p><code>git checkout -b &lt;branchName&gt;</code> 新建 <code>branchName</code> 分支并立即切换到该分支下</p><p><code>git branch &lt;branchName&gt; &lt;version&gt;</code> 新建 <code>branchName</code> 分支，指向版本库的指定版本</p><p><code>git branch --track &lt;branchName&gt; &lt;remoteBranch&gt;</code> 新建 <code>branchName</code> 分支，与远程的 <code>remoteBranch</code> 分支建立追踪关系</p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p><code>git checkout &lt;branchName&gt;</code> 从当前分支切换到 <code>branchName</code> 分支</p><p><code>git checkout -</code> 从当前分支切换到切换到上一个分支</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p><code>git branch -d &lt;branchName&gt;</code> 删除本地 <code>branchName</code> 分支</p><p><code>git branch -d -r &lt;repo&gt; &lt;branchName&gt;</code> 删除远程 <code>repo</code> 仓库的 <code>branchName</code> 分支</p><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p><code>git merge &lt;branchName&gt;</code> 合并 <code>branchName</code> 分支到当前分支</p><p><code>git cherry-pick &lt;version&gt;</code> 从版本库选择一个版本合并进当前分支</p><h2 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h2><p><code>git branch -M &lt;oldbranchName&gt; &lt;newbranchName&gt;</code> 将本地 <code>oldbranchName</code> 分支重命名为 <code>newbranchName</code></p><p>重命名远程分支的做法：删除远程待修改分支后上传本地分支到远程</p><h1 id="查看提交"><a href="#查看提交" class="headerlink" title="查看提交"></a>查看提交</h1><h2 id="查看历史提交记录"><a href="#查看历史提交记录" class="headerlink" title="查看历史提交记录"></a>查看历史提交记录</h2><p><code>git log</code> 查看历史提交记录（从近到远）</p><p><code>git log --oneline</code> 查看历史记录的简洁版本</p><p><code>git log --graph</code> 查看历史中何时出现分支和合并</p><p><code>git log --reverse</code> 逆向查看历史提交记录（从远到近）</p><h2 id="查看指定文件历史修改记录"><a href="#查看指定文件历史修改记录" class="headerlink" title="查看指定文件历史修改记录"></a>查看指定文件历史修改记录</h2><p><code>git blame &lt;fileName&gt;</code> 以列表形式查看 <code>fileName</code> 文件的历史修改记录</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><p><code>git tag</code> 列出所有标签</p><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p><code>git tag &lt;tagName&gt;</code> 新建名为 <code>tagName</code> 标签</p><h1 id="选项解释"><a href="#选项解释" class="headerlink" title="选项解释"></a>选项解释</h1><ul><li>-f –force：强制</li><li>-d –delete：删除</li><li>-D –delete –force 的快捷键</li><li>-m –move：移动或重命名</li><li>-M –move –force 的快捷键</li><li>-r –remote：远程</li><li>-a –all：所有</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据类型</title>
    <link href="/2021/07/17/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/07/17/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>ECMAScript 目前有数据类型：Undefined、Null、Boolean、Number、String、Symbol、BigInt、Object。<br>前 7 种为简单数据类型（也称基本类型、基本值），最后 1 种为复杂数据类型（也称引用类型、引用值）。</p><p>在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述数据类型之一来表示。只有 8 种数据类型似乎不足以表示全部数据。但 ECMAScript 数据类型很灵活，一种数据类型可以当作多种数据类型来使用。</p><h1 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h1><p>Undefined 类型只有一个值：特殊值 <code>undefined</code>。  </p><p>当使用 var 或 let 声明了、但是没有初始化的变量时，就相当于给变量赋予了 undefined 值。一般来说，永远不用显式地给某个变量设 undefined 值。因为在默认情况下，任何未经初始化的变量的值都是 undefined 。undefined 值主要用于比较，增加这个特殊值就是为了正式明确空对象指针（null）和未初始化变量的区别。  </p><p>无论是声明了、但是没有初始化的变量还是未声明的变量，对其使用 typeof 返回的都是字符串”undefined”。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。  </p><p>需要注意，声明了、但是没有初始化的变量和未声明的变量还是有区别的。声明了、但是没有初始化的 undefined 值变量可以被打印，未声明定义的变量打印会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 未声明的变量 a</span><br><span class="hljs-keyword">let</span> b; <span class="hljs-comment">// 声明了、但是没有初始化的变量 b</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 显式地设 undefined 值的变量 c</span><br><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// Uncaught ReferenceError: a is not defined at &lt;anonymous&gt;:3:13</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &#x27;undefined&#x27;</span><br><span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &#x27;undefined&#x27;</span><br><span class="hljs-keyword">typeof</span> c; <span class="hljs-comment">// &#x27;undefined&#x27;</span><br>b === c; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h1><p>Null 类型只有一个值：特殊值 <code>null</code>。  </p><p>逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传 null 值返回”object”的原因。  </p><p>undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等。用等于操作符（==）比较 null 和 undefined 返回 true，用全等操作符（===）比较 null 和 undefined 返回 false。  </p><p>即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其与 undefined 区分开来。</p><h1 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h1><p>Boolean 类型有两个字面值：<code>true</code> 和 <code>false</code>。  </p><p>这两个布尔值不同于数值， true 不等于 1，false 不等于 0。布尔值字面量 true 和 false 都是区分大小写的，因此 True 和 False 之类是有效的标识符，但不是布尔值。</p><p>虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型值转换为布尔值，可以调用特定的<code>Boolean()</code>转型函数（将要转型的值作为参数传入）。<code>Boolean()</code>转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。</p><p>下表总结了不同类型与布尔值之间的转换规则：</p><table><thead><tr><th>数据类型</th><th>转换为 true 的值</th><th>转换为 false 的值</th></tr></thead><tbody><tr><td>Undefined</td><td>无</td><td>undfined</td></tr><tr><td>Null</td><td>无</td><td>null</td></tr><tr><td>String</td><td>非空字符串</td><td>空字符串</td></tr><tr><td>Nmuber</td><td>非零数值</td><td>0 、NaN</td></tr><tr><td>Symbol</td><td>任意值</td><td>无</td></tr><tr><td>BigInt</td><td>任意值</td><td>无</td></tr><tr><td>Object</td><td>任意值</td><td>无</td></tr></tbody></table><h1 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h1><p>Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p><p>最基本的数值字面量格式是十进制整数，直接写出来即可。整数也可以用八进制或者十六进制字面量表示。但是，使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。  </p><ul><li>八进制字面量，第一个数字必须是零（0），然后是八进制数字（数值 0~7）。<br>如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。</li><li>十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0~9 及 A~F）。<br>十六进制数字中的字母大小写均可。  </li></ul><p>正零（+0）和负零（-0）在所有情况下都被认为是等同的，除了使用 Object.is() 方法时。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少含有一个非零数字。虽然小数点前面不是必须有整数，但推荐加上。  </p><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数。</p><p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。在 ECMAScript 中，科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写字母 e，再加上一个要乘的 10 的多少次幂。对非常小的数值，默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法。</p><p>浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。因为使用了 IEEE 754 数值，所以存在舍入错误，因此永远不要测试某个特定的浮点值。</p><h2 id="值的范围"><a href="#值的范围" class="headerlink" title="值的范围"></a>值的范围</h2><p>由于内存的限制，ECMAScript 不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.7976931348623157e+308。</p><p>如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity 表示，任何无法表示的正数以 Infinity 表示。</p><p>如果计算返回 +Infinity 或 -Infinity，则该值将不能再进一步用于任何计算。这是因为 Infinity 没有可用于计算的数值表示形式。若要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 <code>isFinite()</code> 函数（将要检测的值作为参数传入）。</p><h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或 -0 相除会返回 NaN，如果分子是非 0 值，分母是有符号或无符号 0，则会返回 Infinity 或-Infinity。</p><p>NaN 有几个独特的属性：</p><ul><li>任何涉及 NaN 的操作始终返回 NaN</li><li>NaN 不等于包括 NaN 在内的任何值</li><li>ECMAScript 提供 <code>isNaN()</code> 函数（将要检测的值作为参数传入）。参数可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 <code>isNaN()</code> 函数后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，任何不能转换为数值的值都会导致这个函数返回 true。</li></ul><p>虽然不常见，但 isNaN() 函数可以用于测试对象。此时，首先会调用对象的 valueOf() 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString() 方法，并测试其返回值。这通常是 ECMAScript 内置函数和操作符的工作方式。</p><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>有 3 个函数可以将非数值转换为数值： <code>Number()</code> 、 <code>parseInt()</code> 和 <code>parseFloat()</code> 。</p><h1 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h1><p>String 类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）来标示。跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript 语法中表示字符串的引号没有区别。不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p><h1 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h1><p>Symbol 类型是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p><p>尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的（尤其是因为 Object API 提供了方法，可以更方便地发现符号属性）。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p><h1 id="BigInt-类型"><a href="#BigInt-类型" class="headerlink" title="BigInt 类型"></a>BigInt 类型</h1><h1 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h1><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法。</p><p>ECMAScript 只要求在给构造函数提供参数时使用括号。如果没有参数，那么完全可以省略括号（不推荐）。</p><p>Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 Object 实例都有如下属性和方法：</p><ul><li>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object() 函数。</li><li>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty(“name”)）或符号。</li><li>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。</li><li>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用 for-in 语句枚举。与hasOwnProperty() 一样，属性名必须是字符串。</li><li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li><li>toString()：返回对象的字符串表示。</li><li>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。</li></ul><h1 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h1><p>因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型，<code>typeof</code> 操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一</p><table><thead><tr><th align="center">字符串</th><th align="center">表示值</th></tr></thead><tbody><tr><td align="center">“undefined”</td><td align="center">未定义</td></tr><tr><td align="center">“boolean”</td><td align="center">布尔值</td></tr><tr><td align="center">“number”</td><td align="center">数值</td></tr><tr><td align="center">“string”</td><td align="center">字符串</td></tr><tr><td align="center">“symbol”</td><td align="center">符号</td></tr><tr><td align="center">“bigint”</td><td align="center">任意大的整数</td></tr><tr><td align="center">“object”</td><td align="center">对象或 null</td></tr><tr><td align="center">“function”</td><td align="center">函数</td></tr></tbody></table><p>typeof 在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。如：</p><ul><li>对 null 使用 typeof 会返回”object”。这是因为，null 表示一个对空对象的引用。  </li><li>对函数使用 typeof 会返回”function”。这是因为，虽然函数被认为是可执行的 Object 类型变量，不代表一种数据类型，但函数有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">null</span> === <span class="hljs-literal">null</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">undefined</span> === <span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> + <span class="hljs-literal">null</span> <span class="hljs-comment">// 1</span><br><span class="hljs-number">1</span>+ <span class="hljs-literal">undefined</span> <span class="hljs-comment">// NaN</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] + <span class="hljs-number">10</span> <span class="hljs-comment">// &#x27;1,2,,4,510&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语言基础之数据类型</title>
    <link href="/2021/07/17/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/07/17/JavaScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>ECMAScript 目前有数据类型：Undefined、Null、Boolean、Number、String、Symbol、BigInt、Object。<br>前 7 种为简单数据类型（也称基本类型、原始类型、基本值），最后 1 种为复杂数据类型（也称引用类型、引用值）。</p><p>在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述数据类型之一来表示。ECMAScript 数据类型很灵活，一种数据类型可以当作多种数据类型来使用。</p><h1 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h1><p>Undefined 类型只有一个值：特殊值 <code>undefined</code>。  </p><p>当使用 <code>var</code> 或 <code>let</code> 声明了、但是没有初始化的变量时，就相当于给变量赋予了 <code>undefined</code> 值。一般来说，永远不用显式地给某个变量设 <code>undefined</code> 值。因为在默认情况下，任何未经初始化的变量的值都是 <code>undefined</code>。<code>undefined</code> 值主要用于比较，增加这个特殊值就是为了正式明确空对象指针（<code>null</code>）和未初始化变量（<code>undefined</code>）的区别。  </p><p>无论是<strong>声明了但未初始化的变量</strong>还是<strong>未声明的变量</strong>，对其使用 <code>typeof</code> 返回的都是”undefined”。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><p>需要注意的是，声明了但未初始化的变量和未声明的变量还是有区别的。声明了但未初始化的变量可以被打印，未声明定义的变量打印会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 未声明的变量 a</span><br><span class="hljs-keyword">let</span> b; <span class="hljs-comment">// 声明了但未初始化的变量 b</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 显式地设 undefined 值的变量 c</span><br><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// Uncaught ReferenceError: a is not defined at &lt;anonymous&gt;:3:13</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &#x27;undefined&#x27;</span><br><span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &#x27;undefined&#x27;</span><br><span class="hljs-keyword">typeof</span> c; <span class="hljs-comment">// &#x27;undefined&#x27;</span><br>b === c; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h1><p>Null 类型只有一个值：特殊值 <code>null</code>。</p><p>逻辑上讲，<code>null</code> 值表示一个空对象指针，这也是给 <code>typeof</code> 传 <code>null</code> 值返回”object”的原因。  </p><p><code>undefined</code> 值是由 <code>null</code> 值派生而来的，因此 ECMA-262 将它们定义为表面上相等。用等于操作符（==）比较两者返回 true，用全等操作符（===）比较两者返回 false。  </p><p>即使 <code>null</code> 和 <code>undefined</code> 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为 <code>undefined</code>。但 <code>null</code> 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 <code>null</code> 来填充该变量。这样就可以保持 <code>null</code> 是空对象指针的语义，并进一步将其与 <code>undefined</code> 区分开来。</p><h1 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h1><p>Boolean 类型有两个字面值：<code>true</code> 和 <code>false</code>。  </p><p>这两个布尔值不同于数值，<code>true</code> 不等于 1，<code>false</code> 不等于 0。</p><p>虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型值转换为布尔值，可以调用特定的 <code>Boolean()</code> 转型函数（将要转型的值作为参数传入）。<code>Boolean()</code> 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。</p><p>下表总结了不同类型与布尔值之间的转换规则：</p><table><thead><tr><th align="center">数据类型</th><th align="center">转换为 <code>true</code> 的值</th><th align="center">转换为 <code>false</code> 的值</th></tr></thead><tbody><tr><td align="center">Undefined</td><td align="center">无</td><td align="center">undfined</td></tr><tr><td align="center">Null</td><td align="center">无</td><td align="center">null</td></tr><tr><td align="center">String</td><td align="center">非空字符串</td><td align="center">空字符串</td></tr><tr><td align="center">Nmuber</td><td align="center">非零数值</td><td align="center">0 、NaN</td></tr><tr><td align="center">Symbol</td><td align="center">任意值</td><td align="center">无</td></tr><tr><td align="center">BigInt</td><td align="center">任意值</td><td align="center">无</td></tr><tr><td align="center">Object</td><td align="center">任意值</td><td align="center">无</td></tr></tbody></table><h1 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h1><p>Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p><p>最基本的数值字面量格式是十进制整数，直接写出来即可。整数也可以用八进制或者十六进制字面量表示。但是，使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。  </p><ul><li>八进制字面量，第一个数字必须是 <code>0</code>（零），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。</li><li>十六进制字面量，必须让真正的数值前缀 <code>0x</code>（区分大小写），然后是相应的十六进制数字（0~9 及 A~F）。十六进制数字中的字母大小写均可。  </li></ul><p>正零（+0）和负零（-0）在所有情况下都被认为是等同的，除了使用 <code>Object.is()</code> 方法时。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少含有一个非零数字。虽然小数点前面不是必须有整数，但推荐加上。  </p><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数。</p><p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。在 ECMAScript 中，科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写字母 e，再加上一个要乘的 10 的多少次幂。对非常小的数值，默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法。</p><p>浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。因为使用了 IEEE 754 数值，所以存在舍入错误，因此永远不要测试某个特定的浮点值。</p><h2 id="值的范围"><a href="#值的范围" class="headerlink" title="值的范围"></a>值的范围</h2><p>由于内存的限制，ECMAScript 不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 <code>Number.MIN_VALUE</code> 中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保存在 <code>Number.MAX_VALUE</code> 中，这个值在多数浏览器中是 1.7976931348623157e+308。</p><p>如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 <code>Infinity</code>（无穷）值。任何无法表示的负数以 <code>-Infinity</code> 表示，任何无法表示的正数以 <code>Infinity</code> 表示。</p><p>如果计算返回 <code>+Infinity</code> 或 <code>-Infinity</code>，则该值将不能再进一步用于任何计算。这是因为 <code>Infinity</code> 没有可用于计算的数值表示形式。若要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 <code>isFinite()</code> 函数（将要检测的值作为参数传入）。虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果是否超出范围。</p><p>此外，<code>Number.NEGATIVE_INFINITY</code> 和 <code>Number.POSITIVE_INFINITY</code> 这两个属性的值分别是 <code>-Infinity</code> 和 <code>Infinity</code>。</p><h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a><code>NaN</code></h2><p>有一个特殊的数值叫 <code>NaN</code>，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中 0、+0 或 -0 相除会返回 <code>NaN</code>，如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 <code>Infinity</code> 或 <code>-Infinity</code>。</p><p><code>NaN</code> 有几个独特的属性：</p><ul><li>任何涉及 <code>NaN</code> 的操作始终返回 <code>NaN</code></li><li><code>NaN</code> 不等于包括 <code>NaN</code> 在内的任何值</li><li>ECMAScript 提供 <code>isNaN()</code> 函数（将要检测的值作为参数传入）。参数可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 <code>isNaN()</code> 函数后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，任何不能转换为数值的值都会导致这个函数返回 <code>true</code>。</li></ul><p>虽然不常见，但 <code>isNaN()</code> 函数可以用于测试对象。此时，首先会调用对象的 <code>valueOf()</code> 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 <code>toString()</code> 方法，并测试其返回值。这通常是 ECMAScript 内置函数和操作符的工作方式。</p><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>有 3 个函数可以将非数值转换为数值： <code>Number()</code> 、 <code>parseInt()</code> 、 <code>parseFloat()</code> 。第一个是转型函数，可用于任何数据类型，后两个主要用于将字符串转换为数据。对于同样的参数，这 3 个函数执行的操作也不同。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a><code>Number()</code></h3><p>基于如下规则执行转换。</p><ul><li>布尔值，<code>true</code> 转换为 1，<code>false</code> 转换为 0。</li><li>数值，直接返回。</li><li>null，返回 0。</li><li>undefined，返回 <code>NaN</code>。</li><li>字符串，应用以下规则。<ul><li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。</li><li>如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（忽略前面的零）。</li><li>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。</li><li>如果是空字符串（不包含字符），则返回 0。</li><li>如果字符串包含除上述情况之外的其他字符，则返回 <code>NaN</code>。</li></ul></li><li>对象，调用 <code>valueOf()</code> 方法，并按照上述规则转换返回的值。如果转换结果是 <code>NaN</code>，则调用 <code>toString()</code> 方法，再按照转换字符串的规则转换。</li></ul><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a><code>parseInt()</code></h3><p>用 <code>Number()</code> 函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用 <code>parseInt()</code> 函数。</p><p><code>parseInt()</code> 函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code>立即返回 <code>NaN</code>。这意味着空字符串也会返回 <code>NaN</code>（这一点跟 <code>Number()</code>不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为 1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为 22，因为小数点不是有效的整数字符。</p><p>假设字符串中的第一个字符是数值字符，<code>parseInt()</code>函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。</p><p>不同的数值格式很容易混淆，因此 <code>parseInt()</code> 也接收第二个参数，用于指定底数（进制数）。通过第二个参数，可以极大扩展转换后获得的结果类型。不传底数参数相当于让 parseInt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。</p><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a><code>parseFloat()</code></h3><p><code>parseFloat()</code> 函数的工作方式跟 <code>parseInt()</code> 函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，”22.34.5”将转换成 22.34。</p><p><code>parseFloat()</code> 函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0。因为 <code>parseFloat()</code> 函数只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则 <code>parseFloat()</code> 返回整数。</p><h1 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h1><p>String 类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）来标示。跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript 语法中表示字符串的引号没有区别。不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p><h2 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h2><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符。如：</p><table><thead><tr><th align="center">字面量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">制表</td></tr><tr><td align="center">\b</td><td align="center">退格</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\f</td><td align="center">换页</td></tr><tr><td align="center">\\</td><td align="center">反斜杠</td></tr><tr><td align="center">\‘</td><td align="center">单引号</td></tr><tr><td align="center">\“</td><td align="center">双引号</td></tr><tr><td align="center">\`</td><td align="center">反引号</td></tr><tr><td align="center">\xnn</td><td align="center">以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F）</td></tr><tr><td align="center">\unnnn</td><td align="center">以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F）</td></tr></tbody></table><p>注意，因为转义序列表示一个字符，所以只算一个字符。</p><h2 id="字符串特点"><a href="#字符串特点" class="headerlink" title="字符串特点"></a>字符串特点</h2><p>ECMAScript 中的字符串是不可变的，一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。</p><h2 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h2><p>两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 <code>toString()</code> 方法。这个方法唯一的用途就是返回当前值的字符串等价物。其次就是 <code>String()</code> 转型函数。</p><p><code>toString()</code> 方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 <code>toString()</code> 方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 <code>toString()</code> 方法。多数情况下，<code>toString()</code> 不接收任何参数。不过，在对数值调用这个方法时可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，<code>toString()</code> 返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示。</p><p>如果不确定一个值是不是 <code>null</code> 或 <code>undefined</code>，可以使用 <code>String()</code> 转型函数，它始终会返回表示相应类型值的字符串。<code>String()</code> 函数遵循如下规则。</p><ul><li>如果值有 <code>toString()</code> 方法，则调用该方法（不传参数）并返回结果。</li><li>如果值是 <code>null</code>，返回”null”。</li><li>如果值是 <code>undefined</code>，返回”undefined”。</li></ul><h2 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h2><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串。所以，模板字面量在定义模板时特别有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myMultiLineString = <span class="hljs-string">&#x27;first line\nsecond line&#x27;</span>; <br><span class="hljs-keyword">let</span> myMultiLineTemplateLiteral = <span class="hljs-string">`first line </span><br><span class="hljs-string">second line`</span>; <br><span class="hljs-built_in">console</span>.log(myMultiLineString); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line</span><br><span class="hljs-built_in">console</span>.log(myMultiLineTemplateLiteral); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line</span><br></code></pre></td></tr></table></figure><p>由于模板字面量会保持反引号内部的空格，因此在使用它时要格外注意。格式正确的模板字符串看起来可能会缩进不当。</p><h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。</p><p>模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。字符串插值通过在 <code>$&#123;&#125;</code> 中使用一个 JavaScript 表达式实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> value = <span class="hljs-number">5</span>; <br><span class="hljs-keyword">let</span> exponent = <span class="hljs-string">&#x27;second&#x27;</span>; <br><span class="hljs-keyword">let</span> interpolatedString = value + <span class="hljs-string">&#x27; to the &#x27;</span> + exponent + <span class="hljs-string">&#x27; power is &#x27;</span> + (value * value); <br><span class="hljs-keyword">let</span> interpolatedTemplateLiteral = <span class="hljs-string">`<span class="hljs-subst">$&#123; value &#125;</span> to the <span class="hljs-subst">$&#123; exponent &#125;</span> power is <span class="hljs-subst">$&#123; value * value &#125;</span>`</span>; <br><span class="hljs-built_in">console</span>.log(interpolatedString);          <span class="hljs-comment">// 5 to the second power is 25 </span><br><span class="hljs-built_in">console</span>.log(interpolatedTemplateLiteral); <span class="hljs-comment">// 5 to the second power is 25</span><br></code></pre></td></tr></table></figure><p>所有插入的值都会用 <code>toString()</code> 强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义。在插值表达式中可以调用函数和方法，模板也可以插入自己之前的值。</p><h2 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h2><p>模板字面量也支持定义标签函数，通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。</p><p>因为表达式参数的数量是可变的，所以通常应该使用剩余操作符将它们收集到一个数组中。对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。</p><h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此可以使用默认的 <code>String.raw</code> 标签函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\u00A9`</span>);           <span class="hljs-comment">// © </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>.raw<span class="hljs-string">`\u00A9`</span>); <span class="hljs-comment">// \u00A9 </span><br></code></pre></td></tr></table></figure><p>另外，也可以通过标签函数的第一个参数，即字符串数组的 <code>.raw</code> 属性取得每个字符串的原始内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printRaw</span>(<span class="hljs-params">strings</span>) </span>&#123; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Actual characters:&#x27;</span>); <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> string <span class="hljs-keyword">of</span> strings) &#123; <br>    <span class="hljs-built_in">console</span>.log(string); <br>  &#125; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Escaped characters:&#x27;</span>); <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rawString <span class="hljs-keyword">of</span> strings.raw) &#123; <br>    <span class="hljs-built_in">console</span>.log(rawString); <br>  &#125; <br>&#125; <br>printRaw<span class="hljs-string">`\u00A9<span class="hljs-subst">$&#123; <span class="hljs-string">&#x27;and&#x27;</span> &#125;</span>\n`</span>; <br><span class="hljs-comment">// Actual characters: </span><br><span class="hljs-comment">// © </span><br><span class="hljs-comment">//（换行符）</span><br><span class="hljs-comment">// Escaped characters: </span><br><span class="hljs-comment">// \u00A9 </span><br><span class="hljs-comment">// \n </span><br></code></pre></td></tr></table></figure><h1 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h1><p>Symbol 类型是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p><p>尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的（尤其是因为 Object API 提供了方法，可以更方便地发现符号属性）。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p><h1 id="BigInt-类型"><a href="#BigInt-类型" class="headerlink" title="BigInt 类型"></a>BigInt 类型</h1><h1 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h1><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 <code>new</code> 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法。</p><p>ECMAScript 只要求在给构造函数提供参数时使用括号。如果没有参数，那么完全可以省略括号（不推荐这样使用）。</p><p>Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 Object 实例都有如下属性和方法：</p><ul><li><code>constructor</code>：用于创建当前对象的函数。</li><li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串或符号。</li><li><code>isPrototypeOf(object)</code>：用于判断当前对象是否为另一个对象的原型。</li><li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用 <code>for-in</code> 语句枚举。与 <code>hasOwnProperty()</code> 一样，属性名必须是字符串。</li><li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li><li><code>toString()</code>：返回对象的字符串表示。</li><li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与 <code>toString()</code> 的返回值相同。</li></ul><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><p>ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型，<code>typeof</code> 操作符就是为此而生的。对一个值使用 <code>typeof</code> 操作符会返回下列字符串之一：</p><table><thead><tr><th align="center">字符串</th><th align="center">表示值</th></tr></thead><tbody><tr><td align="center">“undefined”</td><td align="center">未定义</td></tr><tr><td align="center">“boolean”</td><td align="center">布尔值</td></tr><tr><td align="center">“number”</td><td align="center">数值</td></tr><tr><td align="center">“string”</td><td align="center">字符串</td></tr><tr><td align="center">“symbol”</td><td align="center">符号</td></tr><tr><td align="center">“bigint”</td><td align="center">任意大的整数</td></tr><tr><td align="center">“object”</td><td align="center">对象或 null</td></tr><tr><td align="center">“function”</td><td align="center">函数</td></tr></tbody></table><p><code>typeof</code> 在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。如：</p><ul><li>对 null 使用 <code>typeof</code> 会返回”object”。这是因为，null 表示一个对空对象的引用。  </li><li>对函数使用 <code>typeof</code> 会返回”function”。这是因为，虽然函数被认为是可执行的 Object 类型变量，不代表一种数据类型，但函数有自己特殊的属性。为此，就有必要通过 <code>typeof</code> 操作符来区分函数和其他对象。</li></ul><h1 id="相关示例"><a href="#相关示例" class="headerlink" title="相关示例"></a>相关示例</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">null</span> === <span class="hljs-literal">null</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">undefined</span> === <span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> + <span class="hljs-literal">null</span> <span class="hljs-comment">// 1</span><br><span class="hljs-number">1</span>+ <span class="hljs-literal">undefined</span> <span class="hljs-comment">// NaN</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] + <span class="hljs-number">10</span> <span class="hljs-comment">// &#x27;1,2,,4,510&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript面试题</title>
    <link href="/2021/07/16/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/07/16/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h1><table><thead><tr><th align="center">操作符</th><th align="center">自有属性</th><th align="center">继承属性</th><th align="center">可枚举属性</th><th align="center">不可枚举属性</th></tr></thead><tbody><tr><td align="center">in操作符</td><td align="center">返回</td><td align="center">返回</td><td align="center">返回</td><td align="center">返回</td></tr><tr><td align="center">for/in循环</td><td align="center">返回</td><td align="center">返回</td><td align="center">返回</td><td align="center">不返回</td></tr><tr><td align="center">hasOwnProperty()</td><td align="center">返回</td><td align="center">不返回</td><td align="center">返回</td><td align="center">返回</td></tr><tr><td align="center">propertyIsEnumerable()</td><td align="center">返回</td><td align="center">不返回</td><td align="center">返回</td><td align="center">不返回</td></tr><tr><td align="center">Object.keys()</td><td align="center">返回</td><td align="center">不返回</td><td align="center">返回</td><td align="center">不返回</td></tr><tr><td align="center">Object.getOwnPropertyNames()</td><td align="center">返回</td><td align="center">不返回</td><td align="center">返回</td><td align="center">返回</td></tr><tr><td align="center">Reflect.ownKeys()</td><td align="center">返回</td><td align="center">不返回</td><td align="center">返回</td><td align="center">返回</td></tr></tbody></table><h1 id="虚拟-DOM-和-diff-算法"><a href="#虚拟-DOM-和-diff-算法" class="headerlink" title="虚拟 DOM 和 diff 算法"></a>虚拟 DOM 和 diff 算法</h1><p>参考：<a href="https://juejin.cn/post/6994959998283907102">https://juejin.cn/post/6994959998283907102</a> 。</p><p>好处：</p><ul><li>跨平台</li><li>只需要操作数据，开发效率更高</li><li>通过 DOM diff 算法，可减少不必要的 DOM 操作，提高性能</li></ul><h1 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h1><p>可迭代对象是指实现了<code>[Symbol.iterator]</code>方法属性的对象。注意，区分类数组对象。<br>类数组对象（伪数组对象）是指可以通过索引属性访问元素并且拥有一个 <code>length</code> 属性的对象。<br>可迭代对象和类数组对象并非是相互排斥的。比如，字符串既是可迭代对象又是类数组对象。</p><p>迭代器模式（特别是在 ECMAScript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。</p><p>可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序。不过，可迭代对象不一定都是集合对象，也可以是仅仅具有类似数组行为的其他数据结构。基本上，可以使用 for…of 循环的对象都是可迭代对象。</p><h1 id="ES6-新语法"><a href="#ES6-新语法" class="headerlink" title="ES6 新语法"></a>ES6 新语法</h1><p>参考：<br><a href="https://juejin.cn/post/6854818580660387853">https://juejin.cn/post/6854818580660387853</a> 。<br><a href="https://juejin.cn/post/6844903581426925581">https://juejin.cn/post/6844903581426925581</a> 。</p><ul><li>let、const</li><li>Set、Map、Symbol</li><li>for-of/for-in</li><li>模块导入导出</li><li>函数默认参数</li><li>箭头函数</li><li>类</li><li>展开运算符</li><li>对象的解构</li><li>字符串模版</li></ul><h1 id="箭头函数和普通函数"><a href="#箭头函数和普通函数" class="headerlink" title="箭头函数和普通函数"></a>箭头函数和普通函数</h1><ul><li>箭头函数没有没有原型对象。</li><li>箭头函数 this 值为其所在上下文的 this 值。</li><li>箭头函数箭头函数不能使用 arguments、super、new.target。</li><li>箭头函数不能定义生成器函数。</li></ul><h1 id="for-in-循环和-for-of-循环"><a href="#for-in-循环和-for-of-循环" class="headerlink" title="for-in 循环和 for-of 循环"></a>for-in 循环和 for-of 循环</h1><ul><li>for-in 循环：可用于遍历数组索引下标值和对象键名，大部分用于对象。</li><li>for-of 循环：可用于遍历可迭代对象（Array、String、Map、Set 等等），不能遍历类数组对象和对象。但是 for-of 循环和 Object.keys()、Object.vales()、Object.entries() 配合可用来遍历对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">sfd</span>: <span class="hljs-number">45</span>, <span class="hljs-attr">eee</span>: <span class="hljs-number">93</span> &#125;;<br><span class="hljs-keyword">const</span> b = [<span class="hljs-string">&quot;sfd&quot;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&quot;eee&quot;</span>, <span class="hljs-number">93</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> s <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(s);<br>&#125;<br><span class="hljs-comment">// sfd</span><br><span class="hljs-comment">// eee</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> s <span class="hljs-keyword">in</span> b) &#123;<br>  <span class="hljs-built_in">console</span>.log(s);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> s <span class="hljs-keyword">of</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(s);<br>&#125;<br><span class="hljs-comment">// Uncaught TypeError: a is not iterable</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> s <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(a)) &#123;<br>  <span class="hljs-built_in">console</span>.log(s);<br>&#125;<br><span class="hljs-comment">// sfd</span><br><span class="hljs-comment">// eee</span><br></code></pre></td></tr></table></figure><h1 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h1><ul><li>Object.prototype.toString.call() 方法</li><li>typeof 操作符</li><li>instanceof 操作符</li><li>constructor 属性</li></ul><p>此外，还有 Array.isArray(obj) 方法、isNaN(obj) 方法等可以精准判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> und = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">var</span> nul = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">var</span> boo = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;xys&quot;</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/a/g</span>;<br><span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br><span class="hljs-keyword">var</span> arg;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArg</span>(<span class="hljs-params"></span>) </span>&#123;<br>  arg = <span class="hljs-built_in">arguments</span>;<br>&#125;)();<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(und)); <span class="hljs-comment">// [object Undefined]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(nul)); <span class="hljs-comment">// [object Null]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(boo)); <span class="hljs-comment">// [object Boolean]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(num)); <span class="hljs-comment">// [object Number]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(str)); <span class="hljs-comment">// [object String]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(obj)); <span class="hljs-comment">// [object Object]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(arr)); <span class="hljs-comment">// [object Array]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(fun)); <span class="hljs-comment">// [object Function]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(date)); <span class="hljs-comment">// [object Date]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(reg)); <span class="hljs-comment">// [object RegExp]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(err)); <span class="hljs-comment">// [object Error]</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(arg)); <span class="hljs-comment">// [object Arguments]</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> und); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> nul); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> boo); <span class="hljs-comment">// boolean</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> num); <span class="hljs-comment">// number</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> str); <span class="hljs-comment">// string</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> obj); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> arr); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> fun); <span class="hljs-comment">// function</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> date); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> reg); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> err); <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> arg); <span class="hljs-comment">// object</span><br><br><span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(fun <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(date <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(reg <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(arg <span class="hljs-keyword">instanceof</span> Arguments); <span class="hljs-comment">// true</span><br><br>obj.__proto__.constructor === <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span><br>arr.__proto__.constructor === <span class="hljs-built_in">Array</span>; <span class="hljs-comment">// true</span><br>fun.__proto__.constructor === <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// true</span><br>date.__proto__.constructor === <span class="hljs-built_in">Date</span>; <span class="hljs-comment">// true</span><br>reg.__proto__.constructor === <span class="hljs-built_in">RegExp</span>; <span class="hljs-comment">// true</span><br>err.__proto__.constructor === <span class="hljs-built_in">Error</span>; <span class="hljs-comment">// true</span><br>arg.__proto__.constructor === Arguments; <span class="hljs-comment">// Uncaught ReferenceError</span><br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>Object.prototype.toString.call() 方法是最准确的方法。</li><li>typeof 操作符只用于原始值，对于 Null 类型其返回为 Object。</li><li>instanceof 操作符只用于引用值，且是假定只有一种全局环境，如果网页中包含多个框架多个全局环境，如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</li><li>constructor 属性只用于引用值，而且其可以被重写，所以不一定准确。</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在 C 和 C++ 等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 则为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。</p><p>基本思路很简单：确定哪个变量不会再使用，然后释放它所占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。</p><p>以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。</p><p>JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者，可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程中的实现并不重要，关键是策略。</p><p>垃圾回收程序运行的时候，会标记内存中存储的所有变量（标记方法有很多）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p><ul><li>通过 const 和 let 声明提升性能。</li><li>隐藏类和删除操作。</li></ul><h1 id="event-target-和-event-currentTarget"><a href="#event-target-和-event-currentTarget" class="headerlink" title="event.target 和 event.currentTarget"></a>event.target 和 event.currentTarget</h1><p>在事件处理程序内部，this 对象始终等于 currentTarget 的值，target 只包含事件的实际目标。</p><p>如果事件处理程序直接添加在了意图的目标，则 this、currentTarget 和 target 的值是一样的。如果这个事件处理程序是添加到按钮的父节点（如 document.body）上，那么它们的值就不一样了。由于按钮本身并没有注册事件处理程序，因此 click 事件冒泡到 document.body，从而触发了在它上面注册的处理程序。</p><h1 id="CommonJS-和-ES-Module"><a href="#CommonJS-和-ES-Module" class="headerlink" title="CommonJS 和 ES Module"></a>CommonJS 和 ES Module</h1><p>参考：<a href="https://juejin.cn/post/6994224541312483336">https://juejin.cn/post/6994224541312483336</a> 。</p><ul><li>CommonJS<br>CommonJS 模块由 JS 运行时实现。<br>CommonJs 是单个值导出，本质上导出的就是 exports 属性。<br>CommonJS 是可以动态加载的，对每一个加载都存在缓存，可以有效的解决循环引用问题。<br>CommonJS 模块同步加载并执行模块文件</li><li>ES Module<br>ES6 Module 静态的，不能放在块级作用域内，代码发生在编译时。<br>ES6 Module 的值是动态绑定的，可以通过导出方法修改，可以直接访问修改结果。<br>ES6 Module 可以导出多个属性和方法，可以单个导入导出，混合导入导出。<br>ES6 模块提前加载并执行模块文件，<br>ES6 Module 导入模块在严格模式下。<br>ES6 Module 的特性可以很容易实现 Tree Shaking 和 Code Splitting。</li></ul><h1 id="输出判断题"><a href="#输出判断题" class="headerlink" title="输出判断题"></a>输出判断题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params">aaa, bbb</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(aaa, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], bbb, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>  aaa = <span class="hljs-number">666</span>;<br>  bbb = <span class="hljs-number">777</span>;<br>  <span class="hljs-built_in">console</span>.log(aaa, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], bbb, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">888</span>;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">999</span>;<br>  <span class="hljs-built_in">console</span>.log(aaa, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], bbb, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>&#125;<br>test1(<span class="hljs-number">111</span>, <span class="hljs-number">222</span>);<br><br><span class="hljs-comment">// 111 111 222 222</span><br><span class="hljs-comment">// 666 666 777 777</span><br><span class="hljs-comment">// 888 888 999 999</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], b, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>  a = <span class="hljs-string">&quot;aaa&quot;</span>;<br>  b = <span class="hljs-string">&quot;bbb&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], b, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;trueaaa&quot;</span>;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;truebbb&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], b, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params">a = <span class="hljs-string">&quot;aaabbb&quot;</span>, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], b, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>  a = <span class="hljs-string">&quot;aaa&quot;</span>;<br>  b = <span class="hljs-string">&quot;bbb&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], b, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;trueaaa&quot;</span>;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;truebbb&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], b, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>&#125;<br>test1();<br>test1(<span class="hljs-string">&quot;AAA&quot;</span>);<br>test2();<br>test2(<span class="hljs-string">&quot;AAA&quot;</span>);<br><br><span class="hljs-comment">// undefined undefined undefined undefined</span><br><span class="hljs-comment">// aaa undefined bbb undefined</span><br><span class="hljs-comment">// aaa trueaaa bbb truebbb</span><br><br><span class="hljs-comment">// AAA AAA undefined undefined</span><br><span class="hljs-comment">// aaa aaa bbb undefined</span><br><span class="hljs-comment">// trueaaa trueaaa bbb truebbb</span><br><br><span class="hljs-comment">// aaabbb undefined undefined undefined</span><br><span class="hljs-comment">// aaa undefined bbb undefined</span><br><span class="hljs-comment">// aaa trueaaa bbb truebbb</span><br><br><span class="hljs-comment">// AAA AAA undefined undefined</span><br><span class="hljs-comment">// aaa AAA bbb undefined</span><br><span class="hljs-comment">// aaa trueaaa bbb truebbb</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(arg);<br>  <span class="hljs-keyword">var</span> arg = <span class="hljs-string">&quot;hello1&quot;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arg</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;aaa&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(arg);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(arg);<br>  <span class="hljs-keyword">var</span> arg = <span class="hljs-string">&quot;hello2&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(arg);<br>&#125;<br>test1(<span class="hljs-string">&quot;hi1&quot;</span>);<br>test2(<span class="hljs-string">&quot;hi2&quot;</span>);<br><br><span class="hljs-comment">// ƒ arg() &#123;</span><br><span class="hljs-comment">//   console.log(&#x27;aaa&#x27;)</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// hello1</span><br><span class="hljs-comment">// hi2</span><br><span class="hljs-comment">// hello2</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">type</span>(<span class="hljs-params">t</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(t).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> args;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(type(fn1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)));<br><span class="hljs-built_in">console</span>.log(type(fn2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)));<br><br><span class="hljs-comment">// Array</span><br><span class="hljs-comment">// Arguments</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span><br>a = <span class="hljs-number">12</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><br>  <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initialization</span><br>  a = <span class="hljs-number">13</span>;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">14</span>;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-number">15</span>;<br>  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 14</span><br>&#125;<br>fn();<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// Uncaught ReferenceError: b is not defined</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showcase</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (value) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span>:<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;A&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span>:<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;B&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">undefined</span>:<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;unKnown&quot;</span>);<br>  &#125;<br>&#125;<br>showcase(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;A&quot;</span>))[([<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].reduce(<span class="hljs-built_in">Math</span>.pow), [<span class="hljs-string">&quot;&quot;</span>].reduce(<span class="hljs-built_in">Math</span>.pow))]; <span class="hljs-comment">// &#x27;unKnown&#x27; // [16, &#x27;&#x27;]</span><br><br><span class="hljs-built_in">Symbol</span>() === <span class="hljs-built_in">Symbol</span>(); <span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;aa&quot;</span>) === <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;aa&quot;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.__proto__; <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Array</span>.__proto__ === <span class="hljs-built_in">Function</span>.__proto__; <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Function</span>.prototype === <span class="hljs-built_in">Function</span>.__proto__; <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// ƒ () &#123; [native code] &#125;</span><br><span class="hljs-built_in">Object</span>.prototype.prototype; <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">Object</span>.prototype.__proto__; <span class="hljs-comment">// null</span><br><span class="hljs-built_in">Function</span>.prototype.prototype; <span class="hljs-comment">// undefined</span><br><br><span class="hljs-string">&quot;标准的7个汉字&quot;</span>.length; <span class="hljs-comment">// 7</span><br><span class="hljs-string">&quot;11&quot;</span> == <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-number">11</span>); <span class="hljs-comment">// true</span><br><span class="hljs-string">&quot;11&quot;</span> === <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-number">11</span>); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&quot;afa&quot;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;jodo&quot;</span>);<br><span class="hljs-built_in">Object</span>.prototype.toString.call(s1); <span class="hljs-comment">// &#x27;[object String]&#x27;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(s2); <span class="hljs-comment">// &#x27;[object String]&#x27;</span><br>s1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// false</span><br>s2 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Value is&quot;</span> + (s === <span class="hljs-string">&quot;afa&quot;</span>) ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>); <span class="hljs-comment">// yes</span><br></code></pre></td></tr></table></figure><h1 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">JavaScript 标准内置对象</a></li><li>数据类型（基本/集合）</li><li>原型、原型链、继承</li><li>this 指向</li><li>数组方法</li><li>数组扁平化</li><li>期约（Promise）</li><li>微任务和宏任务</li><li>事件循环</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
